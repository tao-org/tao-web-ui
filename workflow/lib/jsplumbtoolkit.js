/**
 * jsBezier
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * licensed under the MIT license.
 *
 * a set of Bezier curve functions that deal with Beziers, used by jsPlumb, and perhaps useful for other people.  These functions work with Bezier
 * curves of arbitrary degree.
 *
 * - functions are all in the 'jsBezier' namespace.
 *
 * - all input points should be in the format {x:.., y:..}. all output points are in this format too.
 *
 * - all input curves should be in the format [ {x:.., y:..}, {x:.., y:..}, {x:.., y:..}, {x:.., y:..} ]
 *
 * - 'location' as used as an input here refers to a decimal in the range 0-1 inclusive, which indicates a point some proportion along the length
 * of the curve.  location as output has the same format and meaning.
 *
 *
 * Function List:
 * --------------
 *
 * distanceFromCurve(point, curve)
 *
 * 	Calculates the distance that the given point lies from the given Bezier.  Note that it is computed relative to the center of the Bezier,
 * so if you have stroked the curve with a wide pen you may wish to take that into account!  The distance returned is relative to the values
 * of the curve and the point - it will most likely be pixels.
 *
 * gradientAtPoint(curve, location)
 *
 * 	Calculates the gradient to the curve at the given location, as a decimal between 0 and 1 inclusive.
 *
 * gradientAtPointAlongCurveFrom (curve, location)
 *
 *	Calculates the gradient at the point on the given curve that is 'distance' units from location.
 *
 * nearestPointOnCurve(point, curve)
 *
 *	Calculates the nearest point to the given point on the given curve.  The return value of this is a JS object literal, containing both the
 *point's coordinates and also the 'location' of the point (see above), for example:  { point:{x:551,y:150}, location:0.263365 }.
 *
 * pointOnCurve(curve, location)
 *
 * 	Calculates the coordinates of the point on the given Bezier curve at the given location.
 *
 * pointAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the coordinates of the point on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * locationAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the location on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * perpendicularToCurveAt(curve, location, length, distance)
 *
 * 	Calculates the perpendicular to the given curve at the given location.  length is the length of the line you wish for (it will be centered
 * on the point at 'location'). distance is optional, and allows you to specify a point along the path from the given location as the center of
 * the perpendicular returned.  The return value of this is an array of two points: [ {x:...,y:...}, {x:...,y:...} ].
 *
 *
 */

(function() {

    var root = this;

    if(typeof Math.sgn == "undefined") {
        Math.sgn = function(x) { return x == 0 ? 0 : x > 0 ? 1 :-1; };
    }

    var Vectors = {
            subtract 	: 	function(v1, v2) { return {x:v1.x - v2.x, y:v1.y - v2.y }; },
            dotProduct	: 	function(v1, v2) { return (v1.x * v2.x)  + (v1.y * v2.y); },
            square		:	function(v) { return Math.sqrt((v.x * v.x) + (v.y * v.y)); },
            scale		:	function(v, s) { return {x:v.x * s, y:v.y * s }; }
        },

        maxRecursion = 64,
        flatnessTolerance = Math.pow(2.0,-maxRecursion-1);

    /**
     * Calculates the distance that the point lies from the curve.
     *
     * @param point a point in the form {x:567, y:3342}
     * @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently
     * hardcoded to assume cubiz beziers, but would be better off supporting any degree.
     * @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location
     * argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from
     * the point to the curve.
     */
    var _distanceFromCurve = function(point, curve) {
        var candidates = [],
            w = _convertToBezier(point, curve),
            degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            numSolutions = _findRoots(w, higherDegree, candidates, 0),
            v = Vectors.subtract(point, curve[0]), dist = Vectors.square(v), t = 0.0;

        for (var i = 0; i < numSolutions; i++) {
            v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
            var newDist = Vectors.square(v);
            if (newDist < dist) {
                dist = newDist;
                t = candidates[i];
            }
        }
        v = Vectors.subtract(point, curve[degree]);
        newDist = Vectors.square(v);
        if (newDist < dist) {
            dist = newDist;
            t = 1.0;
        }
        return {location:t, distance:dist};
    };
    /**
     * finds the nearest point on the curve to the given point.
     */
    var _nearestPointOnCurve = function(point, curve) {
        var td = _distanceFromCurve(point, curve);
        return {point:_bezier(curve, curve.length - 1, td.location, null, null), location:td.location};
    };
    var _convertToBezier = function(point, curve) {
        var degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            c = [], d = [], cdTable = [], w = [],
            z = [ [1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0] ];

        for (var i = 0; i <= degree; i++) c[i] = Vectors.subtract(curve[i], point);
        for (var i = 0; i <= degree - 1; i++) {
            d[i] = Vectors.subtract(curve[i+1], curve[i]);
            d[i] = Vectors.scale(d[i], 3.0);
        }
        for (var row = 0; row <= degree - 1; row++) {
            for (var column = 0; column <= degree; column++) {
                if (!cdTable[row]) cdTable[row] = [];
                cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
            }
        }
        for (i = 0; i <= higherDegree; i++) {
            if (!w[i]) w[i] = [];
            w[i].y = 0.0;
            w[i].x = parseFloat(i) / higherDegree;
        }
        var n = degree, m = degree-1;
        for (var k = 0; k <= n + m; k++) {
            var lb = Math.max(0, k - m),
                ub = Math.min(k, n);
            for (i = lb; i <= ub; i++) {
                j = k - i;
                w[i+j].y += cdTable[j][i] * z[j][i];
            }
        }
        return w;
    };
    /**
     * counts how many roots there are.
     */
    var _findRoots = function(w, degree, t, depth) {
        var left = [], right = [],
            left_count, right_count,
            left_t = [], right_t = [];

        switch (_getCrossingCount(w, degree)) {
            case 0 : {
                return 0;
            }
            case 1 : {
                if (depth >= maxRecursion) {
                    t[0] = (w[0].x + w[degree].x) / 2.0;
                    return 1;
                }
                if (_isFlatEnough(w, degree)) {
                    t[0] = _computeXIntercept(w, degree);
                    return 1;
                }
                break;
            }
        }
        _bezier(w, degree, 0.5, left, right);
        left_count  = _findRoots(left,  degree, left_t, depth+1);
        right_count = _findRoots(right, degree, right_t, depth+1);
        for (var i = 0; i < left_count; i++) t[i] = left_t[i];
        for (var i = 0; i < right_count; i++) t[i+left_count] = right_t[i];
        return (left_count+right_count);
    };
    var _getCrossingCount = function(curve, degree) {
        var n_crossings = 0, sign, old_sign;
        sign = old_sign = Math.sgn(curve[0].y);
        for (var i = 1; i <= degree; i++) {
            sign = Math.sgn(curve[i].y);
            if (sign != old_sign) n_crossings++;
            old_sign = sign;
        }
        return n_crossings;
    };
    var _isFlatEnough = function(curve, degree) {
        var  error,
            intercept_1, intercept_2, left_intercept, right_intercept,
            a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;
        a = curve[0].y - curve[degree].y;
        b = curve[degree].x - curve[0].x;
        c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;

        var max_distance_above = max_distance_below = 0.0;

        for (var i = 1; i < degree; i++) {
            var value = a * curve[i].x + b * curve[i].y + c;
            if (value > max_distance_above)
                max_distance_above = value;
            else if (value < max_distance_below)
                max_distance_below = value;
        }

        a1 = 0.0; b1 = 1.0; c1 = 0.0; a2 = a; b2 = b;
        c2 = c - max_distance_above;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_1 = (b1 * c2 - b2 * c1) * dInv;
        a2 = a; b2 = b; c2 = c - max_distance_below;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_2 = (b1 * c2 - b2 * c1) * dInv;
        left_intercept = Math.min(intercept_1, intercept_2);
        right_intercept = Math.max(intercept_1, intercept_2);
        error = right_intercept - left_intercept;
        return (error < flatnessTolerance)? 1 : 0;
    };
    var _computeXIntercept = function(curve, degree) {
        var XLK = 1.0, YLK = 0.0,
            XNM = curve[degree].x - curve[0].x, YNM = curve[degree].y - curve[0].y,
            XMK = curve[0].x - 0.0, YMK = curve[0].y - 0.0,
            det = XNM*YLK - YNM*XLK, detInv = 1.0/det,
            S = (XNM*YMK - YNM*XMK) * detInv;
        return 0.0 + XLK * S;
    };
    var _bezier = function(curve, degree, t, left, right) {
        var temp = [[]];
        for (var j =0; j <= degree; j++) temp[0][j] = curve[j];
        for (var i = 1; i <= degree; i++) {
            for (var j =0 ; j <= degree - i; j++) {
                if (!temp[i]) temp[i] = [];
                if (!temp[i][j]) temp[i][j] = {};
                temp[i][j].x = (1.0 - t) * temp[i-1][j].x + t * temp[i-1][j+1].x;
                temp[i][j].y = (1.0 - t) * temp[i-1][j].y + t * temp[i-1][j+1].y;
            }
        }
        if (left != null)
            for (j = 0; j <= degree; j++) left[j]  = temp[j][0];
        if (right != null)
            for (j = 0; j <= degree; j++) right[j] = temp[degree-j][j];

        return (temp[degree][0]);
    };

    var _curveFunctionCache = {};
    var _getCurveFunctions = function(order) {
        var fns = _curveFunctionCache[order];
        if (!fns) {
            fns = [];
            var f_term = function() { return function(t) { return Math.pow(t, order); }; },
                l_term = function() { return function(t) { return Math.pow((1-t), order); }; },
                c_term = function(c) { return function(t) { return c; }; },
                t_term = function() { return function(t) { return t; }; },
                one_minus_t_term = function() { return function(t) { return 1-t; }; },
                _termFunc = function(terms) {
                    return function(t) {
                        var p = 1;
                        for (var i = 0; i < terms.length; i++) p = p * terms[i](t);
                        return p;
                    };
                };

            fns.push(new f_term());  // first is t to the power of the curve order
            for (var i = 1; i < order; i++) {
                var terms = [new c_term(order)];
                for (var j = 0 ; j < (order - i); j++) terms.push(new t_term());
                for (var j = 0 ; j < i; j++) terms.push(new one_minus_t_term());
                fns.push(new _termFunc(terms));
            }
            fns.push(new l_term());  // last is (1-t) to the power of the curve order

            _curveFunctionCache[order] = fns;
        }

        return fns;
    };


    /**
     * calculates a point on the curve, for a Bezier of arbitrary order.
     * @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.
     * @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.
     */
    var _pointOnPath = function(curve, location) {
        var cc = _getCurveFunctions(curve.length - 1),
            _x = 0, _y = 0;
        for (var i = 0; i < curve.length ; i++) {
            _x = _x + (curve[i].x * cc[i](location));
            _y = _y + (curve[i].y * cc[i](location));
        }

        return {x:_x, y:_y};
    };

    var _dist = function(p1,p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    };

    var _isPoint = function(curve) {
        return curve[0].x == curve[1].x && curve[0].y == curve[1].y;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.  this method returns both the x,y location of the point and also
     * its 'location' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the
     * point.
     */
    var _pointAlongPath = function(curve, location, distance) {

        if (_isPoint(curve)) {
            return {
                point:curve[0],
                location:location
            };
        }

        var prev = _pointOnPath(curve, location),
            tally = 0,
            curLoc = location,
            direction = distance > 0 ? 1 : -1,
            cur = null;

        while (tally < Math.abs(distance)) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return {point:cur, location:curLoc};
    };

    var _length = function(curve) {
        if (_isPoint(curve)) return 0;

        var prev = _pointOnPath(curve, 0),
            tally = 0,
            curLoc = 0,
            direction = 1,
            cur = null;

        while (curLoc < 1) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return tally;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.
     */
    var _pointAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).point;
    };

    /**
     * finds the location that is 'distance' along the path from 'location'.
     */
    var _locationAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).location;
    };

    /**
     * returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.
     *
     * thanks // http://bimixual.org/AnimationLibrary/beziertangents.html
     */
    var _gradientAtPoint = function(curve, location) {
        var p1 = _pointOnPath(curve, location),
            p2 = _pointOnPath(curve.slice(0, curve.length - 1), location),
            dy = p2.y - p1.y, dx = p2.x - p1.x;
        return dy == 0 ? Infinity : Math.atan(dy / dx);
    };

    /**
     returns the gradient of the curve at the point which is 'distance' from the given location.
     if this point is greater than location 1, the gradient at location 1 is returned.
     if this point is less than location 0, the gradient at location 0 is returned.
     */
    var _gradientAtPointAlongPathFrom = function(curve, location, distance) {
        var p = _pointAlongPath(curve, location, distance);
        if (p.location > 1) p.location = 1;
        if (p.location < 0) p.location = 0;
        return _gradientAtPoint(curve, p.location);
    };

    /**
     * calculates a line that is 'length' pixels long, perpendicular to, and centered on, the path at 'distance' pixels from the given location.
     * if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).
     */
    var _perpendicularToPathAt = function(curve, location, length, distance) {
        distance = distance == null ? 0 : distance;
        var p = _pointAlongPath(curve, location, distance),
            m = _gradientAtPoint(curve, p.location),
            _theta2 = Math.atan(-1 / m),
            y =  length / 2 * Math.sin(_theta2),
            x =  length / 2 * Math.cos(_theta2);
        return [{x:p.point.x + x, y:p.point.y + y}, {x:p.point.x - x, y:p.point.y - y}];
    };

    var jsBezier = this.jsBezier = {
        distanceFromCurve : _distanceFromCurve,
        gradientAtPoint : _gradientAtPoint,
        gradientAtPointAlongCurveFrom : _gradientAtPointAlongPathFrom,
        nearestPointOnCurve : _nearestPointOnCurve,
        pointOnCurve : _pointOnPath,
        pointAlongCurveFrom : _pointAlongPathFrom,
        perpendicularToCurveAt : _perpendicularToPathAt,
        locationAlongCurveFrom:_locationAlongPathFrom,
        getLength:_length,
        version:"0.9.0"
    };

    if (typeof exports !== "undefined") {
        exports.jsBezier = jsBezier;
    }

}).call(typeof window !== 'undefined' ? window : this);

/**
 * Biltong v0.4.0
 *
 * Various geometry functions written as part of jsPlumb and perhaps useful for others.
 *
 * Copyright (c) 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
;(function() {

    "use strict";
    var root = this;

    var Biltong = root.Biltong = {
        version:"0.4.0"
    };

    if (typeof exports !== "undefined") {
        exports.Biltong = Biltong;
    }

    var _isa = function(a) { return Object.prototype.toString.call(a) === "[object Array]"; },
        _pointHelper = function(p1, p2, fn) {
            p1 = _isa(p1) ? p1 : [p1.x, p1.y];
            p2 = _isa(p2) ? p2 : [p2.x, p2.y];
            return fn(p1, p2);
        },
        /**
         * @name Biltong.gradient
         * @function
         * @desc Calculates the gradient of a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The gradient of a line between the two points.
         */
        _gradient = Biltong.gradient = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                if (_p2[0] == _p1[0])
                    return _p2[1] > _p1[1] ? Infinity : -Infinity;
                else if (_p2[1] == _p1[1])
                    return _p2[0] > _p1[0] ? 0 : -0;
                else
                    return (_p2[1] - _p1[1]) / (_p2[0] - _p1[0]);
            });
        },
        /**
         * @name Biltong.normal
         * @function
         * @desc Calculates the gradient of a normal to a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The gradient of a normal to a line between the two points.
         */
        _normal = Biltong.normal = function(p1, p2) {
            return -1 / _gradient(p1, p2);
        },
        /**
         * @name Biltong.lineLength
         * @function
         * @desc Calculates the length of a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The length of a line between the two points.
         */
        _lineLength = Biltong.lineLength = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                return Math.sqrt(Math.pow(_p2[1] - _p1[1], 2) + Math.pow(_p2[0] - _p1[0], 2));
            });
        },
        /**
         * @name Biltong.quadrant
         * @function
         * @desc Calculates the quadrant in which the angle between the two points lies.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Integer} The quadrant - 1 for upper right, 2 for lower right, 3 for lower left, 4 for upper left.
         */
        _quadrant = Biltong.quadrant = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                if (_p2[0] > _p1[0]) {
                    return (_p2[1] > _p1[1]) ? 2 : 1;
                }
                else if (_p2[0] == _p1[0]) {
                    return _p2[1] > _p1[1] ? 2 : 1;
                }
                else {
                    return (_p2[1] > _p1[1]) ? 3 : 4;
                }
            });
        },
        /**
         * @name Biltong.theta
         * @function
         * @desc Calculates the angle between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The angle between the two points.
         */
        _theta = Biltong.theta = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                var m = _gradient(_p1, _p2),
                    t = Math.atan(m),
                    s = _quadrant(_p1, _p2);
                if ((s == 4 || s== 3)) t += Math.PI;
                if (t < 0) t += (2 * Math.PI);

                return t;
            });
        },
        /**
         * @name Biltong.intersects
         * @function
         * @desc Calculates whether or not the two rectangles intersect.
         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @return {Boolean} True if the rectangles intersect, false otherwise.
         */
        _intersects = Biltong.intersects = function(r1, r2) {
            var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
                a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h;

            return  ( (x1 <= a1 && a1 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a2 && a2 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a1 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
                ( (x1 <= a2 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x2 && x2 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y2 && y2 <= b2) ) ||
                ( (a1 <= x2 && x1 <= a2) && (b1 <= y2 && y2 <= b2) );
        },
        /**
         * @name Biltong.encloses
         * @function
         * @desc Calculates whether or not r2 is completely enclosed by r1.
         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Boolean} [allowSharedEdges=false] If true, the concept of enclosure allows for one or more edges to be shared by the two rectangles.
         * @return {Boolean} True if r1 encloses r2, false otherwise.
         */
        _encloses = Biltong.encloses = function(r1, r2, allowSharedEdges) {
            var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
                a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h,
                c = function(v1, v2, v3, v4) { return allowSharedEdges ? v1 <= v2 && v3>= v4 : v1 < v2 && v3 > v4; };

            return c(x1,a1,x2,a2) && c(y1,b1,y2,b2);
        },
        _segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1] ],
        _inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1] ],
        /**
         * @name Biltong.pointOnLine
         * @function
         * @desc Calculates a point on the line from `fromPoint` to `toPoint` that is `distance` units along the length of the line.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Point} Point on the line, in the form `{ x:..., y:... }`.
         */
        _pointOnLine = Biltong.pointOnLine = function(fromPoint, toPoint, distance) {
            var m = _gradient(fromPoint, toPoint),
                s = _quadrant(fromPoint, toPoint),
                segmentMultiplier = distance > 0 ? _segmentMultipliers[s] : _inverseSegmentMultipliers[s],
                theta = Math.atan(m),
                y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
                x =  Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
            return { x:fromPoint.x + x, y:fromPoint.y + y };
        },
        /**
         * @name Biltong.perpendicularLineTo
         * @function
         * @desc Calculates a line of length `length` that is perpendicular to the line from `fromPoint` to `toPoint` and passes through `toPoint`.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Line} Perpendicular line, in the form `[ { x:..., y:... }, { x:..., y:... } ]`.
         */
        _perpendicularLineTo = Biltong.perpendicularLineTo = function(fromPoint, toPoint, length) {
            var m = _gradient(fromPoint, toPoint),
                theta2 = Math.atan(-1 / m),
                y =  length / 2 * Math.sin(theta2),
                x =  length / 2 * Math.cos(theta2);
            return [{x:toPoint.x + x, y:toPoint.y + y}, {x:toPoint.x - x, y:toPoint.y - y}];
        };
}).call(typeof window !== 'undefined' ? window : this);
;
(function () {

    "use strict";

    var root = this,
        Sniff = {
            android: navigator.userAgent.toLowerCase().indexOf("android") > -1
        },
        matchesSelector = function (el, selector, ctx) {
            ctx = ctx || el.parentNode;
            var possibles = ctx.querySelectorAll(selector);
            for (var i = 0; i < possibles.length; i++) {
                if (possibles[i] === el) {
                    return true;
                }
            }
            return false;
        },
        _gel = function (el) {
            return (typeof el == "string" || el.constructor === String) ? document.getElementById(el) : el;
        },
        _t = function (e) {
            return e.srcElement || e.target;
        },
    //
    // gets path info for the given event - the path from target to obj, in the event's bubble chain. if doCompute
    // is false we just return target for the path.
    //
        _pi = function(e, target, obj, doCompute) {
            if (!doCompute) return { path:[target], end:1 };
            else if (typeof e.path !== "undefined" && e.path.indexOf) {
                return { path: e.path, end: e.path.indexOf(obj) };
            } else {
                var out = { path:[], end:-1 }, _one = function(el) {
                    out.path.push(el);
                    if (el === obj) {
                        out.end = out.path.length - 1;
                    }
                    else if (el.parentNode != null) {
                        _one(el.parentNode)
                    }
                };
                _one(target);
                return out;
            }
        },
        _d = function (l, fn) {
            for (var i = 0, j = l.length; i < j; i++) {
                if (l[i] == fn) break;
            }
            if (i < l.length) l.splice(i, 1);
        },
        guid = 1,
    //
    // this function generates a guid for every handler, sets it on the handler, then adds
    // it to the associated object's map of handlers for the given event. this is what enables us
    // to unbind all events of some type, or all events (the second of which can be requested by the user,
    // but it also used by Mottle when an element is removed.)
        _store = function (obj, event, fn) {
            var g = guid++;
            obj.__ta = obj.__ta || {};
            obj.__ta[event] = obj.__ta[event] || {};
            // store each handler with a unique guid.
            obj.__ta[event][g] = fn;
            // set the guid on the handler.
            fn.__tauid = g;
            return g;
        },
        _unstore = function (obj, event, fn) {
            obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
            // a handler might have attached extra functions, so we unbind those too.
            if (fn.__taExtra) {
                for (var i = 0; i < fn.__taExtra.length; i++) {
                    _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
                }
                fn.__taExtra.length = 0;
            }
            // a handler might have attached an unstore callback
            fn.__taUnstore && fn.__taUnstore();
        },
        _curryChildFilter = function (children, obj, fn, evt) {
            if (children == null) return fn;
            else {
                var c = children.split(","),
                    _fn = function (e) {
                        _fn.__tauid = fn.__tauid;
                        var t = _t(e), target = t;  // t is the target element on which the event occurred. it is the
                        // element we will wish to pass to any callbacks.
                        var pathInfo = _pi(e, t, obj, children != null)
                        if (pathInfo.end != -1) {
                            for (var p = 0; p < pathInfo.end; p++) {
                                target = pathInfo.path[p];
                                for (var i = 0; i < c.length; i++) {
                                    if (matchesSelector(target, c[i], obj)) {
                                        fn.apply(target, arguments);
                                    }
                                }
                            }
                        }
                    };
                registerExtraFunction(fn, evt, _fn);
                return _fn;
            }
        },
    //
    // registers an 'extra' function on some event listener function we were given - a function that we
    // created and bound to the element as part of our housekeeping, and which we want to unbind and remove
    // whenever the given function is unbound.
        registerExtraFunction = function (fn, evt, newFn) {
            fn.__taExtra = fn.__taExtra || [];
            fn.__taExtra.push([evt, newFn]);
        },
        DefaultHandler = function (obj, evt, fn, children) {
            if (isTouchDevice && touchMap[evt]) {
                var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
                _bind(obj, touchMap[evt], tfn , fn);
            }
            if (evt === "focus" && obj.getAttribute("tabindex") == null) {
                obj.setAttribute("tabindex", "1");
            }
            _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn);
        },
        SmartClickHandler = function (obj, evt, fn, children) {
            if (obj.__taSmartClicks == null) {
                var down = function (e) {
                        obj.__tad = _pageLocation(e);
                    },
                    up = function (e) {
                        obj.__tau = _pageLocation(e);
                    },
                    click = function (e) {
                        if (obj.__tad && obj.__tau && obj.__tad[0] === obj.__tau[0] && obj.__tad[1] === obj.__tau[1]) {
                            for (var i = 0; i < obj.__taSmartClicks.length; i++)
                                obj.__taSmartClicks[i].apply(_t(e), [ e ]);
                        }
                    };
                DefaultHandler(obj, "mousedown", down, children);
                DefaultHandler(obj, "mouseup", up, children);
                DefaultHandler(obj, "click", click, children);
                obj.__taSmartClicks = [];
            }

            // store in the list of callbacks
            obj.__taSmartClicks.push(fn);
            // the unstore function removes this function from the object's listener list for this type.
            fn.__taUnstore = function () {
                _d(obj.__taSmartClicks, fn);
            };
        },
        _tapProfiles = {
            "tap": {touches: 1, taps: 1},
            "dbltap": {touches: 1, taps: 2},
            "contextmenu": {touches: 2, taps: 1}
        },
        TapHandler = function (clickThreshold, dblClickThreshold) {
            return function (obj, evt, fn, children) {
                // if event is contextmenu, for devices which are mouse only, we want to
                // use the default bind.
                if (evt == "contextmenu" && isMouseDevice)
                    DefaultHandler(obj, evt, fn, children);
                else {
                    // the issue here is that this down handler gets registered only for the
                    // child nodes in the first registration. in fact it should be registered with
                    // no child selector and then on down we should cycle through the registered
                    // functions to see if one of them matches. on mouseup we should execute ALL of
                    // the functions whose children are either null or match the element.
                    if (obj.__taTapHandler == null) {
                        var tt = obj.__taTapHandler = {
                            tap: [],
                            dbltap: [],
                            contextmenu: [],
                            down: false,
                            taps: 0,
                            downSelectors: []
                        };
                        var down = function (e) {
                                var target = _t(e), pathInfo = _pi(e, target, obj, children != null), finished = false;
                                for (var p = 0; p < pathInfo.end; p++) {
                                    if (finished) return;
                                    target = pathInfo.path[p];
                                    for (var i = 0; i < tt.downSelectors.length; i++) {
                                        if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                                            tt.down = true;
                                            setTimeout(clearSingle, clickThreshold);
                                            setTimeout(clearDouble, dblClickThreshold);
                                            finished = true;
                                            break; // we only need one match on mousedown
                                        }
                                    }
                                }
                            },
                            up = function (e) {
                                if (tt.down) {
                                    var target = _t(e), currentTarget, pathInfo;
                                    tt.taps++;
                                    var tc = _touchCount(e);
                                    for (var eventId in _tapProfiles) {
                                        if (_tapProfiles.hasOwnProperty(eventId)) {
                                            var p = _tapProfiles[eventId];
                                            if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                                                for (var i = 0; i < tt[eventId].length; i++) {
                                                    pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);
                                                    for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {
                                                        currentTarget = pathInfo.path[pLoop];
                                                        // this is a single event registration handler.
                                                        if (tt[eventId][i][1] == null || matchesSelector(currentTarget, tt[eventId][i][1], obj)) {
                                                            tt[eventId][i][0].apply(currentTarget, [ e ]);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            clearSingle = function () {
                                tt.down = false;
                            },
                            clearDouble = function () {
                                tt.taps = 0;
                            };

                        DefaultHandler(obj, "mousedown", down);
                        DefaultHandler(obj, "mouseup", up);
                    }
                    // add this child selector (it can be null, that's fine).
                    obj.__taTapHandler.downSelectors.push(children);

                    obj.__taTapHandler[evt].push([fn, children]);
                    // the unstore function removes this function from the object's listener list for this type.
                    fn.__taUnstore = function () {
                        _d(obj.__taTapHandler[evt], fn);
                    };
                }
            };
        },
        meeHelper = function (type, evt, obj, target) {
            for (var i in obj.__tamee[type]) {
                if (obj.__tamee[type].hasOwnProperty(i)) {
                    obj.__tamee[type][i].apply(target, [ evt ]);
                }
            }
        },
        MouseEnterExitHandler = function () {
            var activeElements = [];
            return function (obj, evt, fn, children) {
                if (!obj.__tamee) {
                    // __tamee holds a flag saying whether the mouse is currently "in" the element, and a list of
                    // both mouseenter and mouseexit functions.
                    obj.__tamee = { over: false, mouseenter: [], mouseexit: [] };
                    // register over and out functions
                    var over = function (e) {
                            var t = _t(e);
                            if ((children == null && (t == obj && !obj.__tamee.over)) || (matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over))) {
                                meeHelper("mouseenter", e, obj, t);
                                t.__tamee = t.__tamee || {};
                                t.__tamee.over = true;
                                activeElements.push(t);
                            }
                        },
                        out = function (e) {
                            var t = _t(e);
                            // is the current target one of the activeElements? and is the
                            // related target NOT a descendant of it?
                            for (var i = 0; i < activeElements.length; i++) {
                                if (t == activeElements[i] && !matchesSelector((e.relatedTarget || e.toElement), "*", t)) {
                                    t.__tamee.over = false;
                                    activeElements.splice(i, 1);
                                    meeHelper("mouseexit", e, obj, t);
                                }
                            }
                        };

                    _bind(obj, "mouseover", _curryChildFilter(children, obj, over, "mouseover"), over);
                    _bind(obj, "mouseout", _curryChildFilter(children, obj, out, "mouseout"), out);
                }

                fn.__taUnstore = function () {
                    delete obj.__tamee[evt][fn.__tauid];
                };

                _store(obj, evt, fn);
                obj.__tamee[evt][fn.__tauid] = fn;
            };
        },
        isTouchDevice = "ontouchstart" in document.documentElement,
        isMouseDevice = "onmousedown" in document.documentElement,
        touchMap = { "mousedown": "touchstart", "mouseup": "touchend", "mousemove": "touchmove" },
        touchstart = "touchstart", touchend = "touchend", touchmove = "touchmove",
        iev = (function () {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        isIELT9 = iev > -1 && iev < 9,
        _genLoc = function (e, prefix) {
            if (e == null) return [ 0, 0 ];
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = function (e) {
            if (e == null) return [ 0, 0 ];
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                return _genLoc(e, "page");
            }
        },
        _screenLocation = function (e) {
            return _genLoc(e, "screen");
        },
        _clientLocation = function (e) {
            return _genLoc(e, "client");
        },
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _touchCount = function (e) {
            return _touches(e).length;
        },
    //http://www.quirksmode.org/blog/archives/2005/10/_and_the_winner_1.html
        _bind = function (obj, type, fn, originalFn) {
            _store(obj, type, fn);
            originalFn.__tauid = fn.__tauid;
            if (obj.addEventListener)
                obj.addEventListener(type, fn, false);
            else if (obj.attachEvent) {
                var key = type + fn.__tauid;
                obj["e" + key] = fn;
                // TODO look at replacing with .call(..)
                obj[key] = function () {
                    obj["e" + key] && obj["e" + key](window.event);
                };
                obj.attachEvent("on" + type, obj[key]);
            }
        },
        _unbind = function (obj, type, fn) {
            if (fn == null) return;
            _each(obj, function () {
                var _el = _gel(this);
                _unstore(_el, type, fn);
                // it has been bound if there is a tauid. otherwise it was not bound and we can ignore it.
                if (fn.__tauid != null) {
                    if (_el.removeEventListener) {
                        _el.removeEventListener(type, fn, false);
                        if (isTouchDevice && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);
                    }
                    else if (this.detachEvent) {
                        var key = type + fn.__tauid;
                        _el[key] && _el.detachEvent("on" + type, _el[key]);
                        _el[key] = null;
                        _el["e" + key] = null;
                    }
                }

                // if a touch event was also registered, deregister now.
                if (fn.__taTouchProxy) {
                    _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
                }
            });
        },
        _each = function (obj, fn) {
            if (obj == null) return;
            // if a list (or list-like), use it. if a string, get a list
            // by running the string through querySelectorAll. else, assume
            // it's an Element.
            // obj.top is "unknown" in IE8.
            obj = (typeof Window !== "undefined" && (typeof obj.top !== "unknown" && obj == obj.top)) ? [ obj ] :
                    (typeof obj !== "string") && (obj.tagName == null && obj.length != null) ? obj :
                    typeof obj === "string" ? document.querySelectorAll(obj)
                : [ obj ];

            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i]);
        };

    /**
     * Mottle offers support for abstracting out the differences
     * between touch and mouse devices, plus "smart click" functionality
     * (don't fire click if the mouse has moved between mousedown and mouseup),
     * and synthesized click/tap events.
     * @class Mottle
     * @constructor
     * @param {Object} params Constructor params
     * @param {Number} [params.clickThreshold=250] Threshold, in milliseconds beyond which a touchstart followed by a touchend is not considered to be a click.
     * @param {Number} [params.dblClickThreshold=450] Threshold, in milliseconds beyond which two successive tap events are not considered to be a click.
     * @param {Boolean} [params.smartClicks=false] If true, won't fire click events if the mouse has moved between mousedown and mouseup. Note that this functionality
     * requires that Mottle consume the mousedown event, and so may not be viable in all use cases.
     */
    root.Mottle = function (params) {
        params = params || {};
        var clickThreshold = params.clickThreshold || 250,
            dblClickThreshold = params.dblClickThreshold || 450,
            mouseEnterExitHandler = new MouseEnterExitHandler(),
            tapHandler = new TapHandler(clickThreshold, dblClickThreshold),
            _smartClicks = params.smartClicks,
            _doBind = function (obj, evt, fn, children) {
                if (fn == null) return;
                _each(obj, function () {
                    var _el = _gel(this);
                    if (_smartClicks && evt === "click")
                        SmartClickHandler(_el, evt, fn, children);
                    else if (evt === "tap" || evt === "dbltap" || evt === "contextmenu") {
                        tapHandler(_el, evt, fn, children);
                    }
                    else if (evt === "mouseenter" || evt == "mouseexit")
                        mouseEnterExitHandler(_el, evt, fn, children);
                    else
                        DefaultHandler(_el, evt, fn, children);
                });
            };

        /**
         * Removes an element from the DOM, and deregisters all event handlers for it. You should use this
         * to ensure you don't leak memory.
         * @method remove
         * @param {String|Element} el Element, or id of the element, to remove.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.remove = function (el) {
            _each(el, function () {
                var _el = _gel(this);
                if (_el.__ta) {
                    for (var evt in _el.__ta) {
                        if (_el.__ta.hasOwnProperty(evt)) {
                            for (var h in _el.__ta[evt]) {
                                if (_el.__ta[evt].hasOwnProperty(h))
                                    _unbind(_el, evt, _el.__ta[evt][h]);
                            }
                        }
                    }
                }
                _el.parentNode && _el.parentNode.removeChild(_el);
            });
            return this;
        };

        /**
         * Register an event handler, optionally as a delegate for some set of descendant elements. Note
         * that this method takes either 3 or 4 arguments - if you supply 3 arguments it is assumed you have
         * omitted the `children` parameter, and that the event handler should be bound directly to the given element.
         * @method on
         * @param {Element[]|Element|String} el Either an Element, or a CSS spec for a list of elements, or an array of Elements.
         * @param {String} [children] Comma-delimited list of selectors identifying allowed children.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.on = function (el, event, children, fn) {
            var _el = arguments[0],
                _c = arguments.length == 4 ? arguments[2] : null,
                _e = arguments[1],
                _f = arguments[arguments.length - 1];

            _doBind(_el, _e, _f, _c);
            return this;
        };

        /**
         * Cancel delegate event handling for the given function. Note that unlike with 'on' you do not supply
         * a list of child selectors here: it removes event delegation from all of the child selectors for which the
         * given function was registered (if any).
         * @method off
         * @param {Element[]|Element|String} el Element - or ID of element - from which to remove event listener.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.off = function (el, event, fn) {
            _unbind(el, event, fn);
            return this;
        };

        /**
         * Triggers some event for a given element.
         * @method trigger
         * @param {Element} el Element for which to trigger the event.
         * @param {String} event Event ID.
         * @param {Event} originalEvent The original event. Should be optional of course, but currently is not, due
         * to the jsPlumb use case that caused this method to be added.
         * @param {Object} [payload] Optional object to set as `payload` on the generated event; useful for message passing.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.trigger = function (el, event, originalEvent, payload) {
            // MouseEvent undefined in old IE; that's how we know it's a mouse event.  A fine Microsoft paradox.
            var originalIsMouse = isMouseDevice && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);

            var eventToBind = (isTouchDevice && !isMouseDevice && touchMap[event]) ? touchMap[event] : event,
                bindingAMouseEvent = !(isTouchDevice && !isMouseDevice && touchMap[event]);

            var pl = _pageLocation(originalEvent), sl = _screenLocation(originalEvent), cl = _clientLocation(originalEvent);
            _each(el, function () {
                var _el = _gel(this), evt;
                originalEvent = originalEvent || {
                    screenX: sl[0],
                    screenY: sl[1],
                    clientX: cl[0],
                    clientY: cl[1]
                };

                var _decorate = function (_evt) {
                    if (payload) _evt.payload = payload;
                };

                var eventGenerators = {
                    "TouchEvent": function (evt) {
                        var touch = document.createTouch(window, _el, 0, pl[0], pl[1],
                            sl[0], sl[1],
                            cl[0], cl[1],
                            0, 0, 0, 0);

                        // https://gist.github.com/sstephenson/448808
                        var touches = document.createTouchList(touch);
                        var targetTouches = document.createTouchList(touch);
                        var changedTouches = document.createTouchList(touch);
                        evt.initTouchEvent(eventToBind, true, true, window, null, sl[0], sl[1],
                            cl[0], cl[1], false, false, false, false,
                            touches, targetTouches, changedTouches, 1, 0);
                    },
                    "MouseEvents": function (evt) {
                        evt.initMouseEvent(eventToBind, true, true, window, 0,
                            sl[0], sl[1],
                            cl[0], cl[1],
                            false, false, false, false, 1, _el);

                        if (Sniff.android) {
                            // Android's touch events are not standard.
                            var t = document.createTouch(window, _el, 0, pl[0], pl[1],
                                sl[0], sl[1],
                                cl[0], cl[1],
                                0, 0, 0, 0);

                            evt.touches = evt.targetTouches = evt.changedTouches = document.createTouchList(t);
                        }
                    }
                };

                if (document.createEvent) {

                    var ite = !bindingAMouseEvent && !originalIsMouse && (isTouchDevice && touchMap[event] && !Sniff.android),
                        evtName = ite ? "TouchEvent" : "MouseEvents";

                    evt = document.createEvent(evtName);
                    eventGenerators[evtName](evt);
                    _decorate(evt);
                    _el.dispatchEvent(evt);
                }
                else if (document.createEventObject) {
                    evt = document.createEventObject();
                    evt.eventType = evt.eventName = eventToBind;
                    evt.screenX = sl[0];
                    evt.screenY = sl[1];
                    evt.clientX = cl[0];
                    evt.clientY = cl[1];
                    _decorate(evt);
                    _el.fireEvent('on' + eventToBind, evt);
                }
            });
            return this;
        }
    };

    /**
     * Static method to assist in 'consuming' an element: uses `stopPropagation` where available, or sets
     * `e.returnValue=false` where it is not.
     * @method Mottle.consume
     * @param {Event} e Event to consume
     * @param {Boolean} [doNotPreventDefault=false] If true, does not call `preventDefault()` on the event.
     */
    root.Mottle.consume = function (e, doNotPreventDefault) {
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.returnValue = false;

        if (!doNotPreventDefault && e.preventDefault)
            e.preventDefault();
    };

    /**
     * Gets the page location corresponding to the given event. For touch events this means get the page location of the first touch.
     * @method Mottle.pageLocation
     * @param {Event} e Event to get page location for.
     * @return {Number[]} [left, top] for the given event.
     */
    root.Mottle.pageLocation = _pageLocation;

    /**
     * Forces touch events to be turned "on". Useful for testing: even if you don't have a touch device, you can still
     * trigger a touch event when this is switched on and it will be captured and acted on.
     * @method setForceTouchEvents
     * @param {Boolean} value If true, force touch events to be on.
     */
    root.Mottle.setForceTouchEvents = function (value) {
        isTouchDevice = value;
    };

    /**
     * Forces mouse events to be turned "on". Useful for testing: even if you don't have a mouse, you can still
     * trigger a mouse event when this is switched on and it will be captured and acted on.
     * @method setForceMouseEvents
     * @param {Boolean} value If true, force mouse events to be on.
     */
    root.Mottle.setForceMouseEvents = function (value) {
        isMouseDevice = value;
    };

    root.Mottle.version = "0.8.0";

    if (typeof exports !== "undefined") {
        exports.Mottle = root.Mottle;
    }

}).call(typeof window === "undefined" ? this : window);

/**
 drag/drop functionality for use with jsPlumb but with
 no knowledge of jsPlumb. supports multiple scopes (separated by whitespace), dragging
 multiple elements, constrain to parent, drop filters, drag start filters, custom
 css classes.

 a lot of the functionality of this script is expected to be plugged in:

 addClass
 removeClass

 addEvent
 removeEvent

 getPosition
 setPosition
 getSize

 indexOf
 intersects

 the name came from here:

 http://mrsharpoblunto.github.io/foswig.js/

 copyright 2016 jsPlumb
 */

;(function() {

    "use strict";
    var root = this;

    var _suggest = function(list, item, head) {
        if (list.indexOf(item) === -1) {
            head ? list.unshift(item) : list.push(item);
            return true;
        }
        return false;
    };

    var _vanquish = function(list, item) {
        var idx = list.indexOf(item);
        if (idx != -1) list.splice(idx, 1);
    };

    var _difference = function(l1, l2) {
        var d = [];
        for (var i = 0; i < l1.length; i++) {
            if (l2.indexOf(l1[i]) == -1)
                d.push(l1[i]);
        }
        return d;
    };

    var _isString = function(f) {
        return f == null ? false : (typeof f === "string" || f.constructor == String);
    };

    var getOffsetRect = function (elem) {
        // (1)
        var box = elem.getBoundingClientRect(),
            body = document.body,
            docElem = document.documentElement,
        // (2)
            scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
            scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
        // (3)
            clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,
        // (4)
            top  = box.top +  scrollTop - clientTop,
            left = box.left + scrollLeft - clientLeft;

        return { top: Math.round(top), left: Math.round(left) };
    };

    var matchesSelector = function(el, selector, ctx) {
        ctx = ctx || el.parentNode;
        var possibles = ctx.querySelectorAll(selector);
        for (var i = 0; i < possibles.length; i++) {
            if (possibles[i] === el)
                return true;
        }
        return false;
    };

    var iev = (function() {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        DEFAULT_GRID_X = 50,
        DEFAULT_GRID_Y = 50,
        isIELT9 = iev > -1 && iev < 9,
        isIE9 = iev == 9,
        _pl = function(e) {
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                var ts = _touches(e), t = _getTouch(ts, 0);
                // for IE9 pageX might be null if the event was synthesized. We try for pageX/pageY first,
                // falling back to clientX/clientY if necessary. In every other browser we want to use pageX/pageY.
                return isIE9 ? [t.pageX || t.clientX, t.pageY || t.clientY] : [t.pageX, t.pageY];
            }
        },
        _getTouch = function(touches, idx) { return touches.item ? touches.item(idx) : touches[idx]; },
        _touches = function(e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _classes = {
            draggable:"katavorio-draggable",    // draggable elements
            droppable:"katavorio-droppable",    // droppable elements
            drag : "katavorio-drag",            // elements currently being dragged
            selected:"katavorio-drag-selected", // elements in current drag selection
            active : "katavorio-drag-active",   // droppables that are targets of a currently dragged element
            hover : "katavorio-drag-hover",     // droppables over which a matching drag element is hovering
            noSelect : "katavorio-drag-no-select", // added to the body to provide a hook to suppress text selection
            ghostProxy:"katavorio-ghost-proxy"  // added to a ghost proxy element in use when a drag has exited the bounds of its parent.
        },
        _defaultScope = "katavorio-drag-scope",
        _events = [ "stop", "start", "drag", "drop", "over", "out", "beforeStart" ],
        _devNull = function() {},
        _true = function() { return true; },
        _foreach = function(l, fn, from) {
            for (var i = 0; i < l.length; i++) {
                if (l[i] != from)
                    fn(l[i]);
            }
        },
        _setDroppablesActive = function(dd, val, andHover, drag) {
            _foreach(dd, function(e) {
                e.setActive(val);
                if (val) e.updatePosition();
                if (andHover) e.setHover(drag, val);
            });
        },
        _each = function(obj, fn) {
            if (obj == null) return;
            obj = !_isString(obj) && (obj.tagName == null && obj.length != null) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i], [ obj[i] ]);
        },
        _consume = function(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
        },
        _defaultInputFilterSelector = "input,textarea,select,button,option",
    //
    // filters out events on all input elements, like textarea, checkbox, input, select.
        _inputFilter = function(e, el, _katavorio) {
            var t = e.srcElement || e.target;
            return !matchesSelector(t, _katavorio.getInputFilterSelector(), el);
        };

    var Super = function(el, params, css, scope) {
        this.params = params || {};
        this.el = el;
        this.params.addClass(this.el, this._class);
        this.uuid = _uuid();
        var enabled = true;
        this.setEnabled = function(e) { enabled = e; };
        this.isEnabled = function() { return enabled; };
        this.toggleEnabled = function() { enabled = !enabled; };
        this.setScope = function(scopes) {
            this.scopes = scopes ? scopes.split(/\s+/) : [ scope ];
        };
        this.addScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { m[s] = true;});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.removeScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { delete m[s];});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.toggleScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) {
                if (m[s]) delete m[s];
                else m[s] = true;
            });
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.setScope(params.scope);
        this.k = params.katavorio;
        return params.katavorio;
    };

    var TRUE = function() { return true; };
    var FALSE = function() { return false; };

    var Drag = function(el, params, css, scope) {
        this._class = css.draggable;
        var k = Super.apply(this, arguments);
        this.rightButtonCanDrag = this.params.rightButtonCanDrag;
        var downAt = [0,0], posAtDown = null, pagePosAtDown = null, pageDelta = [0,0], moving = false,
            consumeStartEvent = this.params.consumeStartEvent !== false,
            dragEl = this.el,
            clone = this.params.clone,
            scroll = this.params.scroll,
            _multipleDrop = params.multipleDrop !== false,
            isConstrained = false,
            useGhostProxy = params.ghostProxy === true ? TRUE : params.ghostProxy && typeof params.ghostProxy === "function" ? params.ghostProxy : FALSE,
            ghostProxy = function(el) { return el.cloneNode(true); };

        var snapThreshold = params.snapThreshold || 5,
            _snap = function(pos, x, y, thresholdX, thresholdY) {
                thresholdX = thresholdX || snapThreshold;
                thresholdY = thresholdY || snapThreshold;
                var _dx = Math.floor(pos[0] / x),
                    _dxl = x * _dx,
                    _dxt = _dxl + x,
                    _x = Math.abs(pos[0] - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos[0]) <= thresholdX ? _dxt : pos[0];

                var _dy = Math.floor(pos[1] / y),
                    _dyl = y * _dy,
                    _dyt = _dyl + y,
                    _y = Math.abs(pos[1] - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos[1]) <= thresholdY ? _dyt : pos[1];

                return [ _x, _y];
            };

        this.posses = [];
        this.posseRoles = {};

        this.toGrid = function(pos) {
            if (this.params.grid == null) {
                return pos;
            }
            else {
                return _snap(pos, this.params.grid[0], this.params.grid[1]);
            }
        };

        this.snap = function(x, y) {
            if (dragEl == null) return;
            x = x || (this.params.grid ? this.params.grid[0] : DEFAULT_GRID_X);
            y = y || (this.params.grid ? this.params.grid[1] : DEFAULT_GRID_Y);
            var p = this.params.getPosition(dragEl);
            this.params.setPosition(dragEl, _snap(p, x, y, x, y));
        };

        this.setUseGhostProxy = function(val) {
            useGhostProxy = val ? TRUE : FALSE;
        };

        var constrain;
        var negativeFilter = function(pos) {
            return (params.allowNegative === false) ? [ Math.max (0, pos[0]), Math.max(0, pos[1]) ] : pos;
        };

        var _setConstrain = function(value) {
            constrain = typeof value === "function" ? value : value ? function(pos) {
                return negativeFilter([
                    Math.max(0, Math.min(constrainRect.w - this.size[0], pos[0])),
                    Math.max(0, Math.min(constrainRect.h - this.size[1], pos[1]))
                ]);
            }.bind(this) : function(pos) { return negativeFilter(pos); };
        }.bind(this);

        _setConstrain(typeof this.params.constrain === "function" ? this.params.constrain  : (this.params.constrain || this.params.containment));


        /**
         * Sets whether or not the Drag is constrained. A value of 'true' means constrain to parent bounds; a function
         * will be executed and returns true if the position is allowed.
         * @param value
         */
        this.setConstrain = function(value) {
            _setConstrain(value);
        };

        var revertFunction;
        /**
         * Sets a function to call on drag stop, which, if it returns true, indicates that the given element should
         * revert to its position before the previous drag.
         * @param fn
         */
        this.setRevert = function(fn) {
            revertFunction = fn;
        };

        var _assignId = function(obj) {
                if (typeof obj == "function") {
                    obj._katavorioId = _uuid();
                    return obj._katavorioId;
                } else {
                    return obj;
                }
            },
        // a map of { spec -> [ fn, exclusion ] } entries.
            _filters = {},
            _testFilter = function(e) {
                for (var key in _filters) {
                    var f = _filters[key];
                    var rv = f[0](e);
                    if (f[1]) rv = !rv;
                    if (!rv) return false;
                }
                return true;
            },
            _setFilter = this.setFilter = function(f, _exclude) {
                if (f) {
                    var key = _assignId(f);
                    _filters[key] = [
                        function(e) {
                            var t = e.srcElement || e.target, m;
                            if (_isString(f)) {
                                m = matchesSelector(t, f, el);
                            }
                            else if (typeof f === "function") {
                                m = f(e, el);
                            }
                            return m;
                        },
                            _exclude !== false
                    ];

                }
            },
            _addFilter = this.addFilter = _setFilter,
            _removeFilter = this.removeFilter = function(f) {
                var key = typeof f == "function" ? f._katavorioId : f;
                delete _filters[key];
            };

        this.clearAllFilters = function() {
            _filters = {};
        };

        this.canDrag = this.params.canDrag || _true;

        var constrainRect,
            matchingDroppables = [], intersectingDroppables = [];

        this.downListener = function(e) {
            var isNotRightClick = this.rightButtonCanDrag || (e.which !== 3 && e.button !== 2);
            if (isNotRightClick && this.isEnabled() && this.canDrag()) {
                var _f =  _testFilter(e) && _inputFilter(e, this.el, this.k);
                if (_f) {
                    if (!clone)
                        dragEl = this.el;
                    else {
                        dragEl = this.el.cloneNode(true);
                        dragEl.setAttribute("id", null);
                        dragEl.style.position = "absolute";
                        // the clone node is added to the body; getOffsetRect gives us a value
                        // relative to the body.
                        var b = getOffsetRect(this.el);
                        dragEl.style.left = b.left + "px";
                        dragEl.style.top = b.top + "px";
                        document.body.appendChild(dragEl);
                    }
                    consumeStartEvent && _consume(e);
                    downAt = _pl(e);
                    //
                    this.params.bind(document, "mousemove", this.moveListener);
                    this.params.bind(document, "mouseup", this.upListener);
                    k.markSelection(this);
                    k.markPosses(this);
                    this.params.addClass(document.body, css.noSelect);
                    _dispatch("beforeStart", {el:this.el, pos:posAtDown, e:e, drag:this});
                }
                else if (this.params.consumeFilteredEvents) {
                    _consume(e);
                }
            }
        }.bind(this);

        this.moveListener = function(e) {
            if (downAt) {
                if (!moving) {
                    var _continue = _dispatch("start", {el:this.el, pos:posAtDown, e:e, drag:this});
                    if (_continue !== false) {
                        if (!downAt) return;
                        this.mark(true);
                        moving = true;
                    }
                }

                // it is possible that the start event caused the drag to be aborted. So we check
                // again that we are currently dragging.
                if (downAt) {
                    intersectingDroppables.length = 0;
                    var pos = _pl(e), dx = pos[0] - downAt[0], dy = pos[1] - downAt[1],
                        z = this.params.ignoreZoom ? 1 : k.getZoom();
                    dx /= z;
                    dy /= z;
                    this.moveBy(dx, dy, e);
                    k.updateSelection(dx, dy, this);
                    k.updatePosses(dx, dy, this);
                }
            }
        }.bind(this);

        this.upListener = function(e) {
            if (downAt) {
                downAt = null;
                this.params.unbind(document, "mousemove", this.moveListener);
                this.params.unbind(document, "mouseup", this.upListener);
                this.params.removeClass(document.body, css.noSelect);
                this.unmark(e);
                k.unmarkSelection(this, e);
                k.unmarkPosses(this, e);
                this.stop(e);
                k.notifySelectionDragStop(this, e);
                k.notifyPosseDragStop(this, e);
                moving = false;
                if (clone) {
                    dragEl && dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
                    dragEl = null;
                }

                intersectingDroppables.length = 0;

                if (revertFunction && revertFunction(this.el, this.params.getPosition(this.el)) === true) {
                    this.params.setPosition(this.el, posAtDown);
                    _dispatch("revert", this.el);
                }
            }
        }.bind(this);

        this.getFilters = function() { return _filters; };

        this.abort = function() {
            if (downAt != null)
                this.upListener();
        };

        this.getDragElement = function() {
            return dragEl || this.el;
        };

        var listeners = {"start":[], "drag":[], "stop":[], "over":[], "out":[], "beforeStart":[], "revert":[] };
        if (params.events.start) listeners.start.push(params.events.start);
        if (params.events.beforeStart) listeners.beforeStart.push(params.events.beforeStart);
        if (params.events.stop) listeners.stop.push(params.events.stop);
        if (params.events.drag) listeners.drag.push(params.events.drag);
        if (params.events.revert) listeners.revert.push(params.events.revert);

        this.on = function(evt, fn) {
            if (listeners[evt]) listeners[evt].push(fn);
        };

        this.off = function(evt, fn) {
            if (listeners[evt]) {
                var l = [];
                for (var i = 0; i < listeners[evt].length; i++) {
                    if (listeners[evt][i] !== fn) l.push(listeners[evt][i]);
                }
                listeners[evt] = l;
            }
        };

        var _dispatch = function(evt, value) {
            if (listeners[evt]) {
                for (var i = 0; i < listeners[evt].length; i++) {
                    try {
                        listeners[evt][i](value);
                    }
                    catch (e) { }
                }
            }
        };

        this.notifyStart = function(e) {
            _dispatch("start", {el:this.el, pos:this.params.getPosition(dragEl), e:e, drag:this});
        };

        this.stop = function(e, force) {
            if (force || moving) {
                var positions = [],
                    sel = k.getSelection(),
                    dPos = this.params.getPosition(dragEl);

                if (sel.length > 1) {
                    for (var i = 0; i < sel.length; i++) {
                        var p = this.params.getPosition(sel[i].el);
                        positions.push([ sel[i].el, { left: p[0], top: p[1] }, sel[i] ]);
                    }
                }
                else {
                    positions.push([ dragEl, {left:dPos[0], top:dPos[1]}, this ]);
                }

                _dispatch("stop", {
                    el: dragEl,
                    pos: ghostProxyOffsets || dPos,
                    finalPos:dPos,
                    e: e,
                    drag: this,
                    selection:positions
                });
            }
        };

        this.mark = function(andNotify) {
            posAtDown = this.params.getPosition(dragEl);
            pagePosAtDown = this.params.getPosition(dragEl, true);
            pageDelta = [pagePosAtDown[0] - posAtDown[0], pagePosAtDown[1] - posAtDown[1]];
            this.size = this.params.getSize(dragEl);
            matchingDroppables = k.getMatchingDroppables(this);
            _setDroppablesActive(matchingDroppables, true, false, this);
            this.params.addClass(dragEl, this.params.dragClass || css.drag);
            //if (this.params.constrain || this.params.containment) {
            var cs = this.params.getSize(dragEl.parentNode);
            constrainRect = { w:cs[0], h:cs[1] };
            //}
            if (andNotify) {
                k.notifySelectionDragStart(this);
            }
        };
        var ghostProxyOffsets;
        this.unmark = function(e, doNotCheckDroppables) {
            _setDroppablesActive(matchingDroppables, false, true, this);


            if (isConstrained && useGhostProxy(this.el)) {
                ghostProxyOffsets = [dragEl.offsetLeft, dragEl.offsetTop];
                this.el.parentNode.removeChild(dragEl);
                dragEl = this.el;
            }
            else {
                ghostProxyOffsets = null;
            }

            this.params.removeClass(dragEl, this.params.dragClass || css.drag);
            matchingDroppables.length = 0;
            isConstrained = false;
            if (!doNotCheckDroppables) {
                if (intersectingDroppables.length > 0 && ghostProxyOffsets) {
                    params.setPosition(this.el, ghostProxyOffsets);
                }
                intersectingDroppables.sort(_rankSort);
                for (var i = 0; i < intersectingDroppables.length; i++) {
                    var retVal = intersectingDroppables[i].drop(this, e);
                    if (retVal === true) break;
                }
            }
        };
        this.moveBy = function(dx, dy, e) {
            intersectingDroppables.length = 0;
            var desiredLoc = this.toGrid([posAtDown[0] + dx, posAtDown[1] + dy]),
                cPos = constrain(desiredLoc, dragEl);

            if (useGhostProxy(this.el)) {
                if (desiredLoc[0] != cPos[0] || desiredLoc[1] != cPos[1]) {
                    if (!isConstrained) {
                        var gp = ghostProxy(this.el);
                        params.addClass(gp, _classes.ghostProxy);
                        this.el.parentNode.appendChild(gp);
                        dragEl = gp;
                        isConstrained = true;
                    }
                    cPos = desiredLoc;
                }
                else {
                    if (isConstrained) {
                        this.el.parentNode.removeChild(dragEl);
                        dragEl = this.el;
                        isConstrained = false;
                    }
                }
            }

            var rect = { x:cPos[0], y:cPos[1], w:this.size[0], h:this.size[1]},
                pageRect = { x:rect.x + pageDelta[0], y:rect.y + pageDelta[1], w:rect.w, h:rect.h},
                focusDropElement = null;



            this.params.setPosition(dragEl, cPos);
            for (var i = 0; i < matchingDroppables.length; i++) {
                var r2 = { x:matchingDroppables[i].pagePosition[0], y:matchingDroppables[i].pagePosition[1], w:matchingDroppables[i].size[0], h:matchingDroppables[i].size[1]};
                if (this.params.intersects(pageRect, r2) && (_multipleDrop || focusDropElement == null || focusDropElement == matchingDroppables[i].el) && matchingDroppables[i].canDrop(this)) {
                    if (!focusDropElement) focusDropElement = matchingDroppables[i].el;
                    intersectingDroppables.push(matchingDroppables[i]);
                    matchingDroppables[i].setHover(this, true, e);
                }
                else if (matchingDroppables[i].isHover()) {
                    matchingDroppables[i].setHover(this, false, e);
                }
            }

            _dispatch("drag", {el:this.el, pos:cPos, e:e, drag:this});

            /* test to see if the parent needs to be scrolled (future)
             if (scroll) {
             var pnsl = dragEl.parentNode.scrollLeft, pnst = dragEl.parentNode.scrollTop;
             console.log("scroll!", pnsl, pnst);
             }*/
        };
        this.destroy = function() {
            this.params.unbind(this.el, "mousedown", this.downListener);
            this.params.unbind(document, "mousemove", this.moveListener);
            this.params.unbind(document, "mouseup", this.upListener);
            this.downListener = null;
            this.upListener = null;
            this.moveListener = null;
        };

        // init:register mousedown, and perhaps set a filter
        this.params.bind(this.el, "mousedown", this.downListener);

        // if handle provded, use that.  otherwise, try to set a filter.
        // note that a `handle` selector always results in filterExclude being set to false, ie.
        // the selector defines the handle element(s).
        if (this.params.handle)
            _setFilter(this.params.handle, false);
        else
            _setFilter(this.params.filter, this.params.filterExclude);
    };

    var Drop = function(el, params, css, scope) {
        this._class = css.droppable;
        this.params = params || {};
        this.rank = params.rank || 0;
        this._activeClass = this.params.activeClass || css.active;
        this._hoverClass = this.params.hoverClass || css.hover;
        Super.apply(this, arguments);
        var hover = false;
        this.allowLoopback = this.params.allowLoopback !== false;

        this.setActive = function(val) {
            this.params[val ? "addClass" : "removeClass"](this.el, this._activeClass);
        };

        this.updatePosition = function() {
            this.position = this.params.getPosition(this.el);
            this.pagePosition = this.params.getPosition(this.el, true);
            this.size = this.params.getSize(this.el);
        };

        this.canDrop = this.params.canDrop || function(drag) {
            return true;
        };

        this.isHover = function() { return hover; };

        this.setHover = function(drag, val, e) {
            // if turning off hover but this was not the drag that caused the hover, ignore.
            if (val || this.el._katavorioDragHover == null || this.el._katavorioDragHover == drag.el._katavorio) {
                this.params[val ? "addClass" : "removeClass"](this.el, this._hoverClass);
                //this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                if (hover !== val)
                    this.params.events[val ? "over" : "out"]({el:this.el, e:e, drag:drag, drop:this});
                hover = val;
            }
        };

        this.drop = function(drag, event) {
            return this.params.events["drop"]({ drag:drag, e:event, drop:this });
        };

        this.destroy = function() {
            this._class = null;
            this._activeClass = null;
            this._hoverClass = null;
            //this.params = null;
            hover = null;
            //this.el = null;
        };
    };

    var _uuid = function() {
        return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        }));
    };

    var _rankSort = function(a,b) {
        return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : 0;
    };

    var _gel = function(el) {
        if (el == null) return null;
        el = (typeof el === "string" || el.constructor == String)  ? document.getElementById(el) : el;
        if (el == null) return null;
        el._katavorio = el._katavorio || _uuid();
        return el;
    };

    root.Katavorio = function(katavorioParams) {

        var _selection = [],
            _selectionMap = {};

        this._dragsByScope = {};
        this._dropsByScope = {};
        var _zoom = 1,
            _reg = function(obj, map) {
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        map[_obj.scopes[i]] = map[_obj.scopes[i]] || [];
                        map[_obj.scopes[i]].push(_obj);
                    }
                });
            },
            _unreg = function(obj, map) {
                var c = 0;
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        if (map[_obj.scopes[i]]) {
                            var idx = katavorioParams.indexOf(map[_obj.scopes[i]], _obj);
                            if (idx != -1) {
                                map[_obj.scopes[i]].splice(idx, 1);
                                c++;
                            }
                        }
                    }
                });

                return c > 0 ;
            },
            _getMatchingDroppables = this.getMatchingDroppables = function(drag) {
                var dd = [], _m = {};
                for (var i = 0; i < drag.scopes.length; i++) {
                    var _dd = this._dropsByScope[drag.scopes[i]];
                    if (_dd) {
                        for (var j = 0; j < _dd.length; j++) {
                            if (_dd[j].canDrop(drag) &&  !_m[_dd[j].uuid] && (_dd[j].allowLoopback || _dd[j].el !== drag.el)) {
                                _m[_dd[j].uuid] = true;
                                dd.push(_dd[j]);
                            }
                        }
                    }
                }
                dd.sort(_rankSort);
                return dd;
            },
            _prepareParams = function(p) {
                p = p || {};
                var _p = {
                    events:{}
                }, i;
                for (i in katavorioParams) _p[i] = katavorioParams[i];
                for (i in p) _p[i] = p[i];
                // events

                for (i = 0; i < _events.length; i++) {
                    _p.events[_events[i]] = p[_events[i]] || _devNull;
                }
                _p.katavorio = this;
                return _p;
            }.bind(this),
            _mistletoe = function(existingDrag, params) {
                for (var i = 0; i < _events.length; i++) {
                    if (params[_events[i]]) {
                        existingDrag.on(_events[i], params[_events[i]]);
                    }
                }
            }.bind(this),
            _css = {},
            overrideCss = katavorioParams.css || {},
            _scope = katavorioParams.scope || _defaultScope;

        // prepare map of css classes based on defaults frst, then optional overrides
        for (var i in _classes) _css[i] = _classes[i];
        for (var i in overrideCss) _css[i] = overrideCss[i];

        var inputFilterSelector = katavorioParams.inputFilterSelector || _defaultInputFilterSelector;
        /**
         * Gets the selector identifying which input elements to filter from drag events.
         * @method getInputFilterSelector
         * @return {String} Current input filter selector.
         */
        this.getInputFilterSelector = function() { return inputFilterSelector; };

        /**
         * Sets the selector identifying which input elements to filter from drag events.
         * @method setInputFilterSelector
         * @param {String} selector Input filter selector to set.
         * @return {Katavorio} Current instance; method may be chained.
         */
        this.setInputFilterSelector = function(selector) {
            inputFilterSelector = selector;
            return this;
        };

        this.draggable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    if (_el._katavorioDrag == null) {
                        var p = _prepareParams(params);
                        _el._katavorioDrag = new Drag(_el, p, _css, _scope);
                        _reg(_el._katavorioDrag, this._dragsByScope);
                        o.push(_el._katavorioDrag);
                        katavorioParams.addClass(_el, _css.draggable);
                    }
                    else {
                        _mistletoe(_el._katavorioDrag, params);
                    }
                }
            }.bind(this));
            return o;

        };

        this.droppable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    var drop = new Drop(_el, _prepareParams(params), _css, _scope);
                    _el._katavorioDrop = _el._katavorioDrop || [];
                    _el._katavorioDrop.push(drop);
                    _reg(drop, this._dropsByScope);
                    o.push(drop);
                    katavorioParams.addClass(_el, _css.droppable);
                }
            }.bind(this));
            return o;
        };

        /**
         * @name Katavorio#select
         * @function
         * @desc Adds an element to the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to add.
         */
        this.select = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorioDrag) {
                    if (!_selectionMap[_el._katavorio]) {
                        _selection.push(_el._katavorioDrag);
                        _selectionMap[_el._katavorio] = [ _el, _selection.length - 1 ];
                        katavorioParams.addClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        /**
         * @name Katavorio#deselect
         * @function
         * @desc Removes an element from the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to remove.
         */
        this.deselect = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorio) {
                    var e = _selectionMap[_el._katavorio];
                    if (e) {
                        var _s = [];
                        for (var i = 0; i < _selection.length; i++)
                            if (_selection[i].el !== _el) _s.push(_selection[i]);
                        _selection = _s;
                        delete _selectionMap[_el._katavorio];
                        katavorioParams.removeClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        this.deselectAll = function() {
            for (var i in _selectionMap) {
                var d = _selectionMap[i];
                katavorioParams.removeClass(d[0], _css.selected);
            }

            _selection.length = 0;
            _selectionMap = {};
        };

        this.markSelection = function(drag) {
            _foreach(_selection, function(e) { e.mark(); }, drag);
        };

        this.markPosses = function(drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.mark();
                        }, drag);
                    }
                })
            }
        };

        this.unmarkSelection = function(drag, event) {
            _foreach(_selection, function(e) { e.unmark(event); }, drag);
        };

        this.unmarkPosses = function(drag, event) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.unmark(event, true);
                        }, drag);
                    }
                });
            }
        };

        this.getSelection = function() { return _selection.slice(0); };

        this.updateSelection = function(dx, dy, drag) {
            _foreach(_selection, function(e) { e.moveBy(dx, dy); }, drag);
        };

        var _posseAction = function(fn, drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (e) {
                            fn(e);
                        }, drag);
                    }
                });
            }
        };

        this.updatePosses = function(dx, dy, drag) {
            _posseAction(function(e) { e.moveBy(dx, dy); }, drag);
        };

        this.notifyPosseDragStop = function(drag, evt) {
            _posseAction(function(e) { e.stop(evt, true); }, drag);
        };

        this.notifySelectionDragStop = function(drag, evt) {
            _foreach(_selection, function(e) { e.stop(evt, true); }, drag);
        };

        this.notifySelectionDragStart = function(drag, evt) {
            _foreach(_selection, function(e) { e.notifyStart(evt);}, drag);
        };

        this.setZoom = function(z) { _zoom = z; };
        this.getZoom = function() { return _zoom; };

        // does the work of changing scopes
        var _scopeManip = function(kObj, scopes, map, fn) {
            _each(kObj, function(_kObj) {
                _unreg(_kObj, map);  // deregister existing scopes
                _kObj[fn](scopes); // set scopes
                _reg(_kObj, map); // register new ones
            });
        };

        _each([ "set", "add", "remove", "toggle"], function(v) {
            this[v + "Scope"] = function(el, scopes) {
                _scopeManip(el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
                _scopeManip(el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
            this[v + "DragScope"] = function(el, scopes) {
                _scopeManip(el.constructor === Drag ? el : el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
            }.bind(this);
            this[v + "DropScope"] = function(el, scopes) {
                _scopeManip(el.constructor === Drop ? el : el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
        }.bind(this));

        this.snapToGrid = function(x, y) {
            for (var s in this._dragsByScope) {
                _foreach(this._dragsByScope[s], function(d) { d.snap(x, y); });
            }
        };

        this.getDragsForScope = function(s) { return this._dragsByScope[s]; };
        this.getDropsForScope = function(s) { return this._dropsByScope[s]; };

        var _destroy = function(el, type, map) {
            el = _gel(el);
            if (el[type]) {

                // remove from selection, if present.
                var selIdx = _selection.indexOf(el[type]);
                if (selIdx >= 0) {
                    _selection.splice(selIdx, 1);
                }

                if (_unreg(el[type], map)) {
                    _each(el[type], function(kObj) { kObj.destroy() });
                }

                delete el[type];
            }
        };

        this.elementRemoved = function(el) {
            this.destroyDraggable(el);
            this.destroyDroppable(el);
        };

        this.destroyDraggable = function(el) {
            _destroy(el, "_katavorioDrag", this._dragsByScope);
        };

        this.destroyDroppable = function(el) {
            _destroy(el, "_katavorioDrop", this._dropsByScope);
        };

        this.reset = function() {
            this._dragsByScope = {};
            this._dropsByScope = {};
            _selection = [];
            _selectionMap = {};
            _posses = {};
        };

        // ----- groups
        var _posses = {};

        var _processOneSpec = function(el, _spec, dontAddExisting) {
            var posseId = _isString(_spec) ? _spec : _spec.id;
            var active = _isString(_spec) ? true : _spec.active !== false;
            var posse = _posses[posseId] || (function() {
                var g = {name:posseId, members:[]};
                _posses[posseId] = g;
                return g;
            })();
            _each(el, function(_el) {
                if (_el._katavorioDrag) {

                    if (dontAddExisting && _el._katavorioDrag.posseRoles[posse.name] != null) return;

                    _suggest(posse.members, _el._katavorioDrag);
                    _suggest(_el._katavorioDrag.posses, posse.name);
                    _el._katavorioDrag.posseRoles[posse.name] = active;
                }
            });
            return posse;
        };

        /**
         * Add the given element to the posse with the given id, creating the group if it at first does not exist.
         * @method addToPosse
         * @param {Element} el Element to add.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) was/were added.
         */
        this.addToPosse = function(el, spec) {

            var posses = [];

            for (var i = 1; i < arguments.length; i++) {
                posses.push(_processOneSpec(el, arguments[i]));
            }

            return posses.length == 1 ? posses[0] : posses;
        };

        /**
         * Sets the posse(s) for the element with the given id, creating those that do not yet exist, and removing from
         * the element any current Posses that are not specified by this method call. This method will not change the
         * active/passive state if it is given a posse in which the element is already a member.
         * @method setPosse
         * @param {Element} el Element to set posse(s) on.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) now belongs.
         */
        this.setPosse = function(el, spec) {

            var posses = [];

            for (var i = 1; i < arguments.length; i++) {
                posses.push(_processOneSpec(el, arguments[i], true).name);
            }

            _each(el, function(_el) {
                if (_el._katavorioDrag) {
                    var diff = _difference(_el._katavorioDrag.posses, posses);
                    var p = [];
                    Array.prototype.push.apply(p, _el._katavorioDrag.posses);
                    for (var i = 0; i < diff.length; i++) {
                        this.removeFromPosse(_el, diff[i]);
                    }
                }
            }.bind(this));

            return posses.length == 1 ? posses[0] : posses;
        };

        /**
         * Remove the given element from the given posse(s).
         * @method removeFromPosse
         * @param {Element} el Element to remove.
         * @param {String...} posseId Varargs parameter: one value for each posse to remove the element from.
         */
        this.removeFromPosse = function(el, posseId) {
            if (arguments.length < 2) throw new TypeError("No posse id provided for remove operation");
            for(var i = 1; i < arguments.length; i++) {
                posseId = arguments[i];
                _each(el, function (_el) {
                    if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                        var d = _el._katavorioDrag;
                        _each(posseId, function (p) {
                            _vanquish(_posses[p].members, d);
                            _vanquish(d.posses, p);
                            delete d.posseRoles[p];
                        });
                    }
                });
            }
        };

        /**
         * Remove the given element from all Posses to which it belongs.
         * @method removeFromAllPosses
         * @param {Element|Element[]} el Element to remove from Posses.
         */
        this.removeFromAllPosses = function(el) {
            _each(el, function(_el) {
                if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                    var d = _el._katavorioDrag;
                    _each(d.posses, function(p) {
                        _vanquish(_posses[p].members, d);
                    });
                    d.posses.length = 0;
                    d.posseRoles = {};
                }
            });
        };

        /**
         * Changes the participation state for the element in the Posse with the given ID.
         * @param {Element|Element[]} el Element(s) to change state for.
         * @param {String} posseId ID of the Posse to change element state for.
         * @param {Boolean} state True to make active, false to make passive.
         */
        this.setPosseState = function(el, posseId, state) {
            var posse = _posses[posseId];
            if (posse) {
                _each(el, function(_el) {
                    if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                        _el._katavorioDrag.posseRoles[posse.name] = state;
                    }
                });
            }
        };

    };

    root.Katavorio.version = "0.19.2";

    if (typeof exports !== "undefined") {
        exports.Katavorio = root.Katavorio;
    }

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in both browsers and headless.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */

;
(function () {

    var _isa = function (a) {
            return Object.prototype.toString.call(a) === "[object Array]";
        },
        _isnum = function (n) {
            return Object.prototype.toString.call(n) === "[object Number]";
        },
        _iss = function (s) {
            return typeof s === "string";
        },
        _isb = function (s) {
            return typeof s === "boolean";
        },
        _isnull = function (s) {
            return s == null;
        },
        _iso = function (o) {
            return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
        },
        _isd = function (o) {
            return Object.prototype.toString.call(o) === "[object Date]";
        },
        _isf = function (o) {
            return Object.prototype.toString.call(o) === "[object Function]";
        },
        _isNamedFunction = function(o) {
            return _isf(o) && o.name != null && o.name.length > 0;
        },
        _ise = function (o) {
            for (var i in o) {
                if (o.hasOwnProperty(i)) return false;
            }
            return true;
        };

    var root = this;
    root.jsPlumbUtil = {
        isArray: _isa,
        isString: _iss,
        isBoolean: _isb,
        isNull: _isnull,
        isObject: _iso,
        isDate: _isd,
        isFunction: _isf,
        isEmpty: _ise,
        isNumber: _isnum,
        clone: function (a) {
            if (_iss(a)) return "" + a;
            else if (_isb(a)) return !!a;
            else if (_isd(a)) return new Date(a.getTime());
            else if (_isf(a)) return a;
            else if (_isa(a)) {
                var b = [];
                for (var i = 0; i < a.length; i++)
                    b.push(this.clone(a[i]));
                return b;
            }
            else if (_iso(a)) {
                var c = {};
                for (var j in a)
                    c[j] = this.clone(a[j]);
                return c;
            }
            else return a;
        },
        merge: function (a, b, collations) {
            // first change the collations array - if present - into a lookup table, because its faster.
            var cMap = {}, ar, i;
            collations = collations || [];
            for (i = 0; i < collations.length; i++)
                cMap[collations[i]] = true;

            var c = this.clone(a);
            for (i in b) {
                if (c[i] == null) {
                    c[i] = b[i];
                }
                else if (_iss(b[i]) || _isb(b[i])) {
                    if (!cMap[i]) {
                        c[i] = b[i]; // if we dont want to collate, just copy it in.
                    }
                    else {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        ar.push.apply(ar, _isa(c[i]) ? c[i] : [ c[i] ]);
                        ar.push.apply(ar, _isa(b[i]) ? b[i] : [ b[i] ]);
                        c[i] = ar;
                    }
                }
                else {
                    if (_isa(b[i])) {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        if (_isa(c[i])) ar.push.apply(ar, c[i]);
                        ar.push.apply(ar, b[i]);
                        c[i] = ar;
                    }
                    else if (_iso(b[i])) {
                        // overwite c's value with an object if it is not already one.
                        if (!_iso(c[i]))
                            c[i] = {};
                        for (var j in b[i]) {
                            c[i][j] = b[i][j];
                        }
                    }
                }

            }
            return c;
        },
        replace: function (inObj, path, value) {
            if (inObj == null) return;
            var q = inObj, t = q;
            path.replace(/([^\.])+/g, function (term, lc, pos, str) {
                var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
                    last = pos + term.length >= str.length,
                    _getArray = function () {
                        return t[array[1]] || (function () {
                            t[array[1]] = [];
                            return t[array[1]];
                        })();
                    };

                if (last) {
                    // set term = value on current t, creating term as array if necessary.
                    if (array)
                        _getArray()[array[3]] = value;
                    else
                        t[term] = value;
                }
                else {
                    // set to current t[term], creating t[term] if necessary.
                    if (array) {
                        var a = _getArray();
                        t = a[array[3]] || (function () {
                            a[array[3]] = {};
                            return a[array[3]];
                        })();
                    }
                    else
                        t = t[term] || (function () {
                            t[term] = {};
                            return t[term];
                        })();
                }
            });

            return inObj;
        },
        //
        // chain a list of functions, supplied by [ object, method name, args ], and return on the first
        // one that returns the failValue. if none return the failValue, return the successValue.
        //
        functionChain: function (successValue, failValue, fns) {
            for (var i = 0; i < fns.length; i++) {
                var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
                if (o === failValue) {
                    return o;
                }
            }
            return successValue;
        },
        // take the given model and expand out any parameters.
        // 'functionPrefix' is optional, and if present, helps jsplumb figure out what to do if a value is a Function.
        // if you do not provide it, jsplumb will run the given values through any functions it finds, and use the function's
        // output as the value in the result. if you do provide the prefix, only functions that are named and have this prefix
        // will be executed; other functions will be passed as values to the output.
        populate: function (model, values, functionPrefix) {
            // for a string, see if it has parameter matches, and if so, try to make the substitutions.
            var getValue = function (fromString) {
                    var matches = fromString.match(/(\${.*?})/g);
                    if (matches != null) {
                        for (var i = 0; i < matches.length; i++) {
                            var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
                            if (val != null) {
                                fromString = fromString.replace(matches[i], val);
                            }
                        }
                    }
                    return fromString;
                },
            // process one entry.
                _one = function (d) {
                    if (d != null) {
                        if (_iss(d)) {
                            return getValue(d);
                        }
                        else if (_isf(d) && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
                            return d(values);
                        }
                        else if (_isa(d)) {
                            var r = [];
                            for (var i = 0; i < d.length; i++)
                                r.push(_one(d[i]));
                            return r;
                        }
                        else if (_iso(d)) {
                            var s = {};
                            for (var j in d) {
                                s[j] = _one(d[j]);
                            }
                            return s;
                        }
                        else {
                            return d;
                        }
                    }
                };

            return _one(model);
        },
        findWithFunction: function (a, f) {
            if (a)
                for (var i = 0; i < a.length; i++) if (f(a[i])) return i;
            return -1;
        },
        removeWithFunction: function (a, f) {
            var idx = root.jsPlumbUtil.findWithFunction(a, f);
            if (idx > -1) a.splice(idx, 1);
            return idx != -1;
        },
        remove: function (l, v) {
            var idx = l.indexOf(v);
            if (idx > -1) l.splice(idx, 1);
            return idx != -1;
        },
        // TODO support insert index
        addWithFunction: function (list, item, hashFunction) {
            if (root.jsPlumbUtil.findWithFunction(list, hashFunction) == -1) list.push(item);
        },
        addToList: function (map, key, value, insertAtStart) {
            var l = map[key];
            if (l == null) {
                l = [];
                map[key] = l;
            }
            l[insertAtStart ? "unshift" : "push"](value);
            return l;
        },
        suggest : function(list, item, insertAtHead) {
            if (list.indexOf(item) === -1) {
                if (insertAtHead) {
                    list.unshift(item);
                } else {
                    list.push(item);
                }
                return true;
            }
            return false;
        },
        //
        // extends the given obj (which can be an array) with the given constructor function, prototype functions, and
        // class members, any of which may be null.
        //
        extend: function (child, parent, _protoFn) {
            var i;
            parent = _isa(parent) ? parent : [ parent ];

            for (i = 0; i < parent.length; i++) {
                for (var j in parent[i].prototype) {
                    if (parent[i].prototype.hasOwnProperty(j)) {
                        child.prototype[j] = parent[i].prototype[j];
                    }
                }
            }

            var _makeFn = function (name, protoFn) {
                return function () {
                    for (i = 0; i < parent.length; i++) {
                        if (parent[i].prototype[name])
                            parent[i].prototype[name].apply(this, arguments);
                    }
                    return protoFn.apply(this, arguments);
                };
            };

            var _oneSet = function (fns) {
                for (var k in fns) {
                    child.prototype[k] = _makeFn(k, fns[k]);
                }
            };

            if (arguments.length > 2) {
                for (i = 2; i < arguments.length; i++)
                    _oneSet(arguments[i]);
            }

            return child;
        },
        uuid: function () {
            return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            }));
        },
        logEnabled: true,
        log: function () {
            if (root.jsPlumbUtil.logEnabled && typeof console != "undefined") {
                try {
                    var msg = arguments[arguments.length - 1];
                    console.log(msg);
                }
                catch (e) {
                }
            }
        },

        /**
         * Wraps one function with another, creating a placeholder for the
         * wrapped function if it was null. this is used to wrap the various
         * drag/drop event functions - to allow jsPlumb to be notified of
         * important lifecycle events without imposing itself on the user's
         * drag/drop functionality.
         * @method jsPlumbUtil.wrap
         * @param {Function} wrappedFunction original function to wrap; may be null.
         * @param {Function} newFunction function to wrap the original with.
         * @param {Object} [returnOnThisValue] Optional. Indicates that the wrappedFunction should
         * not be executed if the newFunction returns a value matching 'returnOnThisValue'.
         * note that this is a simple comparison and only works for primitives right now.
         */
        wrap: function (wrappedFunction, newFunction, returnOnThisValue) {
            wrappedFunction = wrappedFunction || function () {
            };
            newFunction = newFunction || function () {
            };
            return function () {
                var r = null;
                try {
                    r = newFunction.apply(this, arguments);
                } catch (e) {
                    root.jsPlumbUtil.log("jsPlumb function failed : " + e);
                }
                if (returnOnThisValue == null || (r !== returnOnThisValue)) {
                    try {
                        r = wrappedFunction.apply(this, arguments);
                    } catch (e) {
                        root.jsPlumbUtil.log("wrapped function failed : " + e);
                    }
                }
                return r;
            };
        }
    };

    root.jsPlumbUtil.EventGenerator = function () {
        var _listeners = {},
            eventsSuspended = false,
        // this is a list of events that should re-throw any errors that occur during their dispatch. it is current private.
            eventsToDieOn = { "ready": true };

        this.bind = function (event, listener, insertAtStart) {
            var _one = function(evt) {
                root.jsPlumbUtil.addToList(_listeners, evt, listener, insertAtStart);
                listener.__jsPlumb = listener.__jsPlumb || {};
                listener.__jsPlumb[root.jsPlumbUtil.uuid()] = evt;
            };

            if (typeof event === "string") _one(event);
            else if (event.length != null) {
                for (var i = 0; i < event.length; i++) {
                    _one(event[i]);
                }
            }

            return this;
        };

        this.fire = function (event, value, originalEvent) {
            if (!eventsSuspended && _listeners[event]) {
                var l = _listeners[event].length, i = 0, _gone = false, ret = null;
                if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
                    while (!_gone && i < l && ret !== false) {
                        // doing it this way rather than catching and then possibly re-throwing means that an error propagated by this
                        // method will have the whole call stack available in the debugger.
                        if (eventsToDieOn[event])
                            _listeners[event][i].apply(this, [ value, originalEvent]);
                        else {
                            try {
                                ret = _listeners[event][i].apply(this, [ value, originalEvent ]);
                            } catch (e) {
                                root.jsPlumbUtil.log("jsPlumb: fire failed for event " + event + " : " + e);
                            }
                        }
                        i++;
                        if (_listeners == null || _listeners[event] == null)
                            _gone = true;
                    }
                }
            }
            return this;
        };

        this.unbind = function (eventOrListener, listener) {

            if (arguments.length === 0) {
                _listeners = {};
            }
            else if (arguments.length === 1) {
                if (typeof eventOrListener === "string")
                    delete _listeners[eventOrListener];
                else if (eventOrListener.__jsPlumb) {
                    var evt;
                    for (var i in eventOrListener.__jsPlumb) {
                        evt = eventOrListener.__jsPlumb[i];
                        root.jsPlumbUtil.remove(_listeners[evt] || [], eventOrListener);
                    }
                }
            }
            else if (arguments.length === 2) {
                root.jsPlumbUtil.remove(_listeners[eventOrListener] || [], listener);
            }

            return this;
        };

        this.getListener = function (forEvent) {
            return _listeners[forEvent];
        };
        this.setSuspendEvents = function (val) {
            eventsSuspended = val;
        };
        this.isSuspendEvents = function () {
            return eventsSuspended;
        };
        this.silently = function(fn) {
            this.setSuspendEvents(true);
            try {
                fn();
            }
            catch (e) {
                root.jsPlumbUtil.log("Cannot execute silent function " + e);
            }
            this.setSuspendEvents(false);
        };
        this.cleanupListeners = function () {
            for (var i in _listeners) {
                _listeners[i] = null;
            }
        };
    };

    root.jsPlumbUtil.EventGenerator.prototype = {
        cleanup: function () {
            this.cleanupListeners();
        }
    };

    if (typeof exports !== "undefined") {
        exports.jsPlumbUtil = root.jsPlumbUtil;
    }

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in browsers only.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
 ;(function() {

  "use strict";

   var root = this;

    root.jsPlumbUtil.matchesSelector = function(el, selector, ctx) {
       ctx = ctx || el.parentNode;
       var possibles = ctx.querySelectorAll(selector);
       for (var i = 0; i < possibles.length; i++) {
           if (possibles[i] === el)
               return true;
       }
       return false;
   };

    root.jsPlumbUtil.consume = function(e, doNotPreventDefault) {
       if (e.stopPropagation)
           e.stopPropagation();
       else
           e.returnValue = false;

       if (!doNotPreventDefault && e.preventDefault)
            e.preventDefault();
   };

   /*
    * Function: sizeElement
    * Helper to size and position an element. You would typically use
    * this when writing your own Connector or Endpoint implementation.
    *
    * Parameters:
    *  x - [int] x position for the element origin
    *  y - [int] y position for the element origin
    *  w - [int] width of the element
    *  h - [int] height of the element
    *
    */
    root.jsPlumbUtil.sizeElement = function(el, x, y, w, h) {
       if (el) {
           el.style.height = h + "px";
           el.height = h;
           el.style.width = w + "px";
           el.width = w;
           el.style.left = x + "px";
           el.style.top = y + "px";
       }
   };

 }).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the core code.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";

    var root = this;
    var connectorTypes = [], rendererTypes;

    var _ju = root.jsPlumbUtil,

        /**
         * creates a timestamp, using milliseconds since 1970, but as a string.
         */
        _timestamp = function () {
            return "" + (new Date()).getTime();
        },

    // helper method to update the hover style whenever it, or paintStyle, changes.
    // we use paintStyle as the foundation and merge hoverPaintStyle over the
    // top.
        _updateHoverStyle = function (component) {
            if (component._jsPlumb.paintStyle && component._jsPlumb.hoverPaintStyle) {
                var mergedHoverStyle = {};
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.paintStyle);
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.hoverPaintStyle);
                delete component._jsPlumb.hoverPaintStyle;
                // we want the fill of paintStyle to override a gradient, if possible.
                if (mergedHoverStyle.gradient && component._jsPlumb.paintStyle.fill)
                    delete mergedHoverStyle.gradient;
                component._jsPlumb.hoverPaintStyle = mergedHoverStyle;
            }
        },
        events = ["tap", "dbltap", "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu" ],
        eventFilters = { "mouseout": "mouseleave", "mouseexit": "mouseleave" },
        _updateAttachedElements = function (component, state, timestamp, sourceElement) {
            var affectedElements = component.getAttachedElements();
            if (affectedElements) {
                for (var i = 0, j = affectedElements.length; i < j; i++) {
                    if (!sourceElement || sourceElement != affectedElements[i])
                        affectedElements[i].setHover(state, true, timestamp);			// tell the attached elements not to inform their own attached elements.
                }
            }
        },
        _splitType = function (t) {
            return t == null ? null : t.split(" ");
        },
        _mapType = function(map, obj, typeId) {
            for (var i in obj)
                map[i] = typeId;
        },
        _each = function(fn, obj) {
            obj = _ju.isArray(obj) || (obj.length != null && !_ju.isString(obj)) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++) {
                try {
                    fn.apply(obj[i], [ obj[i] ]);
                }
                catch (e) {
                    _ju.log(".each iteration failed : " + e);
                }
            }
        },
        _applyTypes = function (component, params, doNotRepaint) {
            if (component.getDefaultType) {
                var td = component.getTypeDescriptor(), map = {};
                var defType = component.getDefaultType();
                var o = _ju.merge({}, defType);
                _mapType(map, defType, "__default");
                for (var i = 0, j = component._jsPlumb.types.length; i < j; i++) {
                    var tid = component._jsPlumb.types[i];
                    if (tid !== "__default") {
                        var _t = component._jsPlumb.instance.getType(tid, td);
                        if (_t != null) {
                            o = _ju.merge(o, _t, [ "cssClass" ]);
                            _mapType(map, _t, tid);
                        }
                    }
                }

                if (params) {
                    o = _ju.populate(o, params, "_");
                }

                component.applyType(o, doNotRepaint, map);
                if (!doNotRepaint) component.repaint();
            }
        },

// ------------------------------ BEGIN jsPlumbUIComponent --------------------------------------------

        jsPlumbUIComponent = root.jsPlumbUIComponent = function (params) {

            _ju.EventGenerator.apply(this, arguments);

            var self = this,
                a = arguments,
                idPrefix = self.idPrefix,
                id = idPrefix + (new Date()).getTime();

            this._jsPlumb = {
                instance: params._jsPlumb,
                parameters: params.parameters || {},
                paintStyle: null,
                hoverPaintStyle: null,
                paintStyleInUse: null,
                hover: false,
                beforeDetach: params.beforeDetach,
                beforeDrop: params.beforeDrop,
                overlayPlacements: [],
                hoverClass: params.hoverClass || params._jsPlumb.Defaults.HoverClass,
                types: [],
                typeCache:{}
            };

            this.cacheTypeItem = function(key, item, typeId) {
                this._jsPlumb.typeCache[typeId] = this._jsPlumb.typeCache[typeId] || {};
                this._jsPlumb.typeCache[typeId][key] = item;
            };
            this.getCachedTypeItem = function(key, typeId) {
                return this._jsPlumb.typeCache[typeId] ? this._jsPlumb.typeCache[typeId][key] : null;
            };

            this.getId = function () {
                return id;
            };

// ----------------------------- default type --------------------------------------------


            var o = params.overlays || [], oo = {};
            if (this.defaultOverlayKeys) {
                for (var i = 0; i < this.defaultOverlayKeys.length; i++)
                    Array.prototype.push.apply(o, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []);

                for (i = 0; i < o.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = jsPlumb.convertToFullOverlaySpec(o[i]);
                    oo[fo[1].id] = fo;
                }
            }

            var _defaultType = {
                overlays:oo,
                parameters: params.parameters || {},
                scope: params.scope || this._jsPlumb.instance.getDefaultScope()
            };
            this.getDefaultType = function() {
                return _defaultType;
            };
            this.appendToDefaultType = function(obj) {
                for (var i in obj) _defaultType[i] = obj[i];
            };

// ----------------------------- end default type --------------------------------------------

            // all components can generate events

            if (params.events) {
                for (i in params.events)
                    self.bind(i, params.events[i]);
            }

            // all components get this clone function.
            // TODO issue 116 showed a problem with this - it seems 'a' that is in
            // the clone function's scope is shared by all invocations of it, the classic
            // JS closure problem.  for now, jsPlumb does a version of this inline where
            // it used to call clone.  but it would be nice to find some time to look
            // further at this.
            this.clone = function () {
                var o = Object.create(this.constructor.prototype);
                this.constructor.apply(o, a);
                return o;
            }.bind(this);

            // user can supply a beforeDetach callback, which will be executed before a detach
            // is performed; returning false prevents the detach.
            this.isDetachAllowed = function (connection) {
                var r = true;
                if (this._jsPlumb.beforeDetach) {
                    try {
                        r = this._jsPlumb.beforeDetach(connection);
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDetach callback failed", e);
                    }
                }
                return r;
            };

            // user can supply a beforeDrop callback, which will be executed before a dropped
            // connection is confirmed. user can return false to reject connection.
            this.isDropAllowed = function (sourceId, targetId, scope, connection, dropEndpoint, source, target) {
                var r = this._jsPlumb.instance.checkCondition("beforeDrop", {
                    sourceId: sourceId,
                    targetId: targetId,
                    scope: scope,
                    connection: connection,
                    dropEndpoint: dropEndpoint,
                    source: source, target: target
                });
                if (this._jsPlumb.beforeDrop) {
                    try {
                        r = this._jsPlumb.beforeDrop({
                            sourceId: sourceId,
                            targetId: targetId,
                            scope: scope,
                            connection: connection,
                            dropEndpoint: dropEndpoint,
                            source: source, target: target
                        });
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDrop callback failed", e);
                    }
                }
                return r;
            };

            var domListeners = [];

            // sets the component associated with listener events. for instance, an overlay delegates
            // its events back to a connector. but if the connector is swapped on the underlying connection,
            // then this component must be changed. This is called by setConnector in the Connection class.
            this.setListenerComponent = function (c) {
                for (var i = 0; i < domListeners.length; i++)
                    domListeners[i][3] = c;
            };


        };

    var _removeTypeCssHelper = function (component, typeIndex) {
        var typeId = component._jsPlumb.types[typeIndex],
            type = component._jsPlumb.instance.getType(typeId, component.getTypeDescriptor());

        if (type != null) {

            if (type.cssClass && component.canvas)
                component._jsPlumb.instance.removeClass(component.canvas, type.cssClass);
        }
    };

    _ju.extend(root.jsPlumbUIComponent, _ju.EventGenerator, {

        getParameter: function (name) {
            return this._jsPlumb.parameters[name];
        },

        setParameter: function (name, value) {
            this._jsPlumb.parameters[name] = value;
        },

        getParameters: function () {
            return this._jsPlumb.parameters;
        },

        setParameters: function (p) {
            this._jsPlumb.parameters = p;
        },

        getClass:function() {
            return jsPlumb.getClass(this.canvas);
        },

        hasClass:function(clazz) {
            return jsPlumb.hasClass(this.canvas, clazz);
        },

        addClass: function (clazz) {
            jsPlumb.addClass(this.canvas, clazz);
        },

        removeClass: function (clazz) {
            jsPlumb.removeClass(this.canvas, clazz);
        },

        updateClasses: function (classesToAdd, classesToRemove) {
            jsPlumb.updateClasses(this.canvas, classesToAdd, classesToRemove);
        },

        setType: function (typeId, params, doNotRepaint) {
            this.clearTypes();
            this._jsPlumb.types = _splitType(typeId) || [];
            _applyTypes(this, params, doNotRepaint);
        },

        getType: function () {
            return this._jsPlumb.types;
        },

        reapplyTypes: function (params, doNotRepaint) {
            _applyTypes(this, params, doNotRepaint);
        },

        hasType: function (typeId) {
            return this._jsPlumb.types.indexOf(typeId) != -1;
        },

        addType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId), _cont = false;
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    if (!this.hasType(t[i])) {
                        this._jsPlumb.types.push(t[i]);
                        _cont = true;
                    }
                }
                if (_cont) _applyTypes(this, params, doNotRepaint);
            }
        },

        removeType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId), _cont = false, _one = function (tt) {
                var idx = this._jsPlumb.types.indexOf(tt);
                if (idx != -1) {
                    // remove css class if necessary
                    _removeTypeCssHelper(this, idx);
                    this._jsPlumb.types.splice(idx, 1);
                    return true;
                }
                return false;
            }.bind(this);

            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    _cont = _one(t[i]) || _cont;
                }
                if (_cont) _applyTypes(this, params, doNotRepaint);
            }
        },
        clearTypes: function (params, doNotRepaint) {
            var i = this._jsPlumb.types.length;
            for (var j = 0; j < i; j++) {
                _removeTypeCssHelper(this, 0);
                this._jsPlumb.types.splice(0, 1);
            }
            _applyTypes(this, params, doNotRepaint);
        },

        toggleType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId);
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    var idx = this._jsPlumb.types.indexOf(t[i]);
                    if (idx != -1) {
                        _removeTypeCssHelper(this, idx);
                        this._jsPlumb.types.splice(idx, 1);
                    }
                    else
                        this._jsPlumb.types.push(t[i]);
                }

                _applyTypes(this, params, doNotRepaint);
            }
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.hoverPaintStyle, doNotRepaint);
            if (t.parameters) {
                for (var i in t.parameters)
                    this.setParameter(i, t.parameters[i]);
            }
            this._jsPlumb.paintStyleInUse = this.getPaintStyle();
        },
        setPaintStyle: function (style, doNotRepaint) {
//		    	this._jsPlumb.paintStyle = jsPlumb.extend({}, style);
// TODO figure out if we want components to clone paintStyle so as not to share it.
            this._jsPlumb.paintStyle = style;
            this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle;
            _updateHoverStyle(this);
            if (!doNotRepaint) this.repaint();
        },
        getPaintStyle: function () {
            return this._jsPlumb.paintStyle;
        },
        setHoverPaintStyle: function (style, doNotRepaint) {
            //this._jsPlumb.hoverPaintStyle = jsPlumb.extend({}, style);
// TODO figure out if we want components to clone paintStyle so as not to share it.		    	
            this._jsPlumb.hoverPaintStyle = style;
            _updateHoverStyle(this);
            if (!doNotRepaint) this.repaint();
        },
        getHoverPaintStyle: function () {
            return this._jsPlumb.hoverPaintStyle;
        },
        destroy: function (force) {
            if (force || this.typeId == null) {
                this.cleanupListeners(); // this is on EventGenerator
                this.clone = null;
                this._jsPlumb = null;
            }
        },

        isHover: function () {
            return this._jsPlumb.hover;
        },

        setHover: function (hover, ignoreAttachedElements, timestamp) {
            // while dragging, we ignore these events.  this keeps the UI from flashing and
            // swishing and whatevering.
            if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {

                this._jsPlumb.hover = hover;

                if (this.canvas != null) {
                    if (this._jsPlumb.instance.hoverClass != null) {
                        var method = hover ? "addClass" : "removeClass";
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.instance.hoverClass);
                    }
                    if (this._jsPlumb.hoverClass != null) {
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.hoverClass);
                    }
                }
                if (this._jsPlumb.hoverPaintStyle != null) {
                    this._jsPlumb.paintStyleInUse = hover ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle;
                    if (!this._jsPlumb.instance.isSuspendDrawing()) {
                        timestamp = timestamp || _timestamp();
                        this.repaint({timestamp: timestamp, recalc: false});
                    }
                }
                // get the list of other affected elements, if supported by this component.
                // for a connection, its the endpoints.  for an endpoint, its the connections! surprise.
                if (this.getAttachedElements && !ignoreAttachedElements)
                    _updateAttachedElements(this, hover, _timestamp(), this);
            }
        }
    });

// ------------------------------ END jsPlumbUIComponent --------------------------------------------

    var _jsPlumbInstanceIndex = 0,
        getInstanceIndex = function () {
            var i = _jsPlumbInstanceIndex + 1;
            _jsPlumbInstanceIndex++;
            return i;
        };

    var jsPlumbInstance = root.jsPlumbInstance = function (_defaults) {

        this.version = "2.4.0";

        if (_defaults) jsPlumb.extend(this.Defaults, _defaults);

        this.logEnabled = this.Defaults.LogEnabled;
        this._connectionTypes = {};
        this._endpointTypes = {};

        _ju.EventGenerator.apply(this);

        var _currentInstance = this,
            _instanceIndex = getInstanceIndex(),
            _bb = _currentInstance.bind,
            _initialDefaults = {},
            _zoom = 1,
            _info = function (el) {
                if (el == null) return null;
                else if (el.nodeType == 3 || el.nodeType == 8) {
                    return { el:el, text:true };
                }
                else {
                    var _el = _currentInstance.getElement(el);
                    return { el: _el, id: (_ju.isString(el) && _el == null) ? el : _getId(_el) };
                }
            };

        this.getInstanceIndex = function () {
            return _instanceIndex;
        };

        this.setZoom = function (z, repaintEverything) {
            _zoom = z;
            _currentInstance.fire("zoom", _zoom);
            if (repaintEverything) _currentInstance.repaintEverything();
            return true;
        };
        this.getZoom = function () {
            return _zoom;
        };

        for (var i in this.Defaults)
            _initialDefaults[i] = this.Defaults[i];

        var _container, _containerDelegations = [];
        this.unbindContainer = function() {
            if (_container != null && _containerDelegations.length > 0) {
                for (var i = 0; i < _containerDelegations.length; i++) {
                    _currentInstance.off(_container, _containerDelegations[i][0], _containerDelegations[i][1]);
                }
            }
        };
        this.setContainer = function (c) {

            this.unbindContainer();

            // get container as dom element.
            c = this.getElement(c);
            // move existing connections and endpoints, if any.
            this.select().each(function (conn) {
                conn.moveParent(c);
            });
            this.selectEndpoints().each(function (ep) {
                ep.moveParent(c);
            });

            // set container.
            var previousContainer = _container;
            _container = c;
            _containerDelegations.length = 0;
            var eventAliases = {
                "endpointclick":"endpointClick",
                "endpointdblclick":"endpointDblClick"
            };

            var _oneDelegateHandler = function (id, e, componentType) {
                var t = e.srcElement || e.target,
                    jp = (t && t.parentNode ? t.parentNode._jsPlumb : null) || (t ? t._jsPlumb : null) || (t && t.parentNode && t.parentNode.parentNode ? t.parentNode.parentNode._jsPlumb : null);
                if (jp) {
                    jp.fire(id, jp, e);
                    var alias = componentType ? eventAliases[componentType + id] || id : id;
                    // jsplumb also fires every event coming from components/overlays. That's what the test for `jp.component` is for.
                    _currentInstance.fire(alias, jp.component || jp, e);
                }
            };

            var _addOneDelegate = function(eventId, selector, fn) {
                _containerDelegations.push([eventId, fn]);
                _currentInstance.on(_container, eventId, selector, fn);
            };

            // delegate one event on the container to jsplumb elements. it might be possible to
            // abstract this out: each of endpoint, connection and overlay could register themselves with
            // jsplumb as "component types" or whatever, and provide a suitable selector. this would be
            // done by the renderer (although admittedly from 2.0 onwards we're not supporting vml anymore)
            var _oneDelegate = function (id) {
                // connections.
                _addOneDelegate(id, ".jtk-connector", function (e) {
                    _oneDelegateHandler(id, e);
                });
                // endpoints. note they can have an enclosing div, or not.
                _addOneDelegate(id, ".jtk-endpoint", function (e) {
                    _oneDelegateHandler(id, e, "endpoint");
                });
                // overlays
                _addOneDelegate(id, ".jtk-overlay", function (e) {
                    _oneDelegateHandler(id, e);
                });
            };

            for (var i = 0; i < events.length; i++)
                _oneDelegate(events[i]);

            // managed elements
            for (var elId in managedElements) {
                var el = managedElements[elId].el;
                if (el.parentNode === previousContainer) {
                    previousContainer.removeChild(el);
                    _container.appendChild(el);
                }
            }

        };
        this.getContainer = function () {
            return _container;
        };

        this.bind = function (event, fn) {
            if ("ready" === event && initialized) fn();
            else _bb.apply(_currentInstance, [event, fn]);
        };

        _currentInstance.importDefaults = function (d) {
            for (var i in d) {
                _currentInstance.Defaults[i] = d[i];
            }
            if (d.Container)
                _currentInstance.setContainer(d.Container);

            return _currentInstance;
        };

        _currentInstance.restoreDefaults = function () {
            _currentInstance.Defaults = jsPlumb.extend({}, _initialDefaults);
            return _currentInstance;
        };

        var log = null,
            initialized = false,
        // TODO remove from window scope
            connections = [],
        // map of element id -> endpoint lists. an element can have an arbitrary
        // number of endpoints on it, and not all of them have to be connected
        // to anything.
            endpointsByElement = {},
            endpointsByUUID = {},
            managedElements = {},
            offsets = {},
            offsetTimestamps = {},
            draggableStates = {},
            connectionBeingDragged = false,
            sizes = [],
            _suspendDrawing = false,
            _suspendedAt = null,
            DEFAULT_SCOPE = this.Defaults.Scope,
            _curIdStamp = 1,
            _idstamp = function () {
                return "" + _curIdStamp++;
            },

        //
        // appends an element to some other element, which is calculated as follows:
        //
        // 1. if Container exists, use that element.
        // 2. if the 'parent' parameter exists, use that.
        // 3. otherwise just use the root element.
        //
        //
            _appendElement = function (el, parent) {
                if (_container)
                    _container.appendChild(el);
                else if (!parent)
                    this.appendToRoot(el);
                else
                    this.getElement(parent).appendChild(el);
            }.bind(this),

        //
        // Draws an endpoint and its connections. this is the main entry point into drawing connections as well
        // as endpoints, since jsPlumb is endpoint-centric under the hood.
        //
        // @param element element to draw (of type library specific element object)
        // @param ui UI object from current library's event system. optional.
        // @param timestamp timestamp for this paint cycle. used to speed things up a little by cutting down the amount of offset calculations we do.
        // @param clearEdits defaults to false; indicates that mouse edits for connectors should be cleared
        ///
            _draw = function (element, ui, timestamp, clearEdits) {

                if (!_suspendDrawing) {
                    var id = _getId(element),
                        repaintEls,
                        dm = _currentInstance.getDragManager();

                    if (dm) repaintEls = dm.getElementsForDraggable(id);

                    if (timestamp == null) timestamp = _timestamp();

                    // update the offset of everything _before_ we try to draw anything.
                    var o = _updateOffset({ elId: id, offset: ui, recalc: false, timestamp: timestamp });

                    if (repaintEls && o && o.o) {
                        for (var i in repaintEls) {
                            _updateOffset({
                                elId: repaintEls[i].id,
                                offset: {
                                    left: o.o.left + repaintEls[i].offset.left,
                                    top: o.o.top + repaintEls[i].offset.top
                                },
                                recalc: false,
                                timestamp: timestamp
                            });
                        }
                    }

                    _currentInstance.anchorManager.redraw(id, ui, timestamp, null, clearEdits);

                    if (repaintEls) {
                        for (var j in repaintEls) {
                            _currentInstance.anchorManager.redraw(repaintEls[j].id, ui, timestamp, repaintEls[j].offset, clearEdits, true);
                        }
                    }
                }
            },

        //
        // gets an Endpoint by uuid.
        //
            _getEndpoint = function (uuid) {
                return endpointsByUUID[uuid];
            },

            /**
             * inits a draggable if it's not already initialised.
             * TODO: somehow abstract this to the adapter, because the concept of "draggable" has no
             * place on the server.
             */
            _initDraggableIfNecessary = function (element, isDraggable, dragOptions, id, fireEvent) {
                // move to DragManager?
                if (!jsPlumb.headless) {
                    var _draggable = isDraggable == null ? false : isDraggable;
                    if (_draggable) {
                        if (jsPlumb.isDragSupported(element, _currentInstance)) {
                            var options = dragOptions || _currentInstance.Defaults.DragOptions;
                            options = jsPlumb.extend({}, options); // make a copy.
                            if (!jsPlumb.isAlreadyDraggable(element, _currentInstance)) {
                                var dragEvent = jsPlumb.dragEvents.drag,
                                    stopEvent = jsPlumb.dragEvents.stop,
                                    startEvent = jsPlumb.dragEvents.start,
                                    _started = false;

                                _manage(id, element);

                                options[startEvent] = _ju.wrap(options[startEvent], function () {
                                    _currentInstance.setHoverSuspended(true);
                                    _currentInstance.select({source: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                    _currentInstance.select({target: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                    _currentInstance.setConnectionBeingDragged(true);
                                    if (options.canDrag) return dragOptions.canDrag();
                                }, false);

                                options[dragEvent] = _ju.wrap(options[dragEvent], function () {
                                    // TODO: here we could actually use getDragObject, and then compute it ourselves,
                                    // since every adapter does the same thing. but i'm not sure why YUI's getDragObject
                                    // differs from getUIPosition so much
                                    var ui = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom());
                                    if (ui != null) {
                                        _draw(element, ui, null, true);
                                        if (_started) _currentInstance.addClass(element, "jtk-dragged");
                                        _started = true;
                                    }
                                });
                                options[stopEvent] = _ju.wrap(options[stopEvent], function () {
                                    var elements = arguments[0].selection, uip;

                                    var _one = function (_e) {
                                        if (_e[1] != null) {
                                            // run the reported offset through the code that takes parent containers
                                            // into account, to adjust if necessary (issue 554)
                                            uip = _currentInstance.getUIPosition([{
                                                el:_e[2].el,
                                                pos:[_e[1].left, _e[1].top]
                                            }]);
                                            _draw(_e[2].el, uip);
                                        }
                                        _currentInstance.removeClass(_e[0], "jtk-dragged");
                                        _currentInstance.select({source: _e[2].el}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                        _currentInstance.select({target: _e[2].el}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                        _currentInstance.getDragManager().dragEnded(_e[2].el);
                                    };

                                    for (var i = 0; i < elements.length; i++) {
                                        _one(elements[i]);
                                    }

                                    _started = false;
                                    _currentInstance.setHoverSuspended(false);
                                    _currentInstance.setConnectionBeingDragged(false);
                                });
                                var elId = _getId(element); // need ID
                                draggableStates[elId] = true;
                                var draggable = draggableStates[elId];
                                options.disabled = draggable == null ? false : !draggable;
                                _currentInstance.initDraggable(element, options);
                                _currentInstance.getDragManager().register(element);
                                if (fireEvent) _currentInstance.fire("elementDraggable", {el:element, options:options});
                            }
                            else {
                                // already draggable. attach any start, drag or stop listeners to the current Drag.
                                if (dragOptions.force) {
                                    _currentInstance.initDraggable(element, options);
                                }
                            }
                        }
                    }
                }
            },

            _scopeMatch = function (e1, e2) {
                var s1 = e1.scope.split(/\s/), s2 = e2.scope.split(/\s/);
                for (var i = 0; i < s1.length; i++)
                    for (var j = 0; j < s2.length; j++)
                        if (s2[j] == s1[i]) return true;

                return false;
            },

        /*
         * prepares a final params object that can be passed to _newConnection, taking into account defaults, events, etc.
         */
            _prepareConnectionParams = function (params, referenceParams) {
                var _p = jsPlumb.extend({ }, params);
                if (referenceParams) jsPlumb.extend(_p, referenceParams);

                // hotwire endpoints passed as source or target to sourceEndpoint/targetEndpoint, respectively.
                if (_p.source) {
                    if (_p.source.endpoint)
                        _p.sourceEndpoint = _p.source;
                    else
                        _p.source = _currentInstance.getElement(_p.source);
                }
                if (_p.target) {
                    if (_p.target.endpoint)
                        _p.targetEndpoint = _p.target;
                    else
                        _p.target = _currentInstance.getElement(_p.target);
                }

                // test for endpoint uuids to connect
                if (params.uuids) {
                    _p.sourceEndpoint = _getEndpoint(params.uuids[0]);
                    _p.targetEndpoint = _getEndpoint(params.uuids[1]);
                }

                // now ensure that if we do have Endpoints already, they're not full.
                // source:
                if (_p.sourceEndpoint && _p.sourceEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; source endpoint is full");
                    return;
                }

                // target:
                if (_p.targetEndpoint && _p.targetEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; target endpoint is full");
                    return;
                }

                // if source endpoint mandates connection type and nothing specified in our params, use it.
                if (!_p.type && _p.sourceEndpoint)
                    _p.type = _p.sourceEndpoint.connectionType;

                // copy in any connectorOverlays that were specified on the source endpoint.
                // it doesnt copy target endpoint overlays.  i'm not sure if we want it to or not.
                if (_p.sourceEndpoint && _p.sourceEndpoint.connectorOverlays) {
                    _p.overlays = _p.overlays || [];
                    for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
                        _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
                    }
                }

                // scope
                if (_p.sourceEndpoint && _p.sourceEndpoint.scope) {
                    _p.scope = _p.sourceEndpoint.scope;
                }

                // pointer events
                if (!_p["pointer-events"] && _p.sourceEndpoint && _p.sourceEndpoint.connectorPointerEvents)
                    _p["pointer-events"] = _p.sourceEndpoint.connectorPointerEvents;

                var _mergeOverrides = function (def, values) {
                    var m = jsPlumb.extend({}, def);
                    for (var i in values) {
                        if (values[i]) m[i] = values[i];
                    }
                    return m;
                };

                var _addEndpoint = function (el, def, idx) {
                    return _currentInstance.addEndpoint(el, _mergeOverrides(def, {
                        anchor: _p.anchors ? _p.anchors[idx] : _p.anchor,
                        endpoint: _p.endpoints ? _p.endpoints[idx] : _p.endpoint,
                        paintStyle: _p.endpointStyles ? _p.endpointStyles[idx] : _p.endpointStyle,
                        hoverPaintStyle: _p.endpointHoverStyles ? _p.endpointHoverStyles[idx] : _p.endpointHoverStyle
                    }));
                };

                // check for makeSource/makeTarget specs.

                var _oneElementDef = function (type, idx, defs, matchType) {
                    if (_p[type] && !_p[type].endpoint && !_p[type + "Endpoint"] && !_p.newConnection) {
                        var tid = _getId(_p[type]), tep = defs[tid];

                        tep = tep ? tep[matchType] : null;

                        if (tep) {
                            // if not enabled, return.
                            if (!tep.enabled) return false;
                            var newEndpoint = tep.endpoint != null && tep.endpoint._jsPlumb ? tep.endpoint : _addEndpoint(_p[type], tep.def, idx);
                            if (newEndpoint.isFull()) return false;
                            _p[type + "Endpoint"] = newEndpoint;
                            if (!_p.scope && tep.def.scope) _p.scope = tep.def.scope; // provide scope if not already provided and endpoint def has one.
                            newEndpoint.setDeleteOnEmpty(true);
                            if (tep.uniqueEndpoint) {
                                if (!tep.endpoint) {
                                    tep.endpoint = newEndpoint;
                                    newEndpoint.setDeleteOnEmpty(false);
                                }
                                else
                                    newEndpoint.finalEndpoint = tep.endpoint;
                            }
                        }
                    }
                };

                if (_oneElementDef("source", 0, this.sourceEndpointDefinitions, _p.type || "default") === false) return;
                if (_oneElementDef("target", 1, this.targetEndpointDefinitions, _p.type || "default") === false) return;

                // last, ensure scopes match
                if (_p.sourceEndpoint && _p.targetEndpoint)
                    if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) _p = null;

                return _p;
            }.bind(_currentInstance),

            _newConnection = function (params) {
                var connectionFunc = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType();

                params._jsPlumb = _currentInstance;
                params.newConnection = _newConnection;
                params.newEndpoint = _newEndpoint;
                params.endpointsByUUID = endpointsByUUID;
                params.endpointsByElement = endpointsByElement;
                params.finaliseConnection = _finaliseConnection;
                params.id = "con_" + _idstamp();
                var con = new connectionFunc(params);

                // if the connection is draggable, then maybe we need to tell the target endpoint to init the
                // dragging code. it won't run again if it already configured to be draggable.
                if (con.isDetachable()) {
                    con.endpoints[0].initDraggable("_jsPlumbSource");
                    con.endpoints[1].initDraggable("_jsPlumbTarget");
                }

                return con;
            },

        //
        // adds the connection to the backing model, fires an event if necessary and then redraws
        //
            _finaliseConnection = _currentInstance.finaliseConnection = function (jpc, params, originalEvent, doInformAnchorManager) {
                params = params || {};
                // add to list of connections (by scope).
                if (!jpc.suspendedEndpoint)
                    connections.push(jpc);

                jpc.pending = null;

                // turn off isTemporarySource on the source endpoint (only viable on first draw)
                jpc.endpoints[0].isTemporarySource = false;

                // always inform the anchor manager
                // except that if jpc has a suspended endpoint it's not true to say the
                // connection is new; it has just (possibly) moved. the question is whether
                // to make that call here or in the anchor manager.  i think perhaps here.
                if (doInformAnchorManager !== false)
                    _currentInstance.anchorManager.newConnection(jpc);

                // force a paint
                _draw(jpc.source);

                // fire an event
                if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {

                    var eventArgs = {
                        connection: jpc,
                        source: jpc.source, target: jpc.target,
                        sourceId: jpc.sourceId, targetId: jpc.targetId,
                        sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                    };

                    _currentInstance.fire("connection", eventArgs, originalEvent);
                }
            },

        /*
         factory method to prepare a new endpoint.  this should always be used instead of creating Endpoints
         manually, since this method attaches event listeners and an id.
         */
            _newEndpoint = function (params, id) {
                var endpointFunc = _currentInstance.Defaults.EndpointType || jsPlumb.Endpoint;
                var _p = jsPlumb.extend({}, params);
                _p._jsPlumb = _currentInstance;
                _p.newConnection = _newConnection;
                _p.newEndpoint = _newEndpoint;
                _p.endpointsByUUID = endpointsByUUID;
                _p.endpointsByElement = endpointsByElement;
                _p.fireDetachEvent = fireDetachEvent;
                _p.elementId = id || _getId(_p.source);
                var ep = new endpointFunc(_p);
                ep.id = "ep_" + _idstamp();
                _manage(_p.elementId, _p.source);

                if (!jsPlumb.headless)
                    _currentInstance.getDragManager().endpointAdded(_p.source, id);

                return ep;
            },

        /*
         * performs the given function operation on all the connections found
         * for the given element id; this means we find all the endpoints for
         * the given element, and then for each endpoint find the connectors
         * connected to it. then we pass each connection in to the given
         * function.
         */
            _operation = function (elId, func, endpointFunc) {
                var endpoints = endpointsByElement[elId];
                if (endpoints && endpoints.length) {
                    for (var i = 0, ii = endpoints.length; i < ii; i++) {
                        for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
                            var retVal = func(endpoints[i].connections[j]);
                            // if the function passed in returns true, we exit.
                            // most functions return false.
                            if (retVal) return;
                        }
                        if (endpointFunc) endpointFunc(endpoints[i]);
                    }
                }
            },

            _setDraggable = function (element, draggable) {
                return jsPlumb.each(element, function (el) {
                    if (_currentInstance.isDragSupported(el)) {
                        draggableStates[_currentInstance.getAttribute(el, "id")] = draggable;
                        _currentInstance.setElementDraggable(el, draggable);
                    }
                });
            },
        /*
         * private method to do the business of hiding/showing.
         *
         * @param el
         *            either Id of the element in question or a library specific
         *            object for the element.
         * @param state
         *            String specifying a value for the css 'display' property
         *            ('block' or 'none').
         */
            _setVisible = function (el, state, alsoChangeEndpoints) {
                state = state === "block";
                var endpointFunc = null;
                if (alsoChangeEndpoints) {
                    endpointFunc = function (ep) {
                        ep.setVisible(state, true, true);
                    };
                }
                var info = _info(el);
                _operation(info.id, function (jpc) {
                    if (state && alsoChangeEndpoints) {
                        // this test is necessary because this functionality is new, and i wanted to maintain backwards compatibility.
                        // this block will only set a connection to be visible if the other endpoint in the connection is also visible.
                        var oidx = jpc.sourceId === info.id ? 1 : 0;
                        if (jpc.endpoints[oidx].isVisible()) jpc.setVisible(true);
                    }
                    else  // the default behaviour for show, and what always happens for hide, is to just set the visibility without getting clever.
                        jpc.setVisible(state);
                }, endpointFunc);
            },
        /*
         * toggles the draggable state of the given element(s).
         * el is either an id, or an element object, or a list of ids/element objects.
         */
            _toggleDraggable = function (el) {
                var state;
                jsPlumb.each(el, function (el) {
                    var elId = _currentInstance.getAttribute(el, "id");
                    state = draggableStates[elId] == null ? false : draggableStates[elId];
                    state = !state;
                    draggableStates[elId] = state;
                    _currentInstance.setDraggable(el, state);
                    return state;
                }.bind(this));
                return state;
            },
            /**
             * private method to do the business of toggling hiding/showing.
             */
            _toggleVisible = function (elId, changeEndpoints) {
                var endpointFunc = null;
                if (changeEndpoints) {
                    endpointFunc = function (ep) {
                        var state = ep.isVisible();
                        ep.setVisible(!state);
                    };
                }
                _operation(elId, function (jpc) {
                    var state = jpc.isVisible();
                    jpc.setVisible(!state);
                }, endpointFunc);
            },

        // TODO comparison performance
            _getCachedData = function (elId) {
                var o = offsets[elId];
                if (!o)
                    return _updateOffset({elId: elId});
                else
                    return {o: o, s: sizes[elId]};
            },

            /**
             * gets an id for the given element, creating and setting one if
             * necessary.  the id is of the form
             *
             *    jsPlumb_<instance index>_<index in instance>
             *
             * where "index in instance" is a monotonically increasing integer that starts at 0,
             * for each instance.  this method is used not only to assign ids to elements that do not
             * have them but also to connections and endpoints.
             */
            _getId = function (element, uuid, doNotCreateIfNotFound) {
                if (_ju.isString(element)) return element;
                if (element == null) return null;
                var id = _currentInstance.getAttribute(element, "id");
                if (!id || id === "undefined") {
                    // check if fixed uuid parameter is given
                    if (arguments.length == 2 && arguments[1] !== undefined)
                        id = uuid;
                    else if (arguments.length == 1 || (arguments.length == 3 && !arguments[2]))
                        id = "jsPlumb_" + _instanceIndex + "_" + _idstamp();

                    if (!doNotCreateIfNotFound) _currentInstance.setAttribute(element, "id", id);
                }
                return id;
            };

        this.setConnectionBeingDragged = function (v) {
            connectionBeingDragged = v;
        };
        this.isConnectionBeingDragged = function () {
            return connectionBeingDragged;
        };

        /**
         * Returns a map of all the elements this jsPlumbInstance is currently managing.
         * @returns {Object} Map of [id-> {el, endpoint[], connection, position}] information.
         */
        this.getManagedElements = function() {
            return managedElements;
        };

        this.connectorClass = "jtk-connector";
        this.connectorOutlineClass = "jtk-connector-outline";
        this.editableConnectorClass = "jtk-connector-editable";
        this.connectedClass = "jtk-connected";
        this.hoverClass = "jtk-hover";
        this.endpointClass = "jtk-endpoint";
        this.endpointConnectedClass = "jtk-endpoint-connected";
        this.endpointFullClass = "jtk-endpoint-full";
        this.endpointDropAllowedClass = "jtk-endpoint-drop-allowed";
        this.endpointDropForbiddenClass = "jtk-endpoint-drop-forbidden";
        this.overlayClass = "jtk-overlay";
        this.draggingClass = "jtk-dragging";
        this.elementDraggingClass = "jtk-element-dragging";
        this.sourceElementDraggingClass = "jtk-source-element-dragging";
        this.targetElementDraggingClass = "jtk-target-element-dragging";
        this.endpointAnchorClassPrefix = "jtk-endpoint-anchor";
        this.hoverSourceClass = "jtk-source-hover";
        this.hoverTargetClass = "jtk-target-hover";
        this.dragSelectClass = "jtk-drag-select";

        this.Anchors = {};
        this.Connectors = {  "svg": {} };
        this.Endpoints = { "svg": {} };
        this.Overlays = { "svg": {} } ;
        this.ConnectorRenderers = {};
        this.SVG = "svg";

// --------------------------- jsPlumbInstance public API ---------------------------------------------------------


        this.addEndpoint = function (el, params, referenceParams) {
            referenceParams = referenceParams || {};
            var p = jsPlumb.extend({}, referenceParams);
            jsPlumb.extend(p, params);
            p.endpoint = p.endpoint || _currentInstance.Defaults.Endpoint;
            p.paintStyle = p.paintStyle || _currentInstance.Defaults.EndpointStyle;

            var results = [],
                inputs = (_ju.isArray(el) || (el.length != null && !_ju.isString(el))) ? el : [ el ];

            for (var i = 0, j = inputs.length; i < j; i++) {
                p.source = _currentInstance.getElement(inputs[i]);
                _ensureContainer(p.source);

                var id = _getId(p.source), e = _newEndpoint(p, id);

                // SP new. here we have introduced a class-wide element manager, which is responsible
                // for getting object dimensions and width/height, and for updating these values only
                // when necessary (after a drag, or on a forced refresh call).
                var myOffset = _manage(id, p.source).info.o;
                _ju.addToList(endpointsByElement, id, e);

                if (!_suspendDrawing) {
                    e.paint({
                        anchorLoc: e.anchor.compute({ xy: [ myOffset.left, myOffset.top ], wh: sizes[id], element: e, timestamp: _suspendedAt }),
                        timestamp: _suspendedAt
                    });
                }

                results.push(e);
                //e._doNotDeleteOnDetach = true; // mark this as being added via addEndpoint.
            }

            return results.length == 1 ? results[0] : results;
        };

        this.addEndpoints = function (el, endpoints, referenceParams) {
            var results = [];
            for (var i = 0, j = endpoints.length; i < j; i++) {
                var e = _currentInstance.addEndpoint(el, endpoints[i], referenceParams);
                if (_ju.isArray(e))
                    Array.prototype.push.apply(results, e);
                else results.push(e);
            }
            return results;
        };

        this.animate = function (el, properties, options) {
            if (!this.animationSupported) return false;

            options = options || {};
            var del = _currentInstance.getElement(el),
                id = _getId(del),
                stepFunction = jsPlumb.animEvents.step,
                completeFunction = jsPlumb.animEvents.complete;

            options[stepFunction] = _ju.wrap(options[stepFunction], function () {
                _currentInstance.revalidate(id);
            });

            // onComplete repaints, just to make sure everything looks good at the end of the animation.
            options[completeFunction] = _ju.wrap(options[completeFunction], function () {
                _currentInstance.revalidate(id);
            });

            _currentInstance.doAnimate(del, properties, options);
        };

        /**
         * checks for a listener for the given condition, executing it if found, passing in the given value.
         * condition listeners would have been attached using "bind" (which is, you could argue, now overloaded, since
         * firing click events etc is a bit different to what this does).  i thought about adding a "bindCondition"
         * or something, but decided against it, for the sake of simplicity. jsPlumb will never fire one of these
         * condition events anyway.
         */
        this.checkCondition = function (conditionName, args) {
            var l = _currentInstance.getListener(conditionName),
                r = true;

            if (l && l.length > 0) {
                var values = Array.prototype.slice.call(arguments, 1);
                try {
                    for (var i = 0, j = l.length; i < j; i++) {
                        r = r && l[i].apply(l[i], values);
                    }
                }
                catch (e) {
                    _ju.log(_currentInstance, "cannot check condition [" + conditionName + "]" + e);
                }
            }
            return r;
        };

        this.connect = function (params, referenceParams) {
            // prepare a final set of parameters to create connection with
            var _p = _prepareConnectionParams(params, referenceParams), jpc;
            // TODO probably a nicer return value if the connection was not made.  _prepareConnectionParams
            // will return null (and log something) if either endpoint was full.  what would be nicer is to
            // create a dedicated 'error' object.
            if (_p) {
                if (_p.source == null && _p.sourceEndpoint == null) {
                    _ju.log("Cannot establish connection - source does not exist");
                    return;
                }
                if (_p.target == null && _p.targetEndpoint == null) {
                    _ju.log("Cannot establish connection - target does not exist");
                    return;
                }
                _ensureContainer(_p.source);
                // create the connection.  it is not yet registered
                jpc = _newConnection(_p);
                // now add it the model, fire an event, and redraw
                _finaliseConnection(jpc, _p);
            }
            return jpc;
        };

        var stTypes = [
            { el: "source", elId: "sourceId", epDefs: "sourceEndpointDefinitions" },
            { el: "target", elId: "targetId", epDefs: "targetEndpointDefinitions" }
        ];

        var _set = function (c, el, idx, doNotRepaint) {
            var ep, _st = stTypes[idx], cId = c[_st.elId], cEl = c[_st.el], sid, sep,
                oldEndpoint = c.endpoints[idx];

            var evtParams = {
                index: idx,
                originalSourceId: idx === 0 ? cId : c.sourceId,
                newSourceId: c.sourceId,
                originalTargetId: idx == 1 ? cId : c.targetId,
                newTargetId: c.targetId,
                connection: c
            };

            if (el.constructor == jsPlumb.Endpoint) { // TODO here match the current endpoint class; users can change it {
                ep = el;
                ep.addConnection(c);
                el = ep.element;
            }
            else {
                sid = _getId(el);
                sep = this[_st.epDefs][sid];

                if (sid === c[_st.elId])
                    ep = null;  // dont change source/target if the element is already the one given.
                else if (sep) {
                    for (var t in sep) {
                        if (!sep[t].enabled) return;
                        ep = sep[t].endpoint != null && sep[t].endpoint._jsPlumb ? sep[t].endpoint : this.addEndpoint(el, sep[t].def);
                        if (sep[t].uniqueEndpoint) sep[t].endpoint = ep;
//                        ep._doNotDeleteOnDetach = false;
//                        ep._deleteOnDetach = true;
                        ep.addConnection(c);
                    }
                }
                else {
                    ep = c.makeEndpoint(idx === 0, el, sid);
//                    ep._doNotDeleteOnDetach = false;
//                    ep._deleteOnDetach = true;
                }
            }

            if (ep != null) {
                oldEndpoint.detachFromConnection(c);
                c.endpoints[idx] = ep;
                c[_st.el] = ep.element;
                c[_st.elId] = ep.elementId;
                evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;

                fireMoveEvent(evtParams);

                if (!doNotRepaint)
                    c.repaint();
            }

            evtParams.element = el;
            return evtParams;

        }.bind(this);

        this.setSource = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 0, doNotRepaint);
            this.anchorManager.sourceChanged(p.originalSourceId, p.newSourceId, connection, p.el);
        };
        this.setTarget = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 1, doNotRepaint);
            this.anchorManager.updateOtherEndpoint(p.originalSourceId, p.originalTargetId, p.newTargetId, connection);
        };

        this.deleteEndpoint = function (object, dontUpdateHover, deleteAttachedObjects) {
            var endpoint = (typeof object === "string") ? endpointsByUUID[object] : object;
            if (endpoint) {
                _currentInstance.deleteObject({ endpoint: endpoint, dontUpdateHover: dontUpdateHover, deleteAttachedObjects:deleteAttachedObjects });
            }
            return _currentInstance;
        };

        this.deleteEveryEndpoint = function () {
            var _is = _currentInstance.setSuspendDrawing(true);
            for (var id in endpointsByElement) {
                var endpoints = endpointsByElement[id];
                if (endpoints && endpoints.length) {
                    for (var i = 0, j = endpoints.length; i < j; i++) {
                        _currentInstance.deleteEndpoint(endpoints[i], true);
                    }
                }
            }
            endpointsByElement = {};
            // SP new
            managedElements = {};
            endpointsByUUID = {};
            offsets = {};
            offsetTimestamps = {};
            _currentInstance.anchorManager.reset();
            _currentInstance.getDragManager().reset();
            if (!_is) _currentInstance.setSuspendDrawing(false);
            return _currentInstance;
        };

        var fireDetachEvent = function (jpc, doFireEvent, originalEvent) {
            // may have been given a connection, or in special cases, an object
            var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                argIsConnection = jpc.constructor == connType,
                params = argIsConnection ? {
                    connection: jpc,
                    source: jpc.source, target: jpc.target,
                    sourceId: jpc.sourceId, targetId: jpc.targetId,
                    sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                } : jpc;

            if (doFireEvent) {
                _currentInstance.fire("connectionDetached", params, originalEvent);
            }

            // always fire this. used by internal jsplumb stuff.
            _currentInstance.fire("internal.connectionDetached", params, originalEvent);

            _currentInstance.anchorManager.connectionDetached(params);
        };

        var fireMoveEvent = _currentInstance.fireMoveEvent = function (params, evt) {
            _currentInstance.fire("connectionMoved", params, evt);
        };

        this.unregisterEndpoint = function (endpoint) {
            //if (endpoint._jsPlumb == null) return;
            if (endpoint._jsPlumb.uuid) endpointsByUUID[endpoint._jsPlumb.uuid] = null;
            _currentInstance.anchorManager.deleteEndpoint(endpoint);
            // TODO at least replace this with a removeWithFunction call.
            for (var e in endpointsByElement) {
                var endpoints = endpointsByElement[e];
                if (endpoints) {
                    var newEndpoints = [];
                    for (var i = 0, j = endpoints.length; i < j; i++)
                        if (endpoints[i] != endpoint) newEndpoints.push(endpoints[i]);

                    endpointsByElement[e] = newEndpoints;
                }
                if (endpointsByElement[e].length < 1) {
                    delete endpointsByElement[e];
                }
            }
        };

        var IS_DETACH_ALLOWED = "isDetachAllowed";
        var BEFORE_DETACH = "beforeDetach";
        var CHECK_CONDITION = "checkCondition";

        /**
         * Deletes a Connection.
         * @method deleteConnection
         * @param connection Connection to delete
         * @param {Object} [params] Optional delete parameters
         * @param {Boolean} [params.doNotFireEvent=false] If true, a connection detached event will not be fired. Otherwise one will.
         * @param {Boolean} [params.force=false] If true, the connection will be deleted even if a beforeDetach interceptor tries to stop the deletion.
         * @returns {Boolean} True if the connection was deleted, false otherwise.
         */
        this.deleteConnection = function(connection, params) {

            if (connection != null) {
                params = params || {};

                if (params.force || _ju.functionChain(true, false, [
                    [ connection.endpoints[0], IS_DETACH_ALLOWED, [ connection ] ],
                    [ connection.endpoints[1], IS_DETACH_ALLOWED, [ connection ] ],
                    [ connection, IS_DETACH_ALLOWED, [ connection ] ],
                    [ _currentInstance, CHECK_CONDITION, [ BEFORE_DETACH, connection ] ]
                ])) {

                    fireDetachEvent(connection, !connection.pending && params.fireEvent !== false, params.originalEvent);

                    connection.endpoints[0].detachFromConnection(connection);
                    connection.endpoints[1].detachFromConnection(connection);
                    _ju.removeWithFunction(connections, function (_c) {
                        return connection.id == _c.id;
                    });

                    connection.cleanup();
                    connection.destroy();
                    return true;
                }
            }
            return false;
        };

        /**
         * Remove all Connections from all elements, but leaves Endpoints in place ((unless a connection is set to auto delete its Endpoints).
         * @method deleteEveryConnection
         * @param {Object} [params] optional params object for the call
         * @param {Boolean} [params.fireEvent=true] Whether or not to fire detach events
         * @param {Boolean} [params.forceDetach=false] If true, this call will ignore any `beforeDetach` interceptors.
         * @returns {Number} The number of connections that were deleted.
         */
        this.deleteEveryConnection = function (params) {
            params = params || {};
            var count = connections.length, deletedCount = 0;
            _currentInstance.batch(function () {
                for (var i = 0; i < count; i++) {
                    deletedCount += _currentInstance.deleteConnection(connections[0], params) ? 1 : 0;
                }
            });
            return deletedCount;
        };

        /**
         * Removes all an element's Connections.
         * @method deleteConnectionsForElement
         * @param {Object} el Either the id of the element, or a selector for the element.
         * @param {Object} [params] Optional parameters.
         * @param {Boolean} [params.fireEvent=true] Whether or not to fire the detach event.
         * @param {Boolean} [params.forceDetach=false] If true, this call will ignore any `beforeDetach` interceptors.
         * @return {jsPlumbInstance} The current jsPlumb instance.
         */
        this.deleteConnectionsForElement = function (el, params) {
            params = params || {};
            el = _currentInstance.getElement(el);
            var id = _getId(el), endpoints = endpointsByElement[id];
            if (endpoints && endpoints.length) {
                for (var i = 0, j = endpoints.length; i < j; i++) {
                    endpoints[i].deleteEveryConnection(params);
                }
            }
            return _currentInstance;
        };

        /// not public.  but of course its exposed. how to change this.
        this.deleteObject = function (params) {
            var result = {
                    endpoints: {},
                    connections: {},
                    endpointCount: 0,
                    connectionCount: 0
                },
                fireEvent = params.fireEvent !== false,
                deleteAttachedObjects = params.deleteAttachedObjects !== false;

            var unravelConnection = function (connection) {
                if (connection != null && result.connections[connection.id] == null) {
                    if (!params.dontUpdateHover && connection._jsPlumb != null) connection.setHover(false);
                    result.connections[connection.id] = connection;
                    result.connectionCount++;
                    if (deleteAttachedObjects) {
                        for (var j = 0; j < connection.endpoints.length; j++) {
//                            if (connection.endpoints[j]._deleteOnDetach)
//                                unravelEndpoint(connection.endpoints[j]);
                        }
                    }
                }
            };
            var unravelEndpoint = function (endpoint) {
                if (endpoint != null && result.endpoints[endpoint.id] == null) {
                    if (!params.dontUpdateHover && endpoint._jsPlumb != null) endpoint.setHover(false);
                    result.endpoints[endpoint.id] = endpoint;
                    result.endpointCount++;

                    if (deleteAttachedObjects) {
                        for (var i = 0; i < endpoint.connections.length; i++) {
                            var c = endpoint.connections[i];
                            unravelConnection(c);
                        }
                    }
                }
            };

            if (params.connection)
                unravelConnection(params.connection);
            else unravelEndpoint(params.endpoint);

            // loop through connections
            for (var i in result.connections) {
                var c = result.connections[i];
                if (c._jsPlumb) {
                    _ju.removeWithFunction(connections, function (_c) {
                        return c.id == _c.id;
                    });

                    fireDetachEvent(c, params.fireEvent === false ? false : !c.pending, params.originalEvent);
                    var doNotCleanup = params.deleteAttachedObjects == null ? null : !params.deleteAttachedObjects;

                    c.endpoints[0].detachFromConnection(c, null, doNotCleanup);
                    c.endpoints[1].detachFromConnection(c, null, doNotCleanup);

                    c.cleanup(true);
                    c.destroy(true);
                }
            }

            // loop through endpoints
            for (var j in result.endpoints) {
                var e = result.endpoints[j];
                if (e._jsPlumb) {
                    _currentInstance.unregisterEndpoint(e);
                    // FIRE some endpoint deleted event?
                    e.cleanup(true);
                    e.destroy(true);
                }
            }

            return result;
        };

        this.draggable = function (el, options) {
            var info;
            _each(function(_el) {
                 info = _info(_el);
                if (info.el) _initDraggableIfNecessary(info.el, true, options, info.id, true);
            }, el);
            return _currentInstance;
        };

        this.droppable = function(el, options) {
            var info;
            options = options || {};
            options.allowLoopback = false;
            _each(function(_el) {
                info = _info(_el);
                if (info.el) _currentInstance.initDroppable(info.el, options);
            }, el);
            return _currentInstance;
        };

        // helpers for select/selectEndpoints
        var _setOperation = function (list, func, args, selector) {
                for (var i = 0, j = list.length; i < j; i++) {
                    list[i][func].apply(list[i], args);
                }
                return selector(list);
            },
            _getOperation = function (list, func, args) {
                var out = [];
                for (var i = 0, j = list.length; i < j; i++) {
                    out.push([ list[i][func].apply(list[i], args), list[i] ]);
                }
                return out;
            },
            setter = function (list, func, selector) {
                return function () {
                    return _setOperation(list, func, arguments, selector);
                };
            },
            getter = function (list, func) {
                return function () {
                    return _getOperation(list, func, arguments);
                };
            },
            prepareList = function (input, doNotGetIds) {
                var r = [];
                if (input) {
                    if (typeof input == 'string') {
                        if (input === "*") return input;
                        r.push(input);
                    }
                    else {
                        if (doNotGetIds) r = input;
                        else {
                            if (input.length) {
                                for (var i = 0, j = input.length; i < j; i++)
                                    r.push(_info(input[i]).id);
                            }
                            else
                                r.push(_info(input).id);
                        }
                    }
                }
                return r;
            },
            filterList = function (list, value, missingIsFalse) {
                if (list === "*") return true;
                return list.length > 0 ? list.indexOf(value) != -1 : !missingIsFalse;
            };

        // get some connections, specifying source/target/scope
        this.getConnections = function (options, flat) {
            if (!options) {
                options = {};
            } else if (options.constructor == String) {
                options = { "scope": options };
            }
            var scope = options.scope || _currentInstance.getDefaultScope(),
                scopes = prepareList(scope, true),
                sources = prepareList(options.source),
                targets = prepareList(options.target),
                results = (!flat && scopes.length > 1) ? {} : [],
                _addOne = function (scope, obj) {
                    if (!flat && scopes.length > 1) {
                        var ss = results[scope];
                        if (ss == null) {
                            ss = results[scope] = [];
                        }
                        ss.push(obj);
                    } else results.push(obj);
                };

            for (var j = 0, jj = connections.length; j < jj; j++) {
                var c = connections[j],
                    sourceId = c.proxies && c.proxies[0] ? c.proxies[0].originalEp.elementId : c.sourceId,
                    targetId = c.proxies && c.proxies[1] ? c.proxies[1].originalEp.elementId : c.targetId;

                if (filterList(scopes, c.scope) && filterList(sources, sourceId) && filterList(targets, targetId))
                    _addOne(c.scope, c);
            }

            return results;
        };

        var _curryEach = function (list, executor) {
                return function (f) {
                    for (var i = 0, ii = list.length; i < ii; i++) {
                        f(list[i]);
                    }
                    return executor(list);
                };
            },
            _curryGet = function (list) {
                return function (idx) {
                    return list[idx];
                };
            };

        var _makeCommonSelectHandler = function (list, executor) {
            var out = {
                    length: list.length,
                    each: _curryEach(list, executor),
                    get: _curryGet(list)
                },
                setters = ["setHover", "removeAllOverlays", "setLabel", "addClass", "addOverlay", "removeOverlay",
                    "removeOverlays", "showOverlay", "hideOverlay", "showOverlays", "hideOverlays", "setPaintStyle",
                    "setHoverPaintStyle", "setSuspendEvents", "setParameter", "setParameters", "setVisible",
                    "repaint", "addType", "toggleType", "removeType", "removeClass", "setType", "bind", "unbind" ],

                getters = ["getLabel", "getOverlay", "isHover", "getParameter", "getParameters", "getPaintStyle",
                    "getHoverPaintStyle", "isVisible", "hasType", "getType", "isSuspendEvents" ],
                i, ii;

            for (i = 0, ii = setters.length; i < ii; i++)
                out[setters[i]] = setter(list, setters[i], executor);

            for (i = 0, ii = getters.length; i < ii; i++)
                out[getters[i]] = getter(list, getters[i]);

            return out;
        };

        var _makeConnectionSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeConnectionSelectHandler);
            return jsPlumb.extend(common, {
                // setters
                setDetachable: setter(list, "setDetachable", _makeConnectionSelectHandler),
                setReattach: setter(list, "setReattach", _makeConnectionSelectHandler),
                setConnector: setter(list, "setConnector", _makeConnectionSelectHandler),
                delete: function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        _currentInstance.deleteConnection(list[i]);
                },
                // getters
                isDetachable: getter(list, "isDetachable"),
                isReattach: getter(list, "isReattach")
            });
        };

        var _makeEndpointSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeEndpointSelectHandler);
            return jsPlumb.extend(common, {
                setEnabled: setter(list, "setEnabled", _makeEndpointSelectHandler),
                setAnchor: setter(list, "setAnchor", _makeEndpointSelectHandler),
                isEnabled: getter(list, "isEnabled"),
                deleteEveryConnection: function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        list[i].deleteEveryConnection();
                },
                "delete": function () {
                    for (var i = 0, ii = list.length; i < ii; i++)
                        _currentInstance.deleteEndpoint(list[i]);
                }
            });
        };

        this.select = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            return _makeConnectionSelectHandler(params.connections || _currentInstance.getConnections(params, true));
        };

        this.selectEndpoints = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            var noElementFilters = !params.element && !params.source && !params.target,
                elements = noElementFilters ? "*" : prepareList(params.element),
                sources = noElementFilters ? "*" : prepareList(params.source),
                targets = noElementFilters ? "*" : prepareList(params.target),
                scopes = prepareList(params.scope, true);

            var ep = [];

            for (var el in endpointsByElement) {
                var either = filterList(elements, el, true),
                    source = filterList(sources, el, true),
                    sourceMatchExact = sources != "*",
                    target = filterList(targets, el, true),
                    targetMatchExact = targets != "*";

                // if they requested 'either' then just match scope. otherwise if they requested 'source' (not as a wildcard) then we have to match only endpoints that have isSource set to to true, and the same thing with isTarget.
                if (either || source || target) {
                    inner:
                        for (var i = 0, ii = endpointsByElement[el].length; i < ii; i++) {
                            var _ep = endpointsByElement[el][i];
                            if (filterList(scopes, _ep.scope, true)) {

                                var noMatchSource = (sourceMatchExact && sources.length > 0 && !_ep.isSource),
                                    noMatchTarget = (targetMatchExact && targets.length > 0 && !_ep.isTarget);

                                if (noMatchSource || noMatchTarget)
                                    continue inner;

                                ep.push(_ep);
                            }
                        }
                }
            }

            return _makeEndpointSelectHandler(ep);
        };

        // get all connections managed by the instance of jsplumb.
        this.getAllConnections = function () {
            return connections;
        };
        this.getDefaultScope = function () {
            return DEFAULT_SCOPE;
        };
        // get an endpoint by uuid.
        this.getEndpoint = _getEndpoint;
        /**
         * Gets the list of Endpoints for a given element.
         * @method getEndpoints
         * @param {String|Element|Selector} el The element to get endpoints for.
         * @return {Endpoint[]} An array of Endpoints for the specified element.
         */
        this.getEndpoints = function (el) {
            return endpointsByElement[_info(el).id] || [];
        };
        // gets the default endpoint type. used when subclassing. see wiki.
        this.getDefaultEndpointType = function () {
            return jsPlumb.Endpoint;
        };
        // gets the default connection type. used when subclassing.  see wiki.
        this.getDefaultConnectionType = function () {
            return jsPlumb.Connection;
        };
        /*
         * Gets an element's id, creating one if necessary. really only exposed
         * for the lib-specific functionality to access; would be better to pass
         * the current instance into the lib-specific code (even though this is
         * a static call. i just don't want to expose it to the public API).
         */
        this.getId = _getId;

        this.appendElement = _appendElement;

        var _hoverSuspended = false;
        this.isHoverSuspended = function () {
            return _hoverSuspended;
        };
        this.setHoverSuspended = function (s) {
            _hoverSuspended = s;
        };

        // set an element's connections to be hidden
        this.hide = function (el, changeEndpoints) {
            _setVisible(el, "none", changeEndpoints);
            return _currentInstance;
        };

        // exposed for other objects to use to get a unique id.
        this.idstamp = _idstamp;

        this.connectorsInitialized = false;
        this.registerConnectorType = function (connector, name) {
            connectorTypes.push([connector, name]);
        };

        // ensure that, if the current container exists, it is a DOM element and not a selector.
        // if it does not exist and `candidate` is supplied, the offset parent of that element will be set as the Container.
        // this is used to do a better default behaviour for the case that the user has not set a container:
        // addEndpoint, makeSource, makeTarget and connect all call this method with the offsetParent of the
        // element in question (for connect it is the source element). So if no container is set, it is inferred
        // to be the offsetParent of the first element the user tries to connect.
        var _ensureContainer = function (candidate) {
            if (!_container && candidate) {
                var can = _currentInstance.getElement(candidate);
                if (can.offsetParent) _currentInstance.setContainer(can.offsetParent);
            }
        };

        var _getContainerFromDefaults = function () {
            if (_currentInstance.Defaults.Container)
                _currentInstance.setContainer(_currentInstance.Defaults.Container);
        };

        // check if a given element is managed or not. if not, add to our map. if drawing is not suspended then
        // we'll also stash its dimensions; otherwise we'll do this in a lazy way through updateOffset.
        var _manage = _currentInstance.manage = function (id, element, _transient) {
            if (!managedElements[id]) {
                managedElements[id] = {
                    el: element,
                    endpoints: [],
                    connections: []
                };

                managedElements[id].info = _updateOffset({ elId: id, timestamp: _suspendedAt });
                if (!_transient) {
                    _currentInstance.fire("manageElement", { id:id, info:managedElements[id].info, el:element });
                }
            }

            return managedElements[id];
        };

        var _unmanage = function(id) {
            if (managedElements[id]) {
                delete managedElements[id];
                _currentInstance.fire("unmanageElement", id);
            }
        };

        /**
         * updates the offset and size for a given element, and stores the
         * values. if 'offset' is not null we use that (it would have been
         * passed in from a drag call) because it's faster; but if it is null,
         * or if 'recalc' is true in order to force a recalculation, we get the current values.
         */
        var _updateOffset = this.updateOffset = function (params) {

            var timestamp = params.timestamp, recalc = params.recalc, offset = params.offset, elId = params.elId, s;
            if (_suspendDrawing && !timestamp) timestamp = _suspendedAt;
            if (!recalc) {
                if (timestamp && timestamp === offsetTimestamps[elId]) {
                    return {o: params.offset || offsets[elId], s: sizes[elId]};
                }
            }
            if (recalc || (!offset && offsets[elId] == null)) { // if forced repaint or no offset available, we recalculate.

                // get the current size and offset, and store them
                s = managedElements[elId] ? managedElements[elId].el : null;
                if (s != null) {
                    sizes[elId] = _currentInstance.getSize(s);
                    offsets[elId] = _currentInstance.getOffset(s);
                    offsetTimestamps[elId] = timestamp;
                }
            } else {
                offsets[elId] = offset || offsets[elId];
                if (sizes[elId] == null) {
                    s = managedElements[elId].el;
                    if (s != null) sizes[elId] = _currentInstance.getSize(s);
                }
                offsetTimestamps[elId] = timestamp;
            }

            if (offsets[elId] && !offsets[elId].right) {
                offsets[elId].right = offsets[elId].left + sizes[elId][0];
                offsets[elId].bottom = offsets[elId].top + sizes[elId][1];
                offsets[elId].width = sizes[elId][0];
                offsets[elId].height = sizes[elId][1];
                offsets[elId].centerx = offsets[elId].left + (offsets[elId].width / 2);
                offsets[elId].centery = offsets[elId].top + (offsets[elId].height / 2);
            }

            return {o: offsets[elId], s: sizes[elId]};
        };

        /**
         * callback from the current library to tell us to prepare ourselves (attach
         * mouse listeners etc; can't do that until the library has provided a bind method)
         */
        this.init = function () {
            rendererTypes = root.jsPlumb.getRenderModes();

            var _oneType = function (renderer, name, fn) {
                root.jsPlumb.Connectors[renderer][name] = function () {
                    fn.apply(this, arguments);
                    root.jsPlumb.ConnectorRenderers[renderer].apply(this, arguments);
                };
                _ju.extend(root.jsPlumb.Connectors[renderer][name], [ fn, root.jsPlumb.ConnectorRenderers[renderer]]);
            };

            if (!root.jsPlumb.connectorsInitialized) {
                for (var i = 0; i < connectorTypes.length; i++) {
                    for (var j = 0; j < rendererTypes.length; j++) {
                        _oneType(rendererTypes[j], connectorTypes[i][1], connectorTypes[i][0]);
                    }

                }
                root.jsPlumb.connectorsInitialized = true;
            }

            if (!initialized) {
                _getContainerFromDefaults();
                _currentInstance.anchorManager = new root.jsPlumb.AnchorManager({jsPlumbInstance: _currentInstance});
                initialized = true;
                _currentInstance.fire("ready", _currentInstance);
            }
        }.bind(this);

        this.log = log;
        this.jsPlumbUIComponent = jsPlumbUIComponent;

        /*
         * Creates an anchor with the given params.
         *
         *
         * Returns: The newly created Anchor.
         * Throws: an error if a named anchor was not found.
         */
        this.makeAnchor = function () {
            var pp, _a = function (t, p) {
                if (root.jsPlumb.Anchors[t]) return new root.jsPlumb.Anchors[t](p);
                if (!_currentInstance.Defaults.DoNotThrowErrors)
                    throw { msg: "jsPlumb: unknown anchor type '" + t + "'" };
            };
            if (arguments.length === 0) return null;
            var specimen = arguments[0], elementId = arguments[1], jsPlumbInstance = arguments[2], newAnchor = null;
            // if it appears to be an anchor already...
            if (specimen.compute && specimen.getOrientation) return specimen;  //TODO hazy here about whether it should be added or is already added somehow.
            // is it the name of an anchor type?
            else if (typeof specimen == "string") {
                newAnchor = _a(arguments[0], {elementId: elementId, jsPlumbInstance: _currentInstance});
            }
            // is it an array? it will be one of:
            // 		an array of [spec, params] - this defines a single anchor, which may be dynamic, but has parameters.
            //		an array of arrays - this defines some dynamic anchors
            //		an array of numbers - this defines a single anchor.
            else if (_ju.isArray(specimen)) {
                if (_ju.isArray(specimen[0]) || _ju.isString(specimen[0])) {
                    // if [spec, params] format
                    if (specimen.length == 2 && _ju.isObject(specimen[1])) {
                        // if first arg is a string, its a named anchor with params
                        if (_ju.isString(specimen[0])) {
                            pp = root.jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance}, specimen[1]);
                            newAnchor = _a(specimen[0], pp);
                        }
                        // otherwise first arg is array, second is params. we treat as a dynamic anchor, which is fine
                        // even if the first arg has only one entry. you could argue all anchors should be implicitly dynamic in fact.
                        else {
                            pp = root.jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance, anchors: specimen[0]}, specimen[1]);
                            newAnchor = new root.jsPlumb.DynamicAnchor(pp);
                        }
                    }
                    else
                        newAnchor = new jsPlumb.DynamicAnchor({anchors: specimen, selector: null, elementId: elementId, jsPlumbInstance: _currentInstance});

                }
                else {
                    var anchorParams = {
                        x: specimen[0], y: specimen[1],
                        orientation: (specimen.length >= 4) ? [ specimen[2], specimen[3] ] : [0, 0],
                        offsets: (specimen.length >= 6) ? [ specimen[4], specimen[5] ] : [ 0, 0 ],
                        elementId: elementId,
                        jsPlumbInstance: _currentInstance,
                        cssClass: specimen.length == 7 ? specimen[6] : null
                    };
                    newAnchor = new root.jsPlumb.Anchor(anchorParams);
                    newAnchor.clone = function () {
                        return new root.jsPlumb.Anchor(anchorParams);
                    };
                }
            }

            if (!newAnchor.id) newAnchor.id = "anchor_" + _idstamp();
            return newAnchor;
        };

        /**
         * makes a list of anchors from the given list of types or coords, eg
         * ["TopCenter", "RightMiddle", "BottomCenter", [0, 1, -1, -1] ]
         */
        this.makeAnchors = function (types, elementId, jsPlumbInstance) {
            var r = [];
            for (var i = 0, ii = types.length; i < ii; i++) {
                if (typeof types[i] == "string")
                    r.push(root.jsPlumb.Anchors[types[i]]({elementId: elementId, jsPlumbInstance: jsPlumbInstance}));
                else if (_ju.isArray(types[i]))
                    r.push(_currentInstance.makeAnchor(types[i], elementId, jsPlumbInstance));
            }
            return r;
        };

        /**
         * Makes a dynamic anchor from the given list of anchors (which may be in shorthand notation as strings or dimension arrays, or Anchor
         * objects themselves) and the given, optional, anchorSelector function (jsPlumb uses a default if this is not provided; most people will
         * not need to provide this - i think).
         */
        this.makeDynamicAnchor = function (anchors, anchorSelector) {
            return new root.jsPlumb.DynamicAnchor({anchors: anchors, selector: anchorSelector, elementId: null, jsPlumbInstance: _currentInstance});
        };

// --------------------- makeSource/makeTarget ---------------------------------------------- 

        this.targetEndpointDefinitions = {};
        this.sourceEndpointDefinitions = {};

        var selectorFilter = function (evt, _el, selector, _instance, negate) {
            var t = evt.target || evt.srcElement, ok = false,
                sel = _instance.getSelector(_el, selector);
            for (var j = 0; j < sel.length; j++) {
                if (sel[j] == t) {
                    ok = true;
                    break;
                }
            }
            return negate ? !ok : ok;
        };

        var _makeElementDropHandler = function (elInfo, p, dropOptions, isSource, isTarget) {
            var proxyComponent = new jsPlumbUIComponent(p);
            var _drop = p._jsPlumb.EndpointDropHandler({
                jsPlumb: _currentInstance,
                enabled: function () {
                    return elInfo.def.enabled;
                },
                isFull: function () {
                    var targetCount = _currentInstance.select({target: elInfo.id}).length;
                    return elInfo.def.maxConnections > 0 && targetCount >= elInfo.def.maxConnections;
                },
                element: elInfo.el,
                elementId: elInfo.id,
                isSource: isSource,
                isTarget: isTarget,
                addClass: function (clazz) {
                    _currentInstance.addClass(elInfo.el, clazz);
                },
                removeClass: function (clazz) {
                    _currentInstance.removeClass(elInfo.el, clazz);
                },
                onDrop: function (jpc) {
                    var source = jpc.endpoints[0];
                    source.anchor.locked = false;
                },
                isDropAllowed: function () {
                    return proxyComponent.isDropAllowed.apply(proxyComponent, arguments);
                },
                isRedrop:function(jpc) {
                    return (jpc.suspendedElement != null && jpc.suspendedEndpoint != null && jpc.suspendedEndpoint.element === elInfo.el);
                },
                getEndpoint: function (jpc) {

                    // make a new Endpoint for the target, or get it from the cache if uniqueEndpoint
                    // is set. if its a redrop the new endpoint will be immediately cleaned up.

                    var newEndpoint = elInfo.def.endpoint;

                    // if no cached endpoint, or there was one but it has been cleaned up
                    // (ie. detached), create a new one
                    if (newEndpoint == null || newEndpoint._jsPlumb == null) {
                        var eps = _currentInstance.deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
                        var pp = eps.endpoints ? root.jsPlumb.extend(p, {
                            endpoint:elInfo.def.def.endpoint || eps.endpoints[1]
                        }) :p;
                        if (eps.anchors) {
                            pp = root.jsPlumb.extend(pp, {
                                anchor:elInfo.def.def.anchor || eps.anchors[1]
                            });
                        }
                        newEndpoint = _currentInstance.addEndpoint(elInfo.el, pp);
                        newEndpoint._mtNew = true;
                    }

                    if (p.uniqueEndpoint) {
                        elInfo.def.endpoint = newEndpoint;
                    }

                    newEndpoint.setDeleteOnEmpty(true);

                    // if connection is detachable, init the new endpoint to be draggable, to support that happening.
                    if (jpc.isDetachable())
                        newEndpoint.initDraggable();

                    // if the anchor has a 'positionFinder' set, then delegate to that function to find
                    // out where to locate the anchor.
                    if (newEndpoint.anchor.positionFinder != null) {
                        var dropPosition = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom()),
                            elPosition = _currentInstance.getOffset(elInfo.el),
                            elSize = _currentInstance.getSize(elInfo.el),
                            ap = dropPosition == null ? [0,0] : newEndpoint.anchor.positionFinder(dropPosition, elPosition, elSize, newEndpoint.anchor.constructorParams);

                        newEndpoint.anchor.x = ap[0];
                        newEndpoint.anchor.y = ap[1];
                        // now figure an orientation for it..kind of hard to know what to do actually. probably the best thing i can do is to
                        // support specifying an orientation in the anchor's spec. if one is not supplied then i will make the orientation
                        // be what will cause the most natural link to the source: it will be pointing at the source, but it needs to be
                        // specified in one axis only, and so how to make that choice? i think i will use whichever axis is the one in which
                        // the target is furthest away from the source.
                    }

                    return newEndpoint;
                },
                maybeCleanup: function (ep) {
                    if (ep._mtNew && ep.connections.length === 0) {
                        _currentInstance.deleteObject({endpoint: ep});
                    }
                    else
                        delete ep._mtNew;
                }
            });

            // wrap drop events as needed and initialise droppable
            var dropEvent = root.jsPlumb.dragEvents.drop;
            dropOptions.scope = dropOptions.scope || (p.scope || _currentInstance.Defaults.Scope);
            dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], _drop, true);

            // if target, return true from the over event. this will cause katavorio to stop setting drops to hover
            // if multipleDrop is set to false.
            if (isTarget) {
                dropOptions[root.jsPlumb.dragEvents.over] = function () { return true; };
            }

            // vanilla jsplumb only
            if (p.allowLoopback === false) {
                dropOptions.canDrop = function (_drag) {
                    var de = _drag.getDragElement()._jsPlumbRelatedElement;
                    return de != elInfo.el;
                };
            }
            _currentInstance.initDroppable(elInfo.el, dropOptions, "internal");

            return _drop;

        };

        // see API docs
        this.makeTarget = function (el, params, referenceParams) {

            // put jsplumb ref into params without altering the params passed in
            var p = root.jsPlumb.extend({_jsPlumb: this}, referenceParams);
            root.jsPlumb.extend(p, params);

            var maxConnections = p.maxConnections || -1,

                _doOne = function (el) {

                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    // decode the info for this element (id and element)
                    var elInfo = _info(el),
                        elid = elInfo.id,
                        dropOptions = root.jsPlumb.extend({}, p.dropOptions || {}),
                        type = p.connectionType || "default";

                    this.targetEndpointDefinitions[elid] = this.targetEndpointDefinitions[elid] || {};

                    _ensureContainer(elid);

                    // if this is a group and the user has not mandated a rank, set to -1 so that Nodes takes
                    // precedence.
                    if (elInfo.el._isJsPlumbGroup && dropOptions.rank == null) {
                        dropOptions.rank = -1;
                    }

                    // store the definition
                    var _def = {
                        def: root.jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };
                    elInfo.def = _def;
                    this.targetEndpointDefinitions[elid][type] = _def;
                    _makeElementDropHandler(elInfo, p, dropOptions, p.isSource === true, true);
                    // stash the definition on the drop
                    elInfo.el._katavorioDrop[elInfo.el._katavorioDrop.length - 1].targetDef = _def;

                }.bind(this);

            // make an array if only given one element
            var inputs = el.length && el.constructor != String ? el : [ el ];

            // register each one in the list.
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(inputs[i]);
            }

            return this;
        };

        // see api docs
        this.unmakeTarget = function (el, doNotClearArrays) {
            var info = _info(el);
            _currentInstance.destroyDroppable(info.el, "internal");
            if (!doNotClearArrays) {
                delete this.targetEndpointDefinitions[info.id];
            }

            return this;
        };

        // see api docs
        this.makeSource = function (el, params, referenceParams) {
            var p = root.jsPlumb.extend({_jsPlumb: this}, referenceParams);
            root.jsPlumb.extend(p, params);
            var type = p.connectionType || "default";
            var aae = _currentInstance.deriveEndpointAndAnchorSpec(type);
            p.endpoint = p.endpoint || aae.endpoints[0];
            p.anchor = p.anchor || aae.anchors[0];
            var maxConnections = p.maxConnections || -1,
                onMaxConnections = p.onMaxConnections,
                _doOne = function (elInfo) {
                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    var elid = elInfo.id,
                        _del = this.getElement(elInfo.el);

                    this.sourceEndpointDefinitions[elid] = this.sourceEndpointDefinitions[elid] || {};
                    _ensureContainer(elid);

                    var _def = {
                        def:root.jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };


                    this.sourceEndpointDefinitions[elid][type] = _def;
                    elInfo.def = _def;

                    var stopEvent = root.jsPlumb.dragEvents.stop,
                        dragEvent = root.jsPlumb.dragEvents.drag,
                        dragOptions = root.jsPlumb.extend({ }, p.dragOptions || {}),
                        existingDrag = dragOptions.drag,
                        existingStop = dragOptions.stop,
                        ep = null,
                        endpointAddedButNoDragYet = false;

                    // set scope if its not set in dragOptions but was passed in in params
                    dragOptions.scope = dragOptions.scope || p.scope;

                    dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], function () {
                        if (existingDrag) existingDrag.apply(this, arguments);
                        endpointAddedButNoDragYet = false;
                    });

                    dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], function () {

                        if (existingStop) existingStop.apply(this, arguments);
                        this.currentlyDragging = false;
                        if (ep._jsPlumb != null) { // if not cleaned up...

                            // reset the anchor to the anchor that was initially provided. the one we were using to drag
                            // the connection was just a placeholder that was located at the place the user pressed the
                            // mouse button to initiate the drag.
                            var anchorDef = p.anchor || this.Defaults.Anchor,
                                oldAnchor = ep.anchor,
                                oldConnection = ep.connections[0];

                            var    newAnchor = this.makeAnchor(anchorDef, elid, this),
                                _el = ep.element;

                            // if the anchor has a 'positionFinder' set, then delegate to that function to find
                            // out where to locate the anchor. issue 117.
                            if (newAnchor.positionFinder != null) {
                                var elPosition = _currentInstance.getOffset(_el),
                                    elSize = this.getSize(_el),
                                    dropPosition = { left: elPosition.left + (oldAnchor.x * elSize[0]), top: elPosition.top + (oldAnchor.y * elSize[1]) },
                                    ap = newAnchor.positionFinder(dropPosition, elPosition, elSize, newAnchor.constructorParams);

                                newAnchor.x = ap[0];
                                newAnchor.y = ap[1];
                            }

                            ep.setAnchor(newAnchor, true);
                            ep.repaint();
                            this.repaint(ep.elementId);
                            if (oldConnection != null) this.repaint(oldConnection.targetId);
                        }
                    }.bind(this));

                    // when the user presses the mouse, add an Endpoint, if we are enabled.
                    var mouseDownListener = function (e) {
                        // on right mouse button, abort.
                        if (e.which === 3 || e.button === 2) return;

                        // TODO store def on element.
                        var def = this.sourceEndpointDefinitions[elid][type];

                        // if disabled, return.
                        if (!def.enabled) return;

                        elid = this.getId(this.getElement(elInfo.el)); // elid might have changed since this method was called to configure the element.

                        // if a filter was given, run it, and return if it says no.
                        if (p.filter) {
                            var r = _ju.isString(p.filter) ? selectorFilter(e, elInfo.el, p.filter, this, p.filterExclude) : p.filter(e, elInfo.el);
                            if (r === false) return;
                        }

                        // if maxConnections reached
                        var sourceCount = this.select({source: elid}).length;
                        if (def.maxConnections >= 0 && (sourceCount >= def.maxConnections)) {
                            if (onMaxConnections) {
                                onMaxConnections({
                                    element: elInfo.el,
                                    maxConnections: maxConnections
                                }, e);
                            }
                            return false;
                        }

                        // find the position on the element at which the mouse was pressed; this is where the endpoint
                        // will be located.
                        var elxy = root.jsPlumb.getPositionOnElement(e, _del, _zoom);

                        // we need to override the anchor in here, and force 'isSource', but we don't want to mess with
                        // the params passed in, because after a connection is established we're going to reset the endpoint
                        // to have the anchor we were given.
                        var tempEndpointParams = {};
                        root.jsPlumb.extend(tempEndpointParams, p);
                        tempEndpointParams.isTemporarySource = true;
                        tempEndpointParams.anchor = [ elxy[0], elxy[1] , 0, 0];
                        tempEndpointParams.dragOptions = dragOptions;

                        if (def.def.scope) tempEndpointParams.scope = def.def.scope;

                        ep = this.addEndpoint(elid, tempEndpointParams);
                        endpointAddedButNoDragYet = true;
                        ep.setDeleteOnEmpty(true);

                        // if unique endpoint and it's already been created, push it onto the endpoint we create. at the end
                        // of a successful connection we'll switch to that endpoint.
                        // TODO this is the same code as the programmatic endpoints create on line 1050 ish
                        if (def.uniqueEndpoint) {
                            if (!def.endpoint) {
                                def.endpoint = ep;
                                ep.setDeleteOnEmpty(false);
                            }
                            else
                                ep.finalEndpoint = def.endpoint;
                        }

                        var _delTempEndpoint = function () {
                            // this mouseup event is fired only if no dragging occurred, by jquery and yui, but for mootools
                            // it is fired even if dragging has occurred, in which case we would blow away a perfectly
                            // legitimate endpoint, were it not for this check.  the flag is set after adding an
                            // endpoint and cleared in a drag listener we set in the dragOptions above.
                            _currentInstance.off(ep.canvas, "mouseup", _delTempEndpoint);
                            _currentInstance.off(elInfo.el, "mouseup", _delTempEndpoint);
                            if (endpointAddedButNoDragYet) {
                                endpointAddedButNoDragYet = false;
                                _currentInstance.deleteEndpoint(ep);
                            }
                        };

                        _currentInstance.on(ep.canvas, "mouseup", _delTempEndpoint);
                        _currentInstance.on(elInfo.el, "mouseup", _delTempEndpoint);

                        // optionally check for attributes to extract from the source element
                        var payload = {};
                        if (def.def.extract) {
                            for (var att in def.def.extract) {
                                var v = (e.srcElement || e.target).getAttribute(att);
                                if (v) {
                                    payload[def.def.extract[att]] = v;
                                }
                            }
                        }

                        // and then trigger its mousedown event, which will kick off a drag, which will start dragging
                        // a new connection from this endpoint.
                        _currentInstance.trigger(ep.canvas, "mousedown", e, payload);

                        _ju.consume(e);

                    }.bind(this);

                    this.on(elInfo.el, "mousedown", mouseDownListener);
                    _def.trigger = mouseDownListener;

                    // if a filter was provided, set it as a dragFilter on the element,
                    // to prevent the element drag function from kicking in when we want to
                    // drag a new connection
                    if (p.filter && (_ju.isString(p.filter) || _ju.isFunction(p.filter))) {
                        _currentInstance.setDragFilter(elInfo.el, p.filter);
                    }

                    var dropOptions = root.jsPlumb.extend({}, p.dropOptions || {});

                    _makeElementDropHandler(elInfo, p, dropOptions, true, p.isTarget === true);

                }.bind(this);

            var inputs = el.length && el.constructor != String ? el : [ el ];
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(_info(inputs[i]));
            }

            return this;
        };

        // see api docs
        this.unmakeSource = function (el, connectionType, doNotClearArrays) {
            var info = _info(el);
            _currentInstance.destroyDroppable(info.el, "internal");
            var eldefs = this.sourceEndpointDefinitions[info.id];
            if (eldefs) {
                for (var def in eldefs) {
                    if (connectionType == null || connectionType === def) {
                        var mouseDownListener = eldefs[def].trigger;
                        if (mouseDownListener)
                            _currentInstance.off(info.el, "mousedown", mouseDownListener);
                        if (!doNotClearArrays) {
                            delete this.sourceEndpointDefinitions[info.id][def];
                        }
                    }
                }
            }

            return this;
        };

        // see api docs
        this.unmakeEverySource = function () {
            for (var i in this.sourceEndpointDefinitions)
                _currentInstance.unmakeSource(i, null, true);

            this.sourceEndpointDefinitions = {};
            return this;
        };

        var _getScope = function (el, types, connectionType) {
            types = _ju.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) return eldefs[connectionType].def.scope || this.Defaults.Scope;
            }
        }.bind(this);

        var _setScope = function (el, scope, types, connectionType) {
            types = _ju.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) {
                    eldefs[connectionType].def.scope = scope;
                }
            }

        }.bind(this);

        this.getScope = function (el, scope) {
            return _getScope(el, [ "sourceEndpointDefinitions", "targetEndpointDefinitions" ]);
        };
        this.getSourceScope = function (el) {
            return _getScope(el, "sourceEndpointDefinitions");
        };
        this.getTargetScope = function (el) {
            return _getScope(el, "targetEndpointDefinitions");
        };
        this.setScope = function (el, scope, connectionType) {
            this.setSourceScope(el, scope, connectionType);
            this.setTargetScope(el, scope, connectionType);
        };
        this.setSourceScope = function (el, scope, connectionType) {
            _setScope(el, scope, "sourceEndpointDefinitions", connectionType);
            // we get the source scope during the mousedown event, but we also want to set this.
            this.setDragScope(el, scope);
        };
        this.setTargetScope = function (el, scope, connectionType) {
            _setScope(el, scope, "targetEndpointDefinitions", connectionType);
            this.setDropScope(el, scope);
        };

        // see api docs
        this.unmakeEveryTarget = function () {
            for (var i in this.targetEndpointDefinitions)
                _currentInstance.unmakeTarget(i, true);

            this.targetEndpointDefinitions = {};
            return this;
        };

        // does the work of setting a source enabled or disabled.
        var _setEnabled = function (type, el, state, toggle, connectionType) {
            var a = type == "source" ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions,
                originalState, info, newState;

            connectionType = connectionType || "default";

            // a selector or an array
            if (el.length && !_ju.isString(el)) {
                originalState = [];
                for (var i = 0, ii = el.length; i < ii; i++) {
                    info = _info(el[i]);
                    if (a[info.id] && a[info.id][connectionType]) {
                        originalState[i] = a[info.id][connectionType].enabled;
                        newState = toggle ? !originalState[i] : state;
                        a[info.id][connectionType].enabled = newState;
                        _currentInstance[newState ? "removeClass" : "addClass"](info.el, "jtk-" + type + "-disabled");
                    }
                }
            }
            // otherwise a DOM element or a String ID.
            else {
                info = _info(el);
                var id = info.id;
                if (a[id] && a[id][connectionType]) {
                    originalState = a[id][connectionType].enabled;
                    newState = toggle ? !originalState : state;
                    a[id][connectionType].enabled = newState;
                    _currentInstance[newState ? "removeClass" : "addClass"](info.el, "jtk-" + type + "-disabled");
                }
            }
            return originalState;
        }.bind(this);

        var _first = function (el, fn) {
            if (_ju.isString(el) || !el.length)
                return fn.apply(this, [ el ]);
            else if (el.length)
                return fn.apply(this, [ el[0] ]);

        }.bind(this);

        this.toggleSourceEnabled = function (el, connectionType) {
            _setEnabled("source", el, null, true, connectionType);
            return this.isSourceEnabled(el, connectionType);
        };

        this.setSourceEnabled = function (el, state, connectionType) {
            return _setEnabled("source", el, state, null, connectionType);
        };
        this.isSource = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.sourceEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isSourceEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var sep = this.sourceEndpointDefinitions[_info(_el).id];
                return sep && sep[connectionType] && sep[connectionType].enabled === true;
            }.bind(this));
        };

        this.toggleTargetEnabled = function (el, connectionType) {
            _setEnabled("target", el, null, true, connectionType);
            return this.isTargetEnabled(el, connectionType);
        };

        this.isTarget = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.targetEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isTargetEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var tep = this.targetEndpointDefinitions[_info(_el).id];
                return tep && tep[connectionType] && tep[connectionType].enabled === true;
            }.bind(this));
        };
        this.setTargetEnabled = function (el, state, connectionType) {
            return _setEnabled("target", el, state, null, connectionType);
        };

// --------------------- end makeSource/makeTarget ---------------------------------------------- 				

        this.ready = function (fn) {
            _currentInstance.bind("ready", fn);
        };

        var _elEach = function(el, fn) {
            // support both lists...
            if (typeof el == 'object' && el.length)
                for (var i = 0, ii = el.length; i < ii; i++) {
                    fn(el[i]);
                }
            else // ...and single strings or elements.
                fn(el);

            return _currentInstance;
        };

        // repaint some element's endpoints and connections
        this.repaint = function (el, ui, timestamp) {
            return _elEach(el, function(_el) {
                _draw(_el, ui, timestamp);
            });
        };

        this.revalidate = function (el, timestamp, isIdAlready) {
            return _elEach(el, function(_el) {
                var elId = isIdAlready ? _el : _currentInstance.getId(_el);
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp:timestamp });
                _currentInstance.getDragManager().updateOffsets(elId);
                _currentInstance.repaint(_el);
            });
        };

        // repaint every endpoint and connection.
        this.repaintEverything = function () {
            // TODO this timestamp causes continuous anchors to not repaint properly.
            // fix this. do not just take out the timestamp. it runs a lot faster with
            // the timestamp included.
            var timestamp = _timestamp(), elId;

            for (elId in endpointsByElement) {
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp: timestamp });
            }

            for (elId in endpointsByElement) {
                _draw(elId, null, timestamp);
            }

            return this;
        };

        this.removeAllEndpoints = function (el, recurse, affectedElements) {
            affectedElements = affectedElements || [];
            var _one = function (_el) {
                var info = _info(_el),
                    ebe = endpointsByElement[info.id],
                    i, ii;

                if (ebe) {
                    affectedElements.push(info);
                    for (i = 0, ii = ebe.length; i < ii; i++)
                        _currentInstance.deleteEndpoint(ebe[i], false);
                }
                delete endpointsByElement[info.id];

                if (recurse) {
                    if (info.el && info.el.nodeType != 3 && info.el.nodeType != 8) {
                        for (i = 0, ii = info.el.childNodes.length; i < ii; i++) {
                            _one(info.el.childNodes[i]);
                        }
                    }
                }

            };
            _one(el);
            return this;
        };

        var _doRemove = function(info, affectedElements) {
            _currentInstance.removeAllEndpoints(info.id, true, affectedElements);
            var _one = function(_info) {
                _currentInstance.getDragManager().elementRemoved(_info.id);
                _currentInstance.anchorManager.clearFor(_info.id);
                _currentInstance.anchorManager.removeFloatingConnection(_info.id);

                if (_currentInstance.isSource(_info.el)) _currentInstance.unmakeSource(_info.el);
                if (_currentInstance.isTarget(_info.el)) _currentInstance.unmakeTarget(_info.el);
                _currentInstance.destroyDraggable(_info.el);
                _currentInstance.destroyDroppable(_info.el);


                delete _currentInstance.floatingConnections[_info.id];
                delete managedElements[_info.id];
                delete offsets[_info.id];
                if (_info.el) {
                    _currentInstance.removeElement(_info.el);
                    _info.el._jsPlumb = null;
                }
            };

            // remove all affected child elements
            for (var ae = 1; ae < affectedElements.length; ae++) {
                _one(affectedElements[ae]);
            }
            // and always remove the requested one from the dom.
            _one(info);
        };

        /**
         * Remove the given element, including cleaning up all endpoints registered for it.
         * This is exposed in the public API but also used internally by jsPlumb when removing the
         * element associated with a connection drag.
         */
        this.remove = function (el, doNotRepaint) {
            var info = _info(el), affectedElements = [];
            if (info.text) {
                info.el.parentNode.removeChild(info.el);
            }
            else if (info.id) {
                _currentInstance.batch(function () {
                    _doRemove(info, affectedElements);
                }, doNotRepaint === false);
            }
            return _currentInstance;
        };

        this.empty = function (el, doNotRepaint) {
            var affectedElements = [];
            var _one = function(el, dontRemoveFocus) {
                var info = _info(el);
                if (info.text) {
                    info.el.parentNode.removeChild(info.el);
                }
                else if (info.el) {
                    while(info.el.childNodes.length > 0) {
                        _one(info.el.childNodes[0]);
                    }
                    if (!dontRemoveFocus) _doRemove(info, affectedElements);
                }
            };

            _currentInstance.batch(function() {
                _one(el, true);
            }, doNotRepaint === false);

            return _currentInstance;
        };

        this.reset = function () {
            _currentInstance.silently(function() {
                _hoverSuspended = false;
                _currentInstance.removeAllGroups();
                _currentInstance.removeGroupManager();
                _currentInstance.deleteEveryEndpoint();
                _currentInstance.unbind();
                this.targetEndpointDefinitions = {};
                this.sourceEndpointDefinitions = {};
                connections.length = 0;
                if (this.doReset) this.doReset();
            }.bind(this));
        };

        var _clearObject = function (obj) {
            if (obj.canvas && obj.canvas.parentNode)
                obj.canvas.parentNode.removeChild(obj.canvas);
            obj.cleanup();
            obj.destroy();
        };

        this.clear = function () {
            _currentInstance.select().each(_clearObject);
            _currentInstance.selectEndpoints().each(_clearObject);

            endpointsByElement = {};
            endpointsByUUID = {};
        };

        this.setDefaultScope = function (scope) {
            DEFAULT_SCOPE = scope;
            return _currentInstance;
        };

        // sets whether or not some element should be currently draggable.
        this.setDraggable = _setDraggable;

        this.deriveEndpointAndAnchorSpec = function(type, dontPrependDefault) {
            var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/), eps = null, ep = null, a = null, as = null;
            for (var i = 0; i < bits.length; i++) {
                var _t = _currentInstance.getType(bits[i], "connection");
                if (_t) {
                    if (_t.endpoints) eps = _t.endpoints;
                    if (_t.endpoint) ep = _t.endpoint;
                    if (_t.anchors) as = _t.anchors;
                    if (_t.anchor) a = _t.anchor;
                }
            }
            return { endpoints: eps ? eps : [ ep, ep ], anchors: as ? as : [a, a ]};
        };

        // sets the id of some element, changing whatever we need to to keep track.
        this.setId = function (el, newId, doNotSetAttribute) {
            //
            var id;

            if (_ju.isString(el)) {
                id = el;
            }
            else {
                el = this.getElement(el);
                id = this.getId(el);
            }

            var sConns = this.getConnections({source: id, scope: '*'}, true),
                tConns = this.getConnections({target: id, scope: '*'}, true);

            newId = "" + newId;

            if (!doNotSetAttribute) {
                el = this.getElement(id);
                this.setAttribute(el, "id", newId);
            }
            else
                el = this.getElement(newId);

            endpointsByElement[newId] = endpointsByElement[id] || [];
            for (var i = 0, ii = endpointsByElement[newId].length; i < ii; i++) {
                endpointsByElement[newId][i].setElementId(newId);
                endpointsByElement[newId][i].setReferenceElement(el);
            }
            delete endpointsByElement[id];

            this.sourceEndpointDefinitions[newId] = this.sourceEndpointDefinitions[id];
            delete this.sourceEndpointDefinitions[id];
            this.targetEndpointDefinitions[newId] = this.targetEndpointDefinitions[id];
            delete this.targetEndpointDefinitions[id];

            this.anchorManager.changeId(id, newId);
            this.getDragManager().changeId(id, newId);
            managedElements[newId] = managedElements[id];
            delete managedElements[id];

            var _conns = function (list, epIdx, type) {
                for (var i = 0, ii = list.length; i < ii; i++) {
                    list[i].endpoints[epIdx].setElementId(newId);
                    list[i].endpoints[epIdx].setReferenceElement(el);
                    list[i][type + "Id"] = newId;
                    list[i][type] = el;
                }
            };
            _conns(sConns, 0, "source");
            _conns(tConns, 1, "target");

            this.repaint(newId);
        };

        this.setDebugLog = function (debugLog) {
            log = debugLog;
        };

        this.setSuspendDrawing = function (val, repaintAfterwards) {
            var curVal = _suspendDrawing;
            _suspendDrawing = val;
            if (val) _suspendedAt = new Date().getTime(); else _suspendedAt = null;
            if (repaintAfterwards) this.repaintEverything();
            return curVal;
        };

        // returns whether or not drawing is currently suspended.
        this.isSuspendDrawing = function () {
            return _suspendDrawing;
        };

        // return timestamp for when drawing was suspended.
        this.getSuspendedAt = function () {
            return _suspendedAt;
        };

        this.batch = function (fn, doNotRepaintAfterwards) {
            var _wasSuspended = this.isSuspendDrawing();
            if (!_wasSuspended)
                this.setSuspendDrawing(true);
            try {
                fn();
            }
            catch (e) {
                _ju.log("Function run while suspended failed", e);
            }
            if (!_wasSuspended)
                this.setSuspendDrawing(false, !doNotRepaintAfterwards);
        };

        this.doWhileSuspended = this.batch;

        this.getCachedData = _getCachedData;
        this.timestamp = _timestamp;
        this.show = function (el, changeEndpoints) {
            _setVisible(el, "block", changeEndpoints);
            return _currentInstance;
        };

        // TODO: update this method to return the current state.
        this.toggleVisible = _toggleVisible;
        this.toggleDraggable = _toggleDraggable;
        this.addListener = this.bind;
    };

    _ju.extend(root.jsPlumbInstance, _ju.EventGenerator, {
        setAttribute: function (el, a, v) {
            this.setAttribute(el, a, v);
        },
        getAttribute: function (el, a) {
            return this.getAttribute(root.jsPlumb.getElement(el), a);
        },
        convertToFullOverlaySpec: function(spec) {
            if (_ju.isString(spec)) {
                spec = [ spec, { } ];
            }
            spec[1].id = spec[1].id || _ju.uuid();
            return spec;
        },
        registerConnectionType: function (id, type) {
            this._connectionTypes[id] = root.jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._connectionTypes[id].overlays = to;
            }
        },
        registerConnectionTypes: function (types) {
            for (var i in types)
                this.registerConnectionType(i, types[i]);
        },
        registerEndpointType: function (id, type) {
            this._endpointTypes[id] = root.jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._endpointTypes[id].overlays = to;
            }
        },
        registerEndpointTypes: function (types) {
            for (var i in types)
                //this._endpointTypes[i] = jsPlumb.extend({}, types[i]);
                this.registerEndpointType(i, types[i]);
        },
        getType: function (id, typeDescriptor) {
            return typeDescriptor === "connection" ? this._connectionTypes[id] : this._endpointTypes[id];
        },
        setIdChanged: function (oldId, newId) {
            this.setId(oldId, newId, true);
        },
        // set parent: change the parent for some node and update all the registrations we need to.
        setParent: function (el, newParent) {
            var _dom = this.getElement(el),
                _id = this.getId(_dom),
                _pdom = this.getElement(newParent),
                _pid = this.getId(_pdom);

            _dom.parentNode.removeChild(_dom);
            _pdom.appendChild(_dom);
            this.getDragManager().setParent(_dom, _id, _pdom, _pid);
        },
        extend: function (o1, o2, names) {
            var i;
            if (names) {
                for (i = 0; i < names.length; i++)
                    o1[names[i]] = o2[names[i]];
            }
            else
                for (i in o2) o1[i] = o2[i];
            return o1;
        },
        floatingConnections: {},
        getFloatingAnchorIndex: function (jpc) {
            return jpc.endpoints[0].isFloating() ? 0 : jpc.endpoints[1].isFloating() ? 1 : -1;
        }
    });

    jsPlumbInstance.prototype.Defaults = {
        Anchor: "Bottom",
        Anchors: [ null, null ],
        ConnectionsDetachable: true,
        ConnectionOverlays: [ ],
        Connector: "Bezier",
        Container: null,
        DoNotThrowErrors: false,
        DragOptions: { },
        DropOptions: { },
        Endpoint: "Dot",
        EndpointOverlays: [ ],
        Endpoints: [ null, null ],
        EndpointStyle: { fill: "#456" },
        EndpointStyles: [ null, null ],
        EndpointHoverStyle: null,
        EndpointHoverStyles: [ null, null ],
        HoverPaintStyle: null,
        LabelStyle: { color: "black" },
        LogEnabled: false,
        Overlays: [ ],
        MaxConnections: 1,
        PaintStyle: { "stroke-width": 4, stroke: "#456" },
        ReattachConnections: false,
        RenderMode: "svg",
        Scope: "jsPlumb_DefaultScope"
    };

// --------------------- static instance + module registration -------------------------------------------

// create static instance and assign to window if window exists.	
    var jsPlumb = new jsPlumbInstance();
    // register on 'root' (lets us run on server or browser)
    root.jsPlumb = jsPlumb;
    // add 'getInstance' method to static instance
    jsPlumb.getInstance = function (_defaults, overrideFns) {
        var j = new jsPlumbInstance(_defaults);
        if (overrideFns) {
            for (var ovf in overrideFns) {
                j[ovf] = overrideFns[ovf];
            }
        }
        j.init();
        return j;
    };
    jsPlumb.each = function (spec, fn) {
        if (spec == null) return;
        if (typeof spec === "string")
            fn(jsPlumb.getElement(spec));
        else if (spec.length != null) {
            for (var i = 0; i < spec.length; i++)
                fn(jsPlumb.getElement(spec[i]));
        }
        else
            fn(spec); // assume it's an element.
    };

    // CommonJS
    if (typeof exports !== 'undefined') {
        exports.jsPlumb = jsPlumb;
    }

// --------------------- end static instance + AMD registration -------------------------------------------		

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base functionality for DOM type adapters.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    var root = this, _ju = root.jsPlumbUtil;

    var _genLoc = function (prefix, e) {
            if (e == null) return [ 0, 0 ];
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = _genLoc.bind(this, "page"),
        _screenLocation = _genLoc.bind(this, "screen"),
        _clientLocation = _genLoc.bind(this, "client"),
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        };

    /**
     Manages dragging for some instance of jsPlumb.

     TODO instead of this being accessed directly, it should subscribe to events on the jsPlumb instance: every method
     in here is called directly by jsPlumb. But what should happen is that we have unpublished events that this listens
     to.  The only trick is getting one of these instantiated with every jsPlumb instance: it needs to have a hook somehow.
     Basically the general idea is to pull ALL the drag code out (prototype method registrations plus this) into a
     dedicated drag script), that does not necessarily need to be included.


     */
    var DragManager = function (_currentInstance) {
        var _draggables = {}, _dlist = [], _delements = {}, _elementsWithEndpoints = {},
        // elementids mapped to the draggable to which they belong.
            _draggablesForElements = {};

        /**
         register some element as draggable.  right now the drag init stuff is done elsewhere, and it is
         possible that will continue to be the case.
         */
        this.register = function (el) {
            var id = _currentInstance.getId(el),
                parentOffset = _currentInstance.getOffset(el);

            if (!_draggables[id]) {
                _draggables[id] = el;
                _dlist.push(el);
                _delements[id] = {};
            }

            // look for child elements that have endpoints and register them against this draggable.
            var _oneLevel = function (p) {
                if (p) {
                    for (var i = 0; i < p.childNodes.length; i++) {
                        if (p.childNodes[i].nodeType != 3 && p.childNodes[i].nodeType != 8) {
                            var cEl = jsPlumb.getElement(p.childNodes[i]),
                                cid = _currentInstance.getId(p.childNodes[i], null, true);
                            if (cid && _elementsWithEndpoints[cid] && _elementsWithEndpoints[cid] > 0) {
                                var cOff = _currentInstance.getOffset(cEl);
                                _delements[id][cid] = {
                                    id: cid,
                                    offset: {
                                        left: cOff.left - parentOffset.left,
                                        top: cOff.top - parentOffset.top
                                    }
                                };
                                _draggablesForElements[cid] = id;
                            }
                            _oneLevel(p.childNodes[i]);
                        }
                    }
                }
            };

            _oneLevel(el);
        };

        // refresh the offsets for child elements of this element.
        this.updateOffsets = function (elId, childOffsetOverrides) {
            if (elId != null) {
                childOffsetOverrides = childOffsetOverrides || {};
                var domEl = jsPlumb.getElement(elId),
                    id = _currentInstance.getId(domEl),
                    children = _delements[id],
                    parentOffset = _currentInstance.getOffset(domEl);

                if (children) {
                    for (var i in children) {
                        if (children.hasOwnProperty(i)) {
                            var cel = jsPlumb.getElement(i),
                                cOff = childOffsetOverrides[i] || _currentInstance.getOffset(cel);

                            // do not update if we have a value already and we'd just be writing 0,0
                            if (cel.offsetParent == null && _delements[id][i] != null) continue;

                            _delements[id][i] = {
                                id: i,
                                offset: {
                                    left: cOff.left - parentOffset.left,
                                    top: cOff.top - parentOffset.top
                                }
                            };
                            _draggablesForElements[i] = id;
                        }
                    }
                }
            }
        };

        /**
         notification that an endpoint was added to the given el.  we go up from that el's parent
         node, looking for a parent that has been registered as a draggable. if we find one, we add this
         el to that parent's list of elements to update on drag (if it is not there already)
         */
        this.endpointAdded = function (el, id) {

            id = id || _currentInstance.getId(el);

            var b = document.body,
                p = el.parentNode;

            _elementsWithEndpoints[id] = _elementsWithEndpoints[id] ? _elementsWithEndpoints[id] + 1 : 1;

            while (p != null && p != b) {
                var pid = _currentInstance.getId(p, null, true);
                if (pid && _draggables[pid]) {
                    var pLoc = _currentInstance.getOffset(p);

                    if (_delements[pid][id] == null) {
                        var cLoc = _currentInstance.getOffset(el);
                        _delements[pid][id] = {
                            id: id,
                            offset: {
                                left: cLoc.left - pLoc.left,
                                top: cLoc.top - pLoc.top
                            }
                        };
                        _draggablesForElements[id] = pid;
                    }
                    break;
                }
                p = p.parentNode;
            }
        };

        this.endpointDeleted = function (endpoint) {
            if (_elementsWithEndpoints[endpoint.elementId]) {
                _elementsWithEndpoints[endpoint.elementId]--;
                if (_elementsWithEndpoints[endpoint.elementId] <= 0) {
                    for (var i in _delements) {
                        if (_delements.hasOwnProperty(i) && _delements[i]) {
                            delete _delements[i][endpoint.elementId];
                            delete _draggablesForElements[endpoint.elementId];
                        }
                    }
                }
            }
        };

        this.changeId = function (oldId, newId) {
            _delements[newId] = _delements[oldId];
            _delements[oldId] = {};
            _draggablesForElements[newId] = _draggablesForElements[oldId];
            _draggablesForElements[oldId] = null;
        };

        this.getElementsForDraggable = function (id) {
            return _delements[id];
        };

        this.elementRemoved = function (elementId) {
            var elId = _draggablesForElements[elementId];
            if (elId) {
                delete _delements[elId][elementId];
                delete _draggablesForElements[elementId];
            }
        };

        this.reset = function () {
            _draggables = {};
            _dlist = [];
            _delements = {};
            _elementsWithEndpoints = {};
        };

        //
        // notification drag ended. We check automatically if need to update some
        // ancestor's offsets.
        //
        this.dragEnded = function (el) {
            if (el.offsetParent != null) {
                var id = _currentInstance.getId(el),
                    ancestor = _draggablesForElements[id];

                if (ancestor) this.updateOffsets(ancestor);
            }
        };

        this.setParent = function (el, elId, p, pId, currentChildLocation) {
            var current = _draggablesForElements[elId];
            if (!_delements[pId]) {
                _delements[pId] = {};
            }
            var pLoc = _currentInstance.getOffset(p),
                cLoc = currentChildLocation || _currentInstance.getOffset(el);

            if (current && _delements[current]) {
                delete _delements[current][elId];
            }

            _delements[pId][elId] = {
                id:elId,
                offset : {
                    left: cLoc.left - pLoc.left,
                    top: cLoc.top - pLoc.top
                }
            };
            _draggablesForElements[elId] = pId;
        };

        this.clearParent = function(el, elId) {
            var current = _draggablesForElements[elId];
            if (current) {
                delete _delements[current][elId];
                delete _draggablesForElements[elId];
            }
        };

        this.revalidateParent = function(el, elId, childOffset) {
            var current = _draggablesForElements[elId];
            if (current) {
                var co = {};
                co[elId] = childOffset;
                this.updateOffsets(current, co);
                _currentInstance.revalidate(current);
            }
        };

        this.getDragAncestor = function (el) {
            var de = jsPlumb.getElement(el),
                id = _currentInstance.getId(de),
                aid = _draggablesForElements[id];

            if (aid)
                return jsPlumb.getElement(aid);
            else
                return null;
        };

    };

    var trim = function (str) {
            return str == null ? null : (str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''));
        },
        _setClassName = function (el, cn) {
            cn = trim(cn);
            if (typeof el.className.baseVal != "undefined")  // SVG
                el.className.baseVal = cn;
            else
                el.className = cn;
        },
        _getClassName = function (el) {
            return (typeof el.className.baseVal == "undefined") ? el.className : el.className.baseVal;
        },
        _classManip = function (el, classesToAdd, classesToRemove) {
            classesToAdd = classesToAdd == null ? [] : _ju.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
            classesToRemove = classesToRemove == null ? [] : _ju.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);

            var className = _getClassName(el),
                curClasses = className.split(/\s+/);

            var _oneSet = function (add, classes) {
                for (var i = 0; i < classes.length; i++) {
                    if (add) {
                        if (curClasses.indexOf(classes[i]) == -1)
                            curClasses.push(classes[i]);
                    }
                    else {
                        var idx = curClasses.indexOf(classes[i]);
                        if (idx != -1)
                            curClasses.splice(idx, 1);
                    }
                }
            };

            _oneSet(true, classesToAdd);
            _oneSet(false, classesToRemove);

            _setClassName(el, curClasses.join(" "));
        };

    root.jsPlumb.extend(root.jsPlumbInstance.prototype, {

        headless: false,

        pageLocation: _pageLocation,
        screenLocation: _screenLocation,
        clientLocation: _clientLocation,

        getDragManager:function() {
            if (this.dragManager == null)
                this.dragManager = new DragManager(this);

            return this.dragManager;
        },

        recalculateOffsets:function(elId) {
            this.getDragManager().updateOffsets(elId);
        },

        createElement:function(tag, style, clazz, atts) {
            return this.createElementNS(null, tag, style, clazz, atts);
        },

        createElementNS:function(ns, tag, style, clazz, atts) {
            var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
            var i;
            style = style || {};
            for (i in style)
                e.style[i] = style[i];

            if (clazz)
                e.className = clazz;

            atts = atts || {};
            for (i in atts)
                e.setAttribute(i, "" + atts[i]);

            return e;
        },

        getAttribute: function (el, attName) {
            return el.getAttribute != null ? el.getAttribute(attName) : null;
        },

        setAttribute: function (el, a, v) {
            if (el.setAttribute != null) el.setAttribute(a, v);
        },

        setAttributes: function (el, atts) {
            for (var i in atts)
                if (atts.hasOwnProperty(i)) el.setAttribute(i, atts[i]);
        },
        appendToRoot: function (node) {
            document.body.appendChild(node);
        },
        getRenderModes: function () {
            return [ "svg"  ];
        },
        getClass:_getClassName,
        addClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, clazz);
            });
        },
        hasClass: function (el, clazz) {
            el = jsPlumb.getElement(el);
            if (el.classList) return el.classList.contains(clazz);
            else {
                return _getClassName(el).indexOf(clazz) != -1;
            }
        },
        removeClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, null, clazz);
            });
        },
        updateClasses: function (el, toAdd, toRemove) {
            jsPlumb.each(el, function (e) {
                _classManip(e, toAdd, toRemove);
            });
        },
        setClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _setClassName(e, clazz);
            });
        },
        setPosition: function (el, p) {
            el.style.left = p.left + "px";
            el.style.top = p.top + "px";
        },
        getPosition: function (el) {
            var _one = function (prop) {
                var v = el.style[prop];
                return v ? v.substring(0, v.length - 2) : 0;
            };
            return {
                left: _one("left"),
                top: _one("top")
            };
        },
        getStyle:function(el, prop) {
            if (typeof window.getComputedStyle !== 'undefined') {
                return getComputedStyle(el, null).getPropertyValue(prop);
            } else {
                return el.currentStyle[prop];
            }
        },
        getSelector: function (ctx, spec) {
            var sel = null;
            if (arguments.length == 1) {
                sel = ctx.nodeType != null ? ctx : document.querySelectorAll(ctx);
            }
            else
                sel = ctx.querySelectorAll(spec);

            return sel;
        },
        getOffset:function(el, relativeToRoot, container) {
            el = jsPlumb.getElement(el);
            container = container || this.getContainer();
            var out = {
                    left: el.offsetLeft,
                    top: el.offsetTop
                },
                op = (relativeToRoot  || (container != null && (el != container && el.offsetParent != container))) ?  el.offsetParent : null,
                _maybeAdjustScroll = function(offsetParent) {
                    if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
                        out.left -= offsetParent.scrollLeft;
                        out.top -= offsetParent.scrollTop;
                    }
                }.bind(this);

            while (op != null) {
                out.left += op.offsetLeft;
                out.top += op.offsetTop;
                _maybeAdjustScroll(op);
                op = relativeToRoot ? op.offsetParent :
                        op.offsetParent == container ? null : op.offsetParent;
            }

            // if container is scrolled and the element (or its offset parent) is not absolute or fixed, adjust accordingly.
            if (container != null && !relativeToRoot && (container.scrollTop > 0 || container.scrollLeft > 0)) {
                var pp = el.offsetParent != null ? this.getStyle(el.offsetParent, "position") : "static",
                    p = this.getStyle(el, "position");
                if (p !== "absolute" && p !== "fixed" && pp !== "absolute" && pp != "fixed") {
                    out.left -= container.scrollLeft;
                    out.top -= container.scrollTop;
                }
            }
            return out;
        },
        //
        // return x+y proportion of the given element's size corresponding to the location of the given event.
        //
        getPositionOnElement: function (evt, el, zoom) {
            var box = typeof el.getBoundingClientRect !== "undefined" ? el.getBoundingClientRect() : { left: 0, top: 0, width: 0, height: 0 },
                body = document.body,
                docElem = document.documentElement,
                scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
                scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                pst = 0,
                psl = 0,
                top = box.top + scrollTop - clientTop + (pst * zoom),
                left = box.left + scrollLeft - clientLeft + (psl * zoom),
                cl = jsPlumb.pageLocation(evt),
                w = box.width || (el.offsetWidth * zoom),
                h = box.height || (el.offsetHeight * zoom),
                x = (cl[0] - left) / w,
                y = (cl[1] - top) / h;

            return [ x, y ];
        },

        /**
         * Gets the absolute position of some element as read from the left/top properties in its style.
         * @method getAbsolutePosition
         * @param {Element} el The element to retrieve the absolute coordinates from. **Note** this is a DOM element, not a selector from the underlying library.
         * @return {Number[]} [left, top] pixel values.
         */
        getAbsolutePosition: function (el) {
            var _one = function (s) {
                var ss = el.style[s];
                if (ss) return parseFloat(ss.substring(0, ss.length - 2));
            };
            return [ _one("left"), _one("top") ];
        },

        /**
         * Sets the absolute position of some element by setting the left/top properties in its style.
         * @method setAbsolutePosition
         * @param {Element} el The element to set the absolute coordinates on. **Note** this is a DOM element, not a selector from the underlying library.
         * @param {Number[]} xy x and y coordinates
         * @param {Number[]} [animateFrom] Optional previous xy to animate from.
         * @param {Object} [animateOptions] Options for the animation.
         */
        setAbsolutePosition: function (el, xy, animateFrom, animateOptions) {
            if (animateFrom) {
                this.animate(el, {
                    left: "+=" + (xy[0] - animateFrom[0]),
                    top: "+=" + (xy[1] - animateFrom[1])
                }, animateOptions);
            }
            else {
                el.style.left = xy[0] + "px";
                el.style.top = xy[1] + "px";
            }
        },
        /**
         * gets the size for the element, in an array : [ width, height ].
         */
        getSize: function (el) {
            return [ el.offsetWidth, el.offsetHeight ];
        },
        getWidth: function (el) {
            return el.offsetWidth;
        },
        getHeight: function (el) {
            return el.offsetHeight;
        },
        getRenderMode : function() { return "svg"; }

    });
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains code for components that support overlays.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // ------------------------------ BEGIN OverlayCapablejsPlumbUIComponent --------------------------------------------

    var _internalLabelOverlayId = "__label",
    // this is a shortcut helper method to let people add a label as
    // overlay.
        _makeLabelOverlay = function (component, params) {

            var _params = {
                    cssClass: params.cssClass,
                    labelStyle: component.labelStyle,
                    id: _internalLabelOverlayId,
                    component: component,
                    _jsPlumb: component._jsPlumb.instance  // TODO not necessary, since the instance can be accessed through the component.
                },
                mergedParams = _jp.extend(_params, params);

            return new _jp.Overlays[component._jsPlumb.instance.getRenderMode()].Label(mergedParams);
        },
        _processOverlay = function (component, o) {
            var _newOverlay = null;
            if (_ju.isArray(o)) {	// this is for the shorthand ["Arrow", { width:50 }] syntax
                // there's also a three arg version:
                // ["Arrow", { width:50 }, {location:0.7}]
                // which merges the 3rd arg into the 2nd.
                var type = o[0],
                // make a copy of the object so as not to mess up anyone else's reference...
                    p = _jp.extend({component: component, _jsPlumb: component._jsPlumb.instance}, o[1]);
                if (o.length == 3) _jp.extend(p, o[2]);
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][type](p);
            } else if (o.constructor == String) {
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][o]({component: component, _jsPlumb: component._jsPlumb.instance});
            } else {
                _newOverlay = o;
            }

            _newOverlay.id = _newOverlay.id || _ju.uuid();
            component.cacheTypeItem("overlay", _newOverlay, _newOverlay.id);
            //component._jsPlumb.overlays.push(_newOverlay);
            component._jsPlumb.overlays[_newOverlay.id] = _newOverlay;

            return _newOverlay;
        };

    _jp.OverlayCapableJsPlumbUIComponent = function (params) {

        root.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.overlays = {};
        this._jsPlumb.overlayPositions = {};

        if (params.label) {
            this.getDefaultType().overlays[_internalLabelOverlayId] = ["Label", {
                label: params.label,
                location: params.labelLocation || this.defaultLabelLocation || 0.5,
                labelStyle: params.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,
                id:_internalLabelOverlayId
            }];
        }

        this.setListenerComponent = function (c) {
            if (this._jsPlumb) {
                for (var i in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[i].setListenerComponent(c);
            }
        };
    };

    _jp.OverlayCapableJsPlumbUIComponent.applyType = function (component, t) {
        if (t.overlays) {
            // loop through the ones in the type. if already present on the component,
            // dont remove or re-add.
            var keep = {}, i;

            for (i in t.overlays) {

                var existing = component._jsPlumb.overlays[t.overlays[i][1].id];
                if (existing) {
                    // maybe update from data, if there were parameterised values for instance.
                    existing.updateFrom(t.overlays[i][1]);
                    keep[t.overlays[i][1].id] = true;
                }
                else {
                    var c = component.getCachedTypeItem("overlay", t.overlays[i][1].id);
                    if (c != null) {
                        c.reattach(component._jsPlumb.instance);
                        c.setVisible(true);
                        // maybe update from data, if there were parameterised values for instance.
                        c.updateFrom(t.overlays[i][1]);
                        component._jsPlumb.overlays[c.id] = c;
                    }
                    else {
                        c = component.addOverlay(t.overlays[i], true);
                    }
                    keep[c.id] = true;
                }
            }

            // now loop through the full overlays and remove those that we dont want to keep
            for (i in component._jsPlumb.overlays) {
                if (keep[component._jsPlumb.overlays[i].id] == null)
                    component.removeOverlay(component._jsPlumb.overlays[i].id, true); // remove overlay but dont clean it up.
                    // that would remove event listeners etc; overlays are never discarded by the types stuff, they are
                    // just detached/reattached.
            }
        }
    };

    _ju.extend(_jp.OverlayCapableJsPlumbUIComponent, root.jsPlumbUIComponent, {

        setHover: function (hover, ignoreAttachedElements) {
            if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i][hover ? "addClass" : "removeClass"](this._jsPlumb.instance.hoverClass);
                }
            }
        },
        addOverlay: function (overlay, doNotRepaint) {
            var o = _processOverlay(this, overlay);
            if (!doNotRepaint) this.repaint();
            return o;
        },
        getOverlay: function (id) {
            return this._jsPlumb.overlays[id];
        },
        getOverlays: function () {
            return this._jsPlumb.overlays;
        },
        hideOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) o.hide();
        },
        hideOverlays: function () {
            for (var i in this._jsPlumb.overlays)
                this._jsPlumb.overlays[i].hide();
        },
        showOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) o.show();
        },
        showOverlays: function () {
            for (var i in this._jsPlumb.overlays)
                this._jsPlumb.overlays[i].show();
        },
        removeAllOverlays: function (doNotRepaint) {
            for (var i in this._jsPlumb.overlays) {
                if (this._jsPlumb.overlays[i].cleanup) this._jsPlumb.overlays[i].cleanup();
            }

            this._jsPlumb.overlays = {};
            this._jsPlumb.overlayPositions = null;
            if (!doNotRepaint)
                this.repaint();
        },
        removeOverlay: function (overlayId, dontCleanup) {
            var o = this._jsPlumb.overlays[overlayId];
            if (o) {
                o.setVisible(false);
                if (!dontCleanup && o.cleanup) o.cleanup();
                delete this._jsPlumb.overlays[overlayId];
                if (this._jsPlumb.overlayPositions)
                    delete this._jsPlumb.overlayPositions[overlayId];
            }
        },
        removeOverlays: function () {
            for (var i = 0, j = arguments.length; i < j; i++)
                this.removeOverlay(arguments[i]);
        },
        moveParent: function (newParent) {
            if (this.bgCanvas) {
                this.bgCanvas.parentNode.removeChild(this.bgCanvas);
                newParent.appendChild(this.bgCanvas);
            }

            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
                newParent.appendChild(this.canvas);

                for (var i in this._jsPlumb.overlays) {
                    if (this._jsPlumb.overlays[i].isAppendedAtTopLevel) {
                        var el = this._jsPlumb.overlays[i].getElement();
                        el.parentNode.removeChild(el);
                        newParent.appendChild(el);
                    }
                }
            }
        },
        getLabel: function () {
            var lo = this.getOverlay(_internalLabelOverlayId);
            return lo != null ? lo.getLabel() : null;
        },
        getLabelOverlay: function () {
            return this.getOverlay(_internalLabelOverlayId);
        },
        setLabel: function (l) {
            var lo = this.getOverlay(_internalLabelOverlayId);
            if (!lo) {
                var params = l.constructor == String || l.constructor == Function ? { label: l } : l;
                lo = _makeLabelOverlay(this, params);
                this._jsPlumb.overlays[_internalLabelOverlayId] = lo;
            }
            else {
                if (l.constructor == String || l.constructor == Function) lo.setLabel(l);
                else {
                    if (l.label) lo.setLabel(l.label);
                    if (l.location) lo.setLocation(l.location);
                }
            }

            if (!this._jsPlumb.instance.isSuspendDrawing())
                this.repaint();
        },
        cleanup: function (force) {
            for (var i in this._jsPlumb.overlays) {
                this._jsPlumb.overlays[i].cleanup(force);
                this._jsPlumb.overlays[i].destroy(force);
            }
            if (force) {
                this._jsPlumb.overlays = {};
                this._jsPlumb.overlayPositions = null;
            }
        },
        setVisible: function (v) {
            this[v ? "showOverlays" : "hideOverlays"]();
        },
        setAbsoluteOverlayPosition: function (overlay, xy) {
            this._jsPlumb.overlayPositions[overlay.id] = xy;
        },
        getAbsoluteOverlayPosition: function (overlay) {
            return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[overlay.id] : null;
        },
        _clazzManip:function(action, clazz, dontUpdateOverlays) {
            if (!dontUpdateOverlays) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i][action + "Class"](clazz);
                }
            }
        },
        addClass:function(clazz, dontUpdateOverlays) {
            this._clazzManip("add", clazz, dontUpdateOverlays)
        },
        removeClass:function(clazz, dontUpdateOverlays) {
            this._clazzManip("remove", clazz, dontUpdateOverlays)
        }
    });

// ------------------------------ END OverlayCapablejsPlumbUIComponent --------------------------------------------

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Endpoints.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // create the drag handler for a connection
    var _makeConnectionDragHandler = function (endpoint, placeholder, _jsPlumb) {
        var stopped = false;
        return {
            drag: function () {
                if (stopped) {
                    stopped = false;
                    return true;
                }

                if (placeholder.element) {
                    var _ui = _jsPlumb.getUIPosition(arguments, _jsPlumb.getZoom());
                    if (_ui != null) jsPlumb.setPosition(placeholder.element, _ui);
                    _jsPlumb.repaint(placeholder.element, _ui);
                    // always repaint the source endpoint, because only continuous/dynamic anchors cause the endpoint
                    // to be repainted, so static anchors need to be told (or the endpoint gets dragged around)
                    endpoint.paint({anchorPoint:endpoint.anchor.getCurrentLocation({element:endpoint})});
                }
            },
            stopDrag: function () {
                stopped = true;
            }
        };
    };

    // creates a placeholder div for dragging purposes, adds it, and pre-computes its offset.
    var _makeDraggablePlaceholder = function (placeholder, _jsPlumb, ipco, ips) {
        var n = jsPlumb.createElement("div", { position : "absolute" });
        _jsPlumb.appendElement(n);
        var id = _jsPlumb.getId(n);
        jsPlumb.setPosition(n, ipco);
        n.style.width = ips[0] + "px";
        n.style.height = ips[1] + "px";
        _jsPlumb.manage(id, n, true); // TRANSIENT MANAGE
        // create and assign an id, and initialize the offset.
        placeholder.id = id;
        placeholder.element = n;
    };

    // create a floating endpoint (for drag connections)
    var _makeFloatingEndpoint = function (paintStyle, referenceAnchor, endpoint, referenceCanvas, sourceElement, _jsPlumb, _newEndpoint, scope) {
        var floatingAnchor = new _jp.FloatingAnchor({ reference: referenceAnchor, referenceCanvas: referenceCanvas, jsPlumbInstance: _jsPlumb });
        //setting the scope here should not be the way to fix that mootools issue.  it should be fixed by not
        // adding the floating endpoint as a droppable.  that makes more sense anyway!
        // TRANSIENT MANAGE
        return _newEndpoint({
            paintStyle: paintStyle,
            endpoint: endpoint,
            anchor: floatingAnchor,
            source: sourceElement,
            scope: scope
        });
    };

    var typeParameters = [ "connectorStyle", "connectorHoverStyle", "connectorOverlays",
        "connector", "connectionType", "connectorClass", "connectorHoverClass" ];

    // a helper function that tries to find a connection to the given element, and returns it if so. if elementWithPrecedence is null,
    // or no connection to it is found, we return the first connection in our list.
    var findConnectionToUseForDynamicAnchor = function (ep, elementWithPrecedence) {
        var idx = 0;
        if (elementWithPrecedence != null) {
            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId == elementWithPrecedence || ep.connections[i].targetId == elementWithPrecedence) {
                    idx = i;
                    break;
                }
            }
        }

        return ep.connections[idx];
    };

    _jp.Endpoint = function (params) {
        var _jsPlumb = params._jsPlumb,
            _newConnection = params.newConnection,
            _newEndpoint = params.newEndpoint;

        this.idPrefix = "_jsplumb_e_";
        this.defaultLabelLocation = [ 0.5, 0.5 ];
        this.defaultOverlayKeys = ["Overlays", "EndpointOverlays"];
        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

// TYPE

        this.appendToDefaultType({
            connectionType:params.connectionType,
            maxConnections: params.maxConnections == null ? this._jsPlumb.instance.Defaults.MaxConnections : params.maxConnections, // maximum number of connections this endpoint can be the source of.,
            paintStyle: params.endpointStyle || params.paintStyle || params.style || this._jsPlumb.instance.Defaults.EndpointStyle || _jp.Defaults.EndpointStyle,
            hoverPaintStyle: params.endpointHoverStyle || params.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || _jp.Defaults.EndpointHoverStyle,
            connectorStyle: params.connectorStyle,
            connectorHoverStyle: params.connectorHoverStyle,
            connectorClass: params.connectorClass,
            connectorHoverClass: params.connectorHoverClass,
            connectorOverlays: params.connectorOverlays,
            connector: params.connector,
            connectorTooltip: params.connectorTooltip
        });

// END TYPE

        this._jsPlumb.enabled = !(params.enabled === false);
        this._jsPlumb.visible = true;
        this.element = _jp.getElement(params.source);
        this._jsPlumb.uuid = params.uuid;
        this._jsPlumb.floatingEndpoint = null;
        var inPlaceCopy = null;
        if (this._jsPlumb.uuid) params.endpointsByUUID[this._jsPlumb.uuid] = this;
        this.elementId = params.elementId;
        this.dragProxy = params.dragProxy;

        this._jsPlumb.connectionCost = params.connectionCost;
        this._jsPlumb.connectionsDirected = params.connectionsDirected;
        this._jsPlumb.currentAnchorClass = "";
        this._jsPlumb.events = {};

        var deleteOnEmpty = params.deleteOnEmpty === true;
        this.setDeleteOnEmpty = function(d) { deleteOnEmpty = d; };

        var _updateAnchorClass = function () {
            // stash old, get new
            var oldAnchorClass = _jsPlumb.endpointAnchorClassPrefix + "-" + this._jsPlumb.currentAnchorClass;
            this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();
            var anchorClass = _jsPlumb.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");

            this.removeClass(oldAnchorClass);
            this.addClass(anchorClass);
            // add and remove at the same time to reduce the number of reflows.
            _jp.updateClasses(this.element, anchorClass, oldAnchorClass);
        }.bind(this);

        this.prepareAnchor = function(anchorParams) {
            var a = this._jsPlumb.instance.makeAnchor(anchorParams, this.elementId, _jsPlumb);
            a.bind("anchorChanged", function (currentAnchor) {
                this.fire("anchorChanged", {endpoint: this, anchor: currentAnchor});
                _updateAnchorClass();
            }.bind(this));
            return a;
        };

        this.setPreparedAnchor = function(anchor, doNotRepaint) {
            this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId);
            this.anchor = anchor;
            _updateAnchorClass();

            if (!doNotRepaint)
                this._jsPlumb.instance.repaint(this.elementId);

            return this;
        };

        this.setAnchor = function (anchorParams, doNotRepaint) {
            var a = this.prepareAnchor(anchorParams);
            this.setPreparedAnchor(a, doNotRepaint);
            return this;
        };

        var internalHover = function (state) {
            if (this.connections.length > 0) {
                for (var i = 0; i < this.connections.length; i++)
                    this.connections[i].setHover(state, false);
            }
            else
                this.setHover(state);
        }.bind(this);

        this.bind("mouseover", function () {
            internalHover(true);
        });
        this.bind("mouseout", function () {
            internalHover(false);
        });

        // ANCHOR MANAGER
        if (!params._transient) // in place copies, for example, are transient.  they will never need to be retrieved during a paint cycle, because they dont move, and then they are deleted.
            this._jsPlumb.instance.anchorManager.add(this, this.elementId);

        this.prepareEndpoint = function(ep, typeId) {
            var _e = function (t, p) {
                var rm = _jsPlumb.getRenderMode();
                if (_jp.Endpoints[rm][t]) return new _jp.Endpoints[rm][t](p);
                if (!_jsPlumb.Defaults.DoNotThrowErrors)
                    throw { msg: "jsPlumb: unknown endpoint type '" + t + "'" };
            };

            var endpointArgs = {
                _jsPlumb: this._jsPlumb.instance,
                cssClass: params.cssClass,
                container: params.container,
                tooltip: params.tooltip,
                connectorTooltip: params.connectorTooltip,
                endpoint: this
            };

            var endpoint;

            if (_ju.isString(ep))
                endpoint = _e(ep, endpointArgs);
            else if (_ju.isArray(ep)) {
                endpointArgs = _ju.merge(ep[1], endpointArgs);
                endpoint = _e(ep[0], endpointArgs);
            }
            else {
                endpoint = ep.clone();
            }

            // assign a clone function using a copy of endpointArgs. this is used when a drag starts: the endpoint that was dragged is cloned,
            // and the clone is left in its place while the original one goes off on a magical journey.
            // the copy is to get around a closure problem, in which endpointArgs ends up getting shared by
            // the whole world.
            //var argsForClone = jsPlumb.extend({}, endpointArgs);
            endpoint.clone = function () {
                // TODO this, and the code above, can be refactored to be more dry.
                if (_ju.isString(ep))
                    return _e(ep, endpointArgs);
                else if (_ju.isArray(ep)) {
                    endpointArgs = _ju.merge(ep[1], endpointArgs);
                    return _e(ep[0], endpointArgs);
                }
            }.bind(this);

            endpoint.typeId = typeId;
            return endpoint;
        };

        this.setEndpoint = function(ep, doNotRepaint) {
            var _ep = this.prepareEndpoint(ep);
            this.setPreparedEndpoint(_ep, true);
        };

        this.setPreparedEndpoint = function (ep, doNotRepaint) {
            if (this.endpoint != null) {
                this.endpoint.cleanup();
                this.endpoint.destroy();
            }
            this.endpoint = ep;
            this.type = this.endpoint.type;
            this.canvas = this.endpoint.canvas;
        };

        _jp.extend(this, params, typeParameters);

        this.isSource = params.isSource || false;
        this.isTemporarySource = params.isTemporarySource || false;
        this.isTarget = params.isTarget || false;

        this.connections = params.connections || [];
        this.connectorPointerEvents = params["connector-pointer-events"];

        this.scope = params.scope || _jsPlumb.getDefaultScope();
        this.timestamp = null;
        this.reattachConnections = params.reattach || _jsPlumb.Defaults.ReattachConnections;
        this.connectionsDetachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.connectionsDetachable === false || params.detachable === false)
            this.connectionsDetachable = false;
        this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;

        if (params.onMaxConnections)
            this.bind("maxConnections", params.onMaxConnections);

        //
        // add a connection. not part of public API.
        //
        this.addConnection = function (connection) {
            this.connections.push(connection);
            this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
            this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
        };

        this.detachFromConnection = function (connection, idx, doNotCleanup) {
            idx = idx == null ? this.connections.indexOf(connection) : idx;
            if (idx >= 0) {
                this.connections.splice(idx, 1);
                this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
                this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
            }

            //if ((this._forceDeleteOnDetach || (!doNotCleanup && this._deleteOnDetach)) && this.connections.length === 0) {
            if (!doNotCleanup && deleteOnEmpty && this.connections.length === 0) {
                _jsPlumb.deleteObject({
                    endpoint: this,
                    fireEvent: false,
                    deleteAttachedObjects: doNotCleanup !== true
                });
            }
        };

        this.deleteEveryConnection = function(params) {
            var c = this.connections.length;
            for (var i = 0; i < c; i++) {
                _jsPlumb.deleteConnection(this.connections[0], params);
            }
        };

        //this.detach = function (connection, ignoreTarget, forceDetach, fireEvent, originalEvent, endpointBeingDeleted, connectionIndex) {

//        this.detach = function (params) {
//            var connectionIndex = params.connectionIndex,
//                connection = params.connection,
//                ignoreTarget = params.ignoreTarget,
//                fireEvent = params.fireEvent,
//                originalEvent = params.originalEvent,
//                endpointBeingDeleted = params.endpointBeingDeleted,
//                forceDetach = params.forceDetach;
//
//            var idx = connectionIndex == null ? this.connections.indexOf(connection) : connectionIndex,
//                actuallyDetached = false;
//            fireEvent = (fireEvent !== false);
//
//            if (idx >= 0) {
//
//                if (forceDetach || connection._forceDetach || (connection.isDetachable() && connection.isDetachAllowed(connection) && this.isDetachAllowed(connection) && _jsPlumb.checkCondition("beforeDetach", connection, endpointBeingDeleted) )) {
//
//                    _jsPlumb.deleteObject({
//                        connection: connection,
//                        fireEvent: (!ignoreTarget && fireEvent),
//                        originalEvent: originalEvent,
//                        deleteAttachedObjects:params.deleteAttachedObjects
//                        //deleteAttachedObjects:null
//                    });
//                    actuallyDetached = true;
//                }
//            }
//            return actuallyDetached;
//        };

//        this.detachAll = function (fireEvent, forceDetach) {
//            var unaffectedConns = [];
//            while (this.connections.length > 0) {
//                // TODO this could pass the index in to the detach method to save some time (index will always be zero in this while loop)
//                var actuallyDetached = _jsPlumb.detach({
//                    connection:this.connections[0],
//                    ignoreTarget:false,
//                    forceDetach:forceDetach === true,
//                    fireEvent:fireEvent !== false,
//                    originalEvent:null,
//                    endpointBeingDeleted:this,
//                    connectionIndex:0
//                });
//                if (!actuallyDetached) {
//                    unaffectedConns.push(this.connections[0]);
//                    this.connections.splice(0, 1);
//                }
//            }
//            this.connections = unaffectedConns;
//            return this;
//        };

        this.detachFrom = function (targetEndpoint, fireEvent, originalEvent) {
            var c = [];
            for (var i = 0; i < this.connections.length; i++) {
                if (this.connections[i].endpoints[1] == targetEndpoint || this.connections[i].endpoints[0] == targetEndpoint) {
                    c.push(this.connections[i]);
                }
            }
            var count = c.length;
            for (var j = 0; j < count; j++) {
//                this.detach({
//                    connection:c[j],
//                    ignoreTarget:false,
//                    forceDetach:true,
//                    fireEvent:fireEvent,
//                    originalEvent:originalEvent
//                });
                _jsPlumb.deleteConnection(c[0]);
            }
            return this;
        };

        this.getElement = function () {
            return this.element;
        };

        this.setElement = function (el) {
            var parentId = this._jsPlumb.instance.getId(el),
                curId = this.elementId;
            // remove the endpoint from the list for the current endpoint's element
            _ju.removeWithFunction(params.endpointsByElement[this.elementId], function (e) {
                return e.id == this.id;
            }.bind(this));
            this.element = _jp.getElement(el);
            this.elementId = _jsPlumb.getId(this.element);
            _jsPlumb.anchorManager.rehomeEndpoint(this, curId, this.element);
            _jsPlumb.dragManager.endpointAdded(this.element);
            _ju.addToList(params.endpointsByElement, parentId, this);
            return this;
        };

        /**
         * private but must be exposed.
         */
        this.makeInPlaceCopy = function () {
            var loc = this.anchor.getCurrentLocation({element: this}),
                o = this.anchor.getOrientation(this),
                acc = this.anchor.getCssClass(),
                inPlaceAnchor = {
                    bind: function () {
                    },
                    compute: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getCurrentLocation: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getOrientation: function () {
                        return o;
                    },
                    getCssClass: function () {
                        return acc;
                    }
                };

            return _newEndpoint({
                dropOptions: params.dropOptions,
                anchor: inPlaceAnchor,
                source: this.element,
                paintStyle: this.getPaintStyle(),
                endpoint: params.hideOnDrag ? "Blank" : this.endpoint,
                _transient: true,
                scope: this.scope,
                reference:this
            });
        };

        /**
         * returns a connection from the pool; used when dragging starts.  just gets the head of the array if it can.
         */
        this.connectorSelector = function () {
            var candidate = this.connections[0];
            // SP target source refactor
            if (/*this.isTarget && */candidate) return candidate;
            else {
                return (this.connections.length < this._jsPlumb.maxConnections) || this._jsPlumb.maxConnections == -1 ? null : candidate;
            }
        };

        this.setStyle = this.setPaintStyle;

        this.paint = function (params) {
            params = params || {};
            var timestamp = params.timestamp, recalc = !(params.recalc === false);
            if (!timestamp || this.timestamp !== timestamp) {

                var info = _jsPlumb.updateOffset({ elId: this.elementId, timestamp: timestamp });

                var xy = params.offset ? params.offset.o : info.o;
                if (xy != null) {
                    var ap = params.anchorPoint, connectorPaintStyle = params.connectorPaintStyle;
                    if (ap == null) {
                        var wh = params.dimensions || info.s,
                            anchorParams = { xy: [ xy.left, xy.top ], wh: wh, element: this, timestamp: timestamp };
                        if (recalc && this.anchor.isDynamic && this.connections.length > 0) {
                            var c = findConnectionToUseForDynamicAnchor(this, params.elementWithPrecedence),
                                oIdx = c.endpoints[0] == this ? 1 : 0,
                                oId = oIdx === 0 ? c.sourceId : c.targetId,
                                oInfo = _jsPlumb.getCachedData(oId),
                                oOffset = oInfo.o, oWH = oInfo.s;
                            anchorParams.txy = [ oOffset.left, oOffset.top ];
                            anchorParams.twh = oWH;
                            anchorParams.tElement = c.endpoints[oIdx];
                        }
                        ap = this.anchor.compute(anchorParams);
                    }

                    this.endpoint.compute(ap, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, connectorPaintStyle || this.paintStyleInUse);
                    this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor);
                    this.timestamp = timestamp;

                    // paint overlays
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.endpoint, this._jsPlumb.paintStyleInUse);
                                o.paint(this._jsPlumb.overlayPlacements[i]);
                            }
                        }
                    }
                }
            }
        };

        this.getTypeDescriptor = function () {
            return "endpoint";
        };
        this.isVisible = function () {
            return this._jsPlumb.visible;
        };

        this.repaint = this.paint;

        var draggingInitialised = false;
        this.initDraggable = function () {

            // is this a connection source? we make it draggable and have the
            // drag listener maintain a connection with a floating endpoint.
            if (!draggingInitialised && _jp.isDragSupported(this.element)) {
                var placeholderInfo = { id: null, element: null },
                    jpc = null,
                    existingJpc = false,
                    existingJpcParams = null,
                    _dragHandler = _makeConnectionDragHandler(this, placeholderInfo, _jsPlumb),
                    dragOptions = params.dragOptions || {},
                    defaultOpts = {},
                    startEvent = _jp.dragEvents.start,
                    stopEvent = _jp.dragEvents.stop,
                    dragEvent = _jp.dragEvents.drag,
                    beforeStartEvent = _jp.dragEvents.beforeStart,
                    payload;

                // respond to beforeStart from katavorio; this will have, optionally, a payload of attribute values
                // that were placed there by the makeSource mousedown listener.
                var beforeStart = function(beforeStartParams) {
                    payload = beforeStartParams.e.payload || {};
                };

                var start = function (startParams) {

// -------------   first, get a connection to drag. this may be null, in which case we are dragging a new one.

                    jpc = this.connectorSelector();

// -------------------------------- now a bunch of tests about whether or not to proceed -------------------------

                    var _continue = true;
                    // if not enabled, return
                    if (!this.isEnabled()) _continue = false;
                    // if no connection and we're not a source - or temporarily a source, as is the case with makeSource - return.
                    if (jpc == null && !this.isSource && !this.isTemporarySource) _continue = false;
                    // otherwise if we're full and not allowed to drag, also return false.
                    if (this.isSource && this.isFull() && !(jpc != null && this.dragAllowedWhenFull)) _continue = false;
                    // if the connection was setup as not detachable or one of its endpoints
                    // was setup as connectionsDetachable = false, or Defaults.ConnectionsDetachable
                    // is set to false...
                    if (jpc != null && !jpc.isDetachable(this)) _continue = false;

                    var beforeDrag = _jsPlumb.checkCondition(jpc == null ? "beforeDrag" : "beforeStartDetach", {
                        endpoint:this,
                        source:this.element,
                        sourceId:this.elementId,
                        connection:jpc
                    });
                    if (beforeDrag === false) _continue = false;
                    // else we might have been given some data. we'll pass it in to a new connection as 'data'.
                    // here we also merge in the optional payload we were given on mousedown.
                    else if (typeof beforeDrag === "object") {
                        _jp.extend(beforeDrag, payload || {});
                    }
                    else
                        // or if no beforeDrag data, maybe use the payload on its own.
                        beforeDrag = payload || {};

                    if (_continue === false) {
                        // this is for mootools and yui. returning false from this causes jquery to stop drag.
                        // the events are wrapped in both mootools and yui anyway, but i don't think returning
                        // false from the start callback would stop a drag.
                        if (_jsPlumb.stopDrag) _jsPlumb.stopDrag(this.canvas);
                        _dragHandler.stopDrag();
                        return false;
                    }

// ---------------------------------------------------------------------------------------------------------------------

                    // ok to proceed.

                    // clear hover for all connections for this endpoint before continuing.
                    for (var i = 0; i < this.connections.length; i++)
                        this.connections[i].setHover(false);

                    this.addClass("endpointDrag");
                    _jsPlumb.setConnectionBeingDragged(true);

                    // if we're not full but there was a connection, make it null. we'll create a new one.
                    if (jpc && !this.isFull() && this.isSource) jpc = null;

                    _jsPlumb.updateOffset({ elId: this.elementId });

// ----------------    make the element we will drag around, and position it -----------------------------

                    var ipco = this._jsPlumb.instance.getOffset(this.canvas),
                        canvasElement = this.canvas,
                        ips = this._jsPlumb.instance.getSize(this.canvas);

                    _makeDraggablePlaceholder(placeholderInfo, _jsPlumb, ipco, ips);

                    // store the id of the dragging div and the source element. the drop function will pick these up.                   
                    _jsPlumb.setAttributes(this.canvas, {
                        "dragId": placeholderInfo.id,
                        "elId": this.elementId
                    });

// ------------------- create an endpoint that will be our floating endpoint ------------------------------------

                    var endpointToFloat = this.dragProxy || this.endpoint;
                    if (this.dragProxy == null && this.connectionType != null) {
                        var aae = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);
                        if (aae.endpoints[1]) endpointToFloat = aae.endpoints[1];
                    }
                    var centerAnchor = this._jsPlumb.instance.makeAnchor("Center");
                    centerAnchor.isFloating = true;
                    this._jsPlumb.floatingEndpoint = _makeFloatingEndpoint(this.getPaintStyle(), centerAnchor, endpointToFloat, this.canvas, placeholderInfo.element, _jsPlumb, _newEndpoint, this.scope);
                    var _savedAnchor = this._jsPlumb.floatingEndpoint.anchor;


                    if (jpc == null) {

                        this.setHover(false, false);
                        // create a connection. one end is this endpoint, the other is a floating endpoint.                    
                        jpc = _newConnection({
                            sourceEndpoint: this,
                            targetEndpoint: this._jsPlumb.floatingEndpoint,
                            source: this.element,  // for makeSource with parent option.  ensure source element is represented correctly.
                            target: placeholderInfo.element,
                            anchors: [ this.anchor, this._jsPlumb.floatingEndpoint.anchor ],
                            paintStyle: params.connectorStyle, // this can be null. Connection will use the default.
                            hoverPaintStyle: params.connectorHoverStyle,
                            connector: params.connector, // this can also be null. Connection will use the default.
                            overlays: params.connectorOverlays,
                            type: this.connectionType,
                            cssClass: this.connectorClass,
                            hoverClass: this.connectorHoverClass,
                            scope:params.scope,
                            data:beforeDrag
                        });
                        jpc.pending = true;
                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.anchor = _savedAnchor;
                        // fire an event that informs that a connection is being dragged
                        _jsPlumb.fire("connectionDrag", jpc);

                        // register the new connection on the drag manager. This connection, at this point, is 'pending',
                        // and has as its target a temporary element (the 'placeholder'). If the connection subsequently
                        // becomes established, the anchor manager is informed that the target of the connection has
                        // changed.

                        _jsPlumb.anchorManager.newConnection(jpc);

                    } else {
                        existingJpc = true;
                        jpc.setHover(false);
                        // new anchor idx
                        var anchorIdx = jpc.endpoints[0].id == this.id ? 0 : 1;
                        this.detachFromConnection(jpc, null, true);                         // detach from the connection while dragging is occurring. but dont cleanup automatically.

                        // store the original scope (issue 57)
                        var dragScope = _jsPlumb.getDragScope(canvasElement);
                        _jsPlumb.setAttribute(this.canvas, "originalScope", dragScope);

                        // fire an event that informs that a connection is being dragged. we do this before
                        // replacing the original target with the floating element info.
                        _jsPlumb.fire("connectionDrag", jpc);

                        // now we replace ourselves with the temporary div we created above:
                        if (anchorIdx === 0) {
                            existingJpcParams = [ jpc.source, jpc.sourceId, canvasElement, dragScope ];
                            _jsPlumb.anchorManager.sourceChanged(jpc.endpoints[anchorIdx].elementId, placeholderInfo.id, jpc, placeholderInfo.element);

                        } else {
                            existingJpcParams = [ jpc.target, jpc.targetId, canvasElement, dragScope ];
                            jpc.target = placeholderInfo.element;
                            jpc.targetId = placeholderInfo.id;

                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.endpoints[anchorIdx].elementId, jpc.targetId, jpc);
                        }

                        // store the original endpoint and assign the new floating endpoint for the drag.
                        jpc.suspendedEndpoint = jpc.endpoints[anchorIdx];

                        // PROVIDE THE SUSPENDED ELEMENT, BE IT A SOURCE OR TARGET (ISSUE 39)
                        jpc.suspendedElement = jpc.endpoints[anchorIdx].getElement();
                        jpc.suspendedElementId = jpc.endpoints[anchorIdx].elementId;
                        jpc.suspendedElementType = anchorIdx === 0 ? "source" : "target";

                        jpc.suspendedEndpoint.setHover(false);
                        this._jsPlumb.floatingEndpoint.referenceEndpoint = jpc.suspendedEndpoint;
                        jpc.endpoints[anchorIdx] = this._jsPlumb.floatingEndpoint;

                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                    }

                    // register it and register connection on it.
                    _jsPlumb.floatingConnections[placeholderInfo.id] = jpc;
                    // only register for the target endpoint; we will not be dragging the source at any time
                    // before this connection is either discarded or made into a permanent connection.
                    _ju.addToList(params.endpointsByElement, placeholderInfo.id, this._jsPlumb.floatingEndpoint);
                    // tell jsplumb about it
                    _jsPlumb.currentlyDragging = true;
                }.bind(this);

                var stop = function () {
                    _jsPlumb.setConnectionBeingDragged(false);

                    if (jpc && jpc.endpoints != null) {
                        // get the actual drop event (decode from library args to stop function)
                        var originalEvent = _jsPlumb.getDropEvent(arguments);
                        // unlock the other endpoint (if it is dynamic, it would have been locked at drag start)
                        var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
                        jpc.endpoints[idx === 0 ? 1 : 0].anchor.locked = false;
                        // TODO: Dont want to know about css classes inside jsplumb, ideally.
                        jpc.removeClass(_jsPlumb.draggingClass);

                        // if we have the floating endpoint then the connection has not been dropped
                        // on another endpoint.  If it is a new connection we throw it away. If it is an
                        // existing connection we check to see if we should reattach it, throwing it away
                        // if not.
                        if (this._jsPlumb && (jpc.deleteConnectionNow || jpc.endpoints[idx] == this._jsPlumb.floatingEndpoint)) {
                            // 6a. if the connection was an existing one...
                            if (existingJpc && jpc.suspendedEndpoint) {
                                // fix for issue35, thanks Sylvain Gizard: when firing the detach event make sure the
                                // floating endpoint has been replaced.
                                if (idx === 0) {
                                    jpc.floatingElement = jpc.source;
                                    jpc.floatingId = jpc.sourceId;
                                    jpc.floatingEndpoint = jpc.endpoints[0];
                                    jpc.floatingIndex = 0;
                                    jpc.source = existingJpcParams[0];
                                    jpc.sourceId = existingJpcParams[1];
                                } else {
                                    // keep a copy of the floating element; the anchor manager will want to clean up.
                                    jpc.floatingElement = jpc.target;
                                    jpc.floatingId = jpc.targetId;
                                    jpc.floatingEndpoint = jpc.endpoints[1];
                                    jpc.floatingIndex = 1;
                                    jpc.target = existingJpcParams[0];
                                    jpc.targetId = existingJpcParams[1];
                                }

                                var fe = this._jsPlumb.floatingEndpoint; // store for later removal.
                                // restore the original scope (issue 57)
                                _jsPlumb.setDragScope(existingJpcParams[2], existingJpcParams[3]);
                                jpc.endpoints[idx] = jpc.suspendedEndpoint;
                                // IF the connection should be reattached, or the other endpoint refuses detach, then
                                // reset the connection to its original state
                                //if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !jpc.endpoints[idx === 0 ? 1 : 0].detach({connection:jpc, ignoreTarget:false, forceDetach:false, fireEvent:true, originalEvent:originalEvent, endpointBeingDeleted:true})) {
                                if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !_jsPlumb.deleteConnection(jpc)) {

                                    jpc.setHover(false);
                                    jpc._forceDetach = null;
                                    jpc._forceReattach = null;
                                    this._jsPlumb.floatingEndpoint.detachFromConnection(jpc);
                                    jpc.suspendedEndpoint.addConnection(jpc);

                                    // TODO this code is duplicated in lots of places...and there is nothing external
                                    // in the code; it all refers to the connection itself. we could add a
                                    // `checkSanity(connection)` method to anchorManager that did this.
                                    if (idx == 1) {
                                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                                    }
                                    else {
                                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                                    }

                                    _jsPlumb.repaint(existingJpcParams[1]);
                                }
                                else {
                                    _jsPlumb.deleteObject({endpoint: fe});
                                }
                            }
                        }

                        // makeTargets sets this flag, to tell us we have been replaced and should delete this object.
                        if (this.deleteAfterDragStop) {
                            _jsPlumb.deleteObject({endpoint: this});
                        }
                        else {
                            if (this._jsPlumb) {
                                 this.paint({recalc: false});
                            }
                        }

                        // although the connection is no longer valid, there are use cases where this is useful.
                        _jsPlumb.fire("connectionDragStop", jpc, originalEvent);
                        // fire this event to give people more fine-grained control (connectionDragStop fires a lot)
                        if (jpc.pending) {
                            _jsPlumb.fire("connectionAborted", jpc, originalEvent);
                        }
                        // tell jsplumb that dragging is finished.
                        _jsPlumb.currentlyDragging = false;
                        jpc.suspendedElement = null;
                        jpc.suspendedEndpoint = null;
                        jpc = null;
                    }

                    // if no endpoints, jpc already cleaned up. but still we want to ensure we're reset properly.
                    // remove the element associated with the floating endpoint
                    // (and its associated floating endpoint and visual artefacts)
                    if (placeholderInfo && placeholderInfo.element) {
                        _jsPlumb.remove(placeholderInfo.element, false, false);
                    }
                    // remove the inplace copy
                    if (inPlaceCopy) {
                        _jsPlumb.deleteObject({endpoint: inPlaceCopy});
                    }

                    if (this._jsPlumb) {
                        // make our canvas visible (TODO: hand off to library; we should not know about DOM)
                        this.canvas.style.visibility = "visible";
                        // unlock our anchor
                        this.anchor.locked = false;
                        // clear floating anchor.
                        this._jsPlumb.floatingEndpoint = null;
                    }

                }.bind(this);

                dragOptions = _jp.extend(defaultOpts, dragOptions);
                dragOptions.scope = this.scope || dragOptions.scope;
                dragOptions[beforeStartEvent] = _ju.wrap(dragOptions[beforeStartEvent], beforeStart, false);
                dragOptions[startEvent] = _ju.wrap(dragOptions[startEvent], start, false);
                // extracted drag handler function so can be used by makeSource
                dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], _dragHandler.drag);
                dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], stop);
                dragOptions.multipleDrop = false;

                dragOptions.canDrag = function () {
                    return this.isSource || this.isTemporarySource || /*(this.isTarget && */this.connections.length > 0/*)*/;
                }.bind(this);

                _jsPlumb.initDraggable(this.canvas, dragOptions, "internal");

                this.canvas._jsPlumbRelatedElement = this.element;

                draggingInitialised = true;
            }
        };

        var ep = params.endpoint || this._jsPlumb.instance.Defaults.Endpoint || _jp.Defaults.Endpoint;
        this.setEndpoint(ep, true);
        var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : (_jsPlumb.Defaults.Anchor || "Top");
        this.setAnchor(anchorParamsToUse, true);

        // finally, set type if it was provided
        var type = [ "default", (params.type || "")].join(" ");
        this.addType(type, params.data, true);
        this.canvas = this.endpoint.canvas;
        this.canvas._jsPlumb = this;

        this.initDraggable();

        // pulled this out into a function so we can reuse it for the inPlaceCopy canvas; you can now drop detached connections
        // back onto the endpoint you detached it from.
        var _initDropTarget = function (canvas, isTransient, endpoint, referenceEndpoint) {

            if (_jp.isDropSupported(this.element)) {
                var dropOptions = params.dropOptions || _jsPlumb.Defaults.DropOptions || _jp.Defaults.DropOptions;
                dropOptions = _jp.extend({}, dropOptions);
                dropOptions.scope = dropOptions.scope || this.scope;
                var dropEvent = _jp.dragEvents.drop,
                    overEvent = _jp.dragEvents.over,
                    outEvent = _jp.dragEvents.out,
                    _ep = this,
                    drop = _jsPlumb.EndpointDropHandler({
                        getEndpoint: function () {
                            return _ep;
                        },
                        jsPlumb: _jsPlumb,
                        enabled: function () {
                            return endpoint != null ? endpoint.isEnabled() : true;
                        },
                        isFull: function () {
                            return endpoint.isFull();
                        },
                        element: this.element,
                        elementId: this.elementId,
                        isSource: this.isSource,
                        isTarget: this.isTarget,
                        addClass: function (clazz) {
                            _ep.addClass(clazz);
                        },
                        removeClass: function (clazz) {
                            _ep.removeClass(clazz);
                        },
                        isDropAllowed: function () {
                            return _ep.isDropAllowed.apply(_ep, arguments);
                        },
                        reference:referenceEndpoint,
                        isRedrop:function(jpc, dhParams) {
                            return jpc.suspendedEndpoint && dhParams.reference && (jpc.suspendedEndpoint.id === dhParams.reference.id);
                        }
                    });

                dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], drop, true);
                dropOptions[overEvent] = _ju.wrap(dropOptions[overEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = _jsPlumb.floatingConnections[id];

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        // here we should fire the 'over' event if we are a target and this is a new connection,
                        // or we are the same as the floating endpoint.
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            var bb = _jsPlumb.checkCondition("checkDropAllowed", {
                                sourceEndpoint: _jpc.endpoints[idx],
                                targetEndpoint: this,
                                connection: _jpc
                            });
                            this[(bb ? "add" : "remove") + "Class"](_jsPlumb.endpointDropAllowedClass);
                            this[(bb ? "remove" : "add") + "Class"](_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.over(this.anchor, this);
                        }
                    }
                }.bind(this));

                dropOptions[outEvent] = _ju.wrap(dropOptions[outEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = draggable == null ? null : _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = id ? _jsPlumb.floatingConnections[id] : null;

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            this.removeClass(_jsPlumb.endpointDropAllowedClass);
                            this.removeClass(_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.out();
                        }
                    }
                }.bind(this));

                _jsPlumb.initDroppable(canvas, dropOptions, "internal", isTransient);
            }
        }.bind(this);

        // Initialise the endpoint's canvas as a drop target. The drop handler will take care of the logic of whether
        // something can actually be dropped.
        if (!this.anchor.isFloating)
            _initDropTarget(this.canvas, !(params._transient || this.anchor.isFloating), this, params.reference);


        return this;
    };

    _ju.extend(_jp.Endpoint, _jp.OverlayCapableJsPlumbUIComponent, {

        setVisible: function (v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
            this._jsPlumb.visible = v;
            if (this.canvas) this.canvas.style.display = v ? "block" : "none";
            this[v ? "showOverlays" : "hideOverlays"]();
            if (!doNotChangeConnections) {
                for (var i = 0; i < this.connections.length; i++) {
                    this.connections[i].setVisible(v);
                    if (!doNotNotifyOtherEndpoint) {
                        var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
                        // only change the other endpoint if this is its only connection.
                        if (this.connections[i].endpoints[oIdx].connections.length == 1) this.connections[i].endpoints[oIdx].setVisible(v, true, true);
                    }
                }
            }
        },
        getAttachedElements: function () {
            return this.connections;
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.endpointStyle || t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle, doNotRepaint);
            if (t.maxConnections != null) this._jsPlumb.maxConnections = t.maxConnections;
            if (t.scope) this.scope = t.scope;
            _jp.extend(this, t, typeParameters);
            if (t.cssClass != null && this.canvas) this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        isEnabled: function () {
            return this._jsPlumb.enabled;
        },
        setEnabled: function (e) {
            this._jsPlumb.enabled = e;
        },
        cleanup: function () {
            var anchorClass = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
            _jp.removeClass(this.element, anchorClass);
            this.anchor = null;
            this.endpoint.cleanup(true);
            this.endpoint.destroy();
            this.endpoint = null;
            // drag/drop
            this._jsPlumb.instance.destroyDraggable(this.canvas, "internal");
            this._jsPlumb.instance.destroyDroppable(this.canvas, "internal");
        },
        setHover: function (h) {
            if (this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged())
                this.endpoint.setHover(h);
        },
        isFull: function () {
            return this._jsPlumb.maxConnections === 0 ? true : !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections);
        },
        /**
         * private but needs to be exposed.
         */
        isFloating: function () {
            return this.anchor != null && this.anchor.isFloating;
        },
        isConnectedTo: function (endpoint) {
            var found = false;
            if (endpoint) {
                for (var i = 0; i < this.connections.length; i++) {
                    if (this.connections[i].endpoints[1] == endpoint || this.connections[i].endpoints[0] == endpoint) {
                        found = true;
                        break;
                    }
                }
            }
            return found;
        },
        getConnectionCost: function () {
            return this._jsPlumb.connectionCost;
        },
        setConnectionCost: function (c) {
            this._jsPlumb.connectionCost = c;
        },
        areConnectionsDirected: function () {
            return this._jsPlumb.connectionsDirected;
        },
        setConnectionsDirected: function (b) {
            this._jsPlumb.connectionsDirected = b;
        },
        setElementId: function (_elId) {
            this.elementId = _elId;
            this.anchor.elementId = _elId;
        },
        setReferenceElement: function (_el) {
            this.element = _jp.getElement(_el);
        },
        setDragAllowedWhenFull: function (allowed) {
            this.dragAllowedWhenFull = allowed;
        },
        equals: function (endpoint) {
            return this.anchor.equals(endpoint.anchor);
        },
        getUuid: function () {
            return this._jsPlumb.uuid;
        },
        computeAnchor: function (params) {
            return this.anchor.compute(params);
        }
    });

    root.jsPlumbInstance.prototype.EndpointDropHandler = function (dhParams) {
        return function (e) {

            var _jsPlumb = dhParams.jsPlumb;

            // remove the classes that are added dynamically. drop is neither forbidden nor allowed now that
            // the drop is finishing.
            dhParams.removeClass(_jsPlumb.endpointDropAllowedClass);
            dhParams.removeClass(_jsPlumb.endpointDropForbiddenClass);

            var originalEvent = _jsPlumb.getDropEvent(arguments),
                draggable = _jsPlumb.getDragObject(arguments),
                id = _jsPlumb.getAttribute(draggable, "dragId"),
                elId = _jsPlumb.getAttribute(draggable, "elId"),
                scope = _jsPlumb.getAttribute(draggable, "originalScope"),
                jpc = _jsPlumb.floatingConnections[id];

            // if no active connection, bail.
            if (jpc == null) return;

            // calculate if this is an existing connection.
            var existingConnection = jpc.suspendedEndpoint != null;

            // if suspended endpoint exists but has been cleaned up, bail. This means it's an existing connection
            // that has been detached and will shortly be discarded.
            if (existingConnection && jpc.suspendedEndpoint._jsPlumb == null) return;

            // get the drop endpoint. for a normal connection this is just the one that would replace the currently
            // floating endpoint. for a makeTarget this is a new endpoint that is created on drop. But we leave that to
            // the handler to figure out.
            var _ep = dhParams.getEndpoint(jpc);

            // If we're not given an endpoint to use, bail.
            if (_ep == null) return;

            // if this is a drop back where the connection came from, mark it force reattach and
            // return; the stop handler will reattach. without firing an event.
            if (dhParams.isRedrop(jpc, dhParams)) {
                jpc._forceReattach = true;
                jpc.setHover(false);
                if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);
                return;
            }

            // ensure we dont bother trying to drop sources on non-source eps, and same for target.
            var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
            if ((idx === 0 && !dhParams.isSource)|| (idx === 1 && !dhParams.isTarget)){
                if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);
                return;
            }

            if (dhParams.onDrop) dhParams.onDrop(jpc);

            // restore the original scope if necessary (issue 57)
            if (scope) _jsPlumb.setDragScope(draggable, scope);

            // if the target of the drop is full, fire an event (we abort below)
            // makeTarget: keep.
            var isFull = dhParams.isFull(e);
            if (isFull) {
                _ep.fire("maxConnections", {
                    endpoint: this,
                    connection: jpc,
                    maxConnections: _ep._jsPlumb.maxConnections
                }, originalEvent);
            }
            //
            // if endpoint enabled, not full, and matches the index of the floating endpoint...
            if (!isFull &&  dhParams.enabled()) {
                var _doContinue = true;

                // before testing for beforeDrop, reset the connection's source/target to be the actual DOM elements
                // involved (that is, stash any temporary stuff used for dragging. but we need to keep it around in
                // order that the anchor manager can clean things up properly).
                if (idx === 0) {
                    jpc.floatingElement = jpc.source;
                    jpc.floatingId = jpc.sourceId;
                    jpc.floatingEndpoint = jpc.endpoints[0];
                    jpc.floatingIndex = 0;
                    jpc.source = dhParams.element;
                    jpc.sourceId = dhParams.elementId;
                } else {
                    jpc.floatingElement = jpc.target;
                    jpc.floatingId = jpc.targetId;
                    jpc.floatingEndpoint = jpc.endpoints[1];
                    jpc.floatingIndex = 1;
                    jpc.target = dhParams.element;
                    jpc.targetId = dhParams.elementId;
                }

                // if this is an existing connection and detach is not allowed we won't continue. The connection's
                // endpoints have been reinstated; everything is back to how it was.
                if (existingConnection && jpc.suspendedEndpoint.id != _ep.id) {

                    if (!jpc.isDetachAllowed(jpc) || !jpc.endpoints[idx].isDetachAllowed(jpc) || !jpc.suspendedEndpoint.isDetachAllowed(jpc) || !_jsPlumb.checkCondition("beforeDetach", jpc))
                        _doContinue = false;
                }

// ------------ wrap the execution path in a function so we can support asynchronous beforeDrop

                var continueFunction = function (optionalData) {
                    // remove this jpc from the current endpoint, which is a floating endpoint that we will
                    // subsequently discard.
                    jpc.endpoints[idx].detachFromConnection(jpc);

                    // if there's a suspended endpoint, detach it from the connection.
                    if (jpc.suspendedEndpoint) jpc.suspendedEndpoint.detachFromConnection(jpc);

                    jpc.endpoints[idx] = _ep;
                    _ep.addConnection(jpc);

                    // copy our parameters in to the connection:
                    var params = _ep.getParameters();
                    for (var aParam in params)
                        jpc.setParameter(aParam, params[aParam]);

                    if (!existingConnection) {
                        // if not an existing connection and
                        if (params.draggable)
                            _jsPlumb.initDraggable(this.element, dragOptions, "internal", _jsPlumb);
                    }
                    else {
                        var suspendedElementId = jpc.suspendedEndpoint.elementId;
                        _jsPlumb.fireMoveEvent({
                            index: idx,
                            originalSourceId: idx === 0 ? suspendedElementId : jpc.sourceId,
                            newSourceId: idx === 0 ? _ep.elementId : jpc.sourceId,
                            originalTargetId: idx == 1 ? suspendedElementId : jpc.targetId,
                            newTargetId: idx == 1 ? _ep.elementId : jpc.targetId,
                            originalSourceEndpoint: idx === 0 ? jpc.suspendedEndpoint : jpc.endpoints[0],
                            newSourceEndpoint: idx === 0 ? _ep : jpc.endpoints[0],
                            originalTargetEndpoint: idx == 1 ? jpc.suspendedEndpoint : jpc.endpoints[1],
                            newTargetEndpoint: idx == 1 ? _ep : jpc.endpoints[1],
                            connection: jpc
                        }, originalEvent);
                    }

                    if (idx == 1) {
                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                    }
                    else {
                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                    }

                    // when makeSource has uniqueEndpoint:true, we want to create connections with new endpoints
                    // that are subsequently deleted. So makeSource sets `finalEndpoint`, which is the Endpoint to
                    // which the connection should be attached. The `detachFromConnection` call below results in the
                    // temporary endpoint being cleaned up.
                    if (jpc.endpoints[0].finalEndpoint) {
                        var _toDelete = jpc.endpoints[0];
                        _toDelete.detachFromConnection(jpc);
                        jpc.endpoints[0] = jpc.endpoints[0].finalEndpoint;
                        jpc.endpoints[0].addConnection(jpc);
                    }

                    // if optionalData was given, merge it onto the connection's data.
                    if (_ju.isObject(optionalData)) {
                        jpc.mergeData(optionalData);
                    }
                    // finalise will inform the anchor manager and also add to
                    // connectionsByScope if necessary.
                    _jsPlumb.finaliseConnection(jpc, null, originalEvent, false);
                    jpc.setHover(false);

                }.bind(this);

                var dontContinueFunction = function () {
                    // otherwise just put it back on the endpoint it was on before the drag.
                    if (jpc.suspendedEndpoint) {
                        jpc.endpoints[idx] = jpc.suspendedEndpoint;
                        jpc.setHover(false);
                        jpc._forceDetach = true;
                        if (idx === 0) {
                            jpc.source = jpc.suspendedEndpoint.element;
                            jpc.sourceId = jpc.suspendedEndpoint.elementId;
                        } else {
                            jpc.target = jpc.suspendedEndpoint.element;
                            jpc.targetId = jpc.suspendedEndpoint.elementId;
                        }
                        jpc.suspendedEndpoint.addConnection(jpc);

                        // TODO checkSanity
                        if (idx == 1) {
                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                        }
                        else {
                            _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                        }

                        _jsPlumb.repaint(jpc.sourceId);
                        jpc._forceDetach = false;
                    }
                };

// --------------------------------------
                // now check beforeDrop.  this will be available only on Endpoints that are setup to
                // have a beforeDrop condition (although, secretly, under the hood all Endpoints and
                // the Connection have them, because they are on jsPlumbUIComponent.  shhh!), because
                // it only makes sense to have it on a target endpoint.
                _doContinue = _doContinue && dhParams.isDropAllowed(jpc.sourceId, jpc.targetId, jpc.scope, jpc, _ep);// && jpc.pending;

                if (_doContinue) {
                    continueFunction(_doContinue);
                    return true;
                }
                else {
                    dontContinueFunction();
                }
            }

            if (dhParams.maybeCleanup) dhParams.maybeCleanup(_ep);

            _jsPlumb.currentlyDragging = false;
        };
    };
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Connections.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this,
        _jp = root.jsPlumb,
        _ju = root.jsPlumbUtil;

    var makeConnector = function (_jsPlumb, renderMode, connectorName, connectorArgs, forComponent) {
            if (!_jsPlumb.Defaults.DoNotThrowErrors && _jp.Connectors[renderMode][connectorName] == null)
                throw { msg: "jsPlumb: unknown connector type '" + connectorName + "'" };

            return new _jp.Connectors[renderMode][connectorName](connectorArgs, forComponent);
        },
        _makeAnchor = function (anchorParams, elementId, _jsPlumb) {
            return (anchorParams) ? _jsPlumb.makeAnchor(anchorParams, elementId, _jsPlumb) : null;
        },
        _updateConnectedClass = function (conn, element, _jsPlumb, remove) {
            if (element != null) {
                element._jsPlumbConnections = element._jsPlumbConnections || {};
                if (remove)
                    delete element._jsPlumbConnections[conn.id];
                else
                    element._jsPlumbConnections[conn.id] = true;

                if (_ju.isEmpty(element._jsPlumbConnections)) {
                    _jsPlumb.removeClass(element, _jsPlumb.connectedClass);
                }
                else
                    _jsPlumb.addClass(element, _jsPlumb.connectedClass);
            }
        };

    _jp.Connection = function (params) {
        var _newEndpoint = params.newEndpoint;

        this.id = params.id;
        this.connector = null;
        this.idPrefix = "_jsplumb_c_";
        this.defaultLabelLocation = 0.5;
        this.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"];
        // if a new connection is the result of moving some existing connection, params.previousConnection
        // will have that Connection in it. listeners for the jsPlumbConnection event can look for that
        // member and take action if they need to.
        this.previousConnection = params.previousConnection;
        this.source = _jp.getElement(params.source);
        this.target = _jp.getElement(params.target);
        // sourceEndpoint and targetEndpoint override source/target, if they are present. but 
        // source is not overridden if the Endpoint has declared it is not the final target of a connection;
        // instead we use the source that the Endpoint declares will be the final source element.
        if (params.sourceEndpoint) this.source = params.sourceEndpoint.getElement();
        if (params.targetEndpoint) this.target = params.targetEndpoint.getElement();

        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

        this.sourceId = this._jsPlumb.instance.getId(this.source);
        this.targetId = this._jsPlumb.instance.getId(this.target);
        this.scope = params.scope; // scope may have been passed in to the connect call. if it wasn't, we will pull it from the source endpoint, after having initialised the endpoints.            
        this.endpoints = [];
        this.endpointStyles = [];

        var _jsPlumb = this._jsPlumb.instance;

        _jsPlumb.manage(this.sourceId, this.source);
        _jsPlumb.manage(this.targetId, this.target);

        this._jsPlumb.visible = true;
        this._jsPlumb.editable = params.editable === true;
        this._jsPlumb.params = {
            cssClass: params.cssClass,
            container: params.container,
            "pointer-events": params["pointer-events"],
            editorParams: params.editorParams,
            overlays: params.overlays
        };
        this._jsPlumb.lastPaintedAt = null;

        // listen to mouseover and mouseout events passed from the container delegate.
        this.bind("mouseover", function () {
            this.setHover(true);
        }.bind(this));
        this.bind("mouseout", function () {
            this.setHover(false);
        }.bind(this));

        this.editableRequested = params.editable !== false;
        this.setEditable = function(e) {
            return this.connector ? this.connector.setEditable(e) : false;
        };
        this.isEditable = function() { return this.connector ? this.connector.isEditable() : false; };
        this.isEditing = function() { return this.connector ? this.connector.isEditing() : false; };

// INITIALISATION CODE

        this.makeEndpoint = function (isSource, el, elId, ep) {
            elId = elId || this._jsPlumb.instance.getId(el);
            return this.prepareEndpoint(_jsPlumb, _newEndpoint, this, ep, isSource ? 0 : 1, params, el, elId);
        };

        // if type given, get the endpoint definitions mapping to that type from the jsplumb instance, and use those.
        // we apply types at the end of this constructor but endpoints are only honoured in a type definition at
        // create time.
        if (params.type) {
            params.endpoints = params.endpoints || this._jsPlumb.instance.deriveEndpointAndAnchorSpec(params.type).endpoints;
        }

        var eS = this.makeEndpoint(true, this.source, this.sourceId, params.sourceEndpoint),
            eT = this.makeEndpoint(false, this.target, this.targetId, params.targetEndpoint);

        if (eS) _ju.addToList(params.endpointsByElement, this.sourceId, eS);
        if (eT) _ju.addToList(params.endpointsByElement, this.targetId, eT);
        // if scope not set, set it to be the scope for the source endpoint.
        if (!this.scope) this.scope = this.endpoints[0].scope;

        // if explicitly told to (or not to) delete endpoints when empty, override endpoint's preferences
        if (params.deleteEndpointsOnEmpty != null) {
            this.endpoints[0].setDeleteOnEmpty(params.deleteEndpointsOnEmpty);
            this.endpoints[1].setDeleteOnEmpty(params.deleteEndpointsOnEmpty);
        }
//        else {
//            // otherwise, unless the endpoints say otherwise, mark them for deletion.
//            if (!this.endpoints[0]._doNotDeleteOnDetach) this.endpoints[0]._deleteOnDetach = true;
//            if (!this.endpoints[1]._doNotDeleteOnDetach) this.endpoints[1]._deleteOnDetach = true;
//        }

// -------------------------- DEFAULT TYPE ---------------------------------------------

        // DETACHABLE
        var _detachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.detachable === false) _detachable = false;
        if (this.endpoints[0].connectionsDetachable === false) _detachable = false;
        if (this.endpoints[1].connectionsDetachable === false) _detachable = false;
        // REATTACH
        var _reattach = params.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || _jsPlumb.Defaults.ReattachConnections;

        this.appendToDefaultType({
            detachable: _detachable,
            reattach: _reattach,
            paintStyle:this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || params.paintStyle || _jsPlumb.Defaults.PaintStyle || _jp.Defaults.PaintStyle,
            hoverPaintStyle:this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _jsPlumb.Defaults.HoverPaintStyle || _jp.Defaults.HoverPaintStyle
        });


        var _suspendedAt = _jsPlumb.getSuspendedAt();
        if (!_jsPlumb.isSuspendDrawing()) {
            // paint the endpoints
            var myInfo = _jsPlumb.getCachedData(this.sourceId),
                myOffset = myInfo.o, myWH = myInfo.s,
                otherInfo = _jsPlumb.getCachedData(this.targetId),
                otherOffset = otherInfo.o,
                otherWH = otherInfo.s,
                initialTimestamp = _suspendedAt || _jsPlumb.timestamp(),
                anchorLoc = this.endpoints[0].anchor.compute({
                    xy: [ myOffset.left, myOffset.top ], wh: myWH, element: this.endpoints[0],
                    elementId: this.endpoints[0].elementId,
                    txy: [ otherOffset.left, otherOffset.top ], twh: otherWH, tElement: this.endpoints[1],
                    timestamp: initialTimestamp
                });

            this.endpoints[0].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });

            anchorLoc = this.endpoints[1].anchor.compute({
                xy: [ otherOffset.left, otherOffset.top ], wh: otherWH, element: this.endpoints[1],
                elementId: this.endpoints[1].elementId,
                txy: [ myOffset.left, myOffset.top ], twh: myWH, tElement: this.endpoints[0],
                timestamp: initialTimestamp
            });
            this.endpoints[1].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });
        }

        this.getTypeDescriptor = function () {
            return "connection";
        };
        this.getAttachedElements = function () {
            return this.endpoints;
        };

        this.isDetachable = function () {
            return this._jsPlumb.detachable === true;
        };
        this.setDetachable = function (detachable) {
            this._jsPlumb.detachable = detachable === true;
        };
        this.isReattach = function () {
            return this._jsPlumb.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
        };
        this.setReattach = function (reattach) {
            this._jsPlumb.reattach = reattach === true;
        };

//        this["delete"] = function() {
//            this.endpoints[0].detachFromConnection(this);
//            this.endpoints[1].detachFromConnection(this);
//            params.deleteConnection(this);
//        };

// END INITIALISATION CODE


// COST + DIRECTIONALITY
        // if cost not supplied, try to inherit from source endpoint
        this._jsPlumb.cost = params.cost || this.endpoints[0].getConnectionCost();
        this._jsPlumb.directed = params.directed;
        // inherit directed flag if set no source endpoint
        if (params.directed == null) this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected();
// END COST + DIRECTIONALITY

// PARAMETERS
        // merge all the parameters objects into the connection.  parameters set
        // on the connection take precedence; then source endpoint params, then
        // finally target endpoint params.
        var _p = _jp.extend({}, this.endpoints[1].getParameters());
        _jp.extend(_p, this.endpoints[0].getParameters());
        _jp.extend(_p, this.getParameters());
        this.setParameters(_p);
// END PARAMETERS

// PAINTING

        this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || params.connector || _jsPlumb.Defaults.Connector || _jp.Defaults.Connector, true);
        if (params.geometry) {
            this.connector.setGeometry(params.geometry);
        }
        var data = params.data == null || !_ju.isObject(params.data) ? {} : params.data;
        this.getData = function() { return data; };
        this.setData = function(d) { data = d || {}; };
        this.mergeData = function(d) { data = _jp.extend(data, d); };

        // the very last thing we do is apply types, if there are any.
        var _types = [ "default", this.endpoints[0].connectionType, this.endpoints[1].connectionType,  params.type ].join(" ");
        if (/[^\s]/.test(_types))
            this.addType(_types, params.data, true);

        this.updateConnectedClass();

// END PAINTING    
    };

    _ju.extend(_jp.Connection, _jp.OverlayCapableJsPlumbUIComponent, {
        applyType: function (t, doNotRepaint, typeMap) {

            // none of these things result in the creation of objects so can be ignored.
            if (t.detachable != null) this.setDetachable(t.detachable);
            if (t.reattach != null) this.setReattach(t.reattach);
            if (t.scope) this.scope = t.scope;

            if (t.cssClass != null && this.canvas) this._jsPlumb.instance.addClass(this.canvas, t.cssClass);

            var _anchors = null;
            // this also results in the creation of objects.
            if (t.anchor) {
                // note that even if the param was anchor, we store `anchors`.
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchor);
                if (_anchors == null) {
                    _anchors = [ this._jsPlumb.instance.makeAnchor(t.anchor), this._jsPlumb.instance.makeAnchor(t.anchor) ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchor);
                }
            }
            else if (t.anchors) {
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchors);
                if (_anchors == null) {
                    _anchors = [
                        this._jsPlumb.instance.makeAnchor(t.anchors[0]),
                        this._jsPlumb.instance.makeAnchor(t.anchors[1])
                    ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchors);
                }
            }
            if (_anchors != null) {
                this.endpoints[0].anchor = _anchors[0];
                this.endpoints[1].anchor = _anchors[1];
                if (this.endpoints[1].anchor.isDynamic) this._jsPlumb.instance.repaint(this.endpoints[1].elementId);
            }

            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        addClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].addClass(c);
                this.endpoints[1].addClass(c);
                if (this.suspendedEndpoint) this.suspendedEndpoint.addClass(c);
            }
            if (this.connector) {
                this.connector.addClass(c);
            }
        },
        removeClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].removeClass(c);
                this.endpoints[1].removeClass(c);
                if (this.suspendedEndpoint) this.suspendedEndpoint.removeClass(c);
            }
            if (this.connector) {
                this.connector.removeClass(c);
            }
        },
        isVisible: function () {
            return this._jsPlumb.visible;
        },
        setVisible: function (v) {
            this._jsPlumb.visible = v;
            if (this.connector)
                this.connector.setVisible(v);
            this.repaint();
        },
        cleanup: function () {
            this.updateConnectedClass(true);
            this.endpoints = null;
            this.source = null;
            this.target = null;
            if (this.connector != null) {
                this.connector.cleanup(true);
                this.connector.destroy(true);
            }
            this.connector = null;
        },
        updateConnectedClass:function(remove) {
            if (this._jsPlumb) {
                _updateConnectedClass(this, this.source, this._jsPlumb.instance, remove);
                _updateConnectedClass(this, this.target, this._jsPlumb.instance, remove);
            }
        },
        setHover: function (state) {
            if (this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                this.connector.setHover(state);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.source, this._jsPlumb.instance.hoverSourceClass);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.target, this._jsPlumb.instance.hoverTargetClass);
            }
        },
        getUuids:function() {
            return [ this.endpoints[0].getUuid(), this.endpoints[1].getUuid() ];
        },
        getCost: function () {
            return this._jsPlumb ? this._jsPlumb.cost : -Infinity;
        },
        setCost: function (c) {
            this._jsPlumb.cost = c;
        },
        isDirected: function () {
            return this._jsPlumb.directed === true;
        },
        getConnector: function () {
            return this.connector;
        },
        getGeometry : function() { return this.connector ? this.connector.getGeometry() : null; },
        setGeometry : function(g) { if (this.connector) this.connector.setGeometry(g); },
        prepareConnector:function(connectorSpec, typeId) {
            var connectorArgs = {
                    _jsPlumb: this._jsPlumb.instance,
                    cssClass: (this._jsPlumb.params.cssClass || "") + (this.isEditable() ? this._jsPlumb.instance.editableConnectorClass : ""),
                    container: this._jsPlumb.params.container,
                    "pointer-events": this._jsPlumb.params["pointer-events"],
                    editable:this.editableRequested
                },
                renderMode = this._jsPlumb.instance.getRenderMode(),
                connector;

            if (_ju.isString(connectorSpec))
                connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec, connectorArgs, this); // lets you use a string as shorthand.
            else if (_ju.isArray(connectorSpec)) {
                if (connectorSpec.length == 1)
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], connectorArgs, this);
                else
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], _ju.merge(connectorSpec[1], connectorArgs), this);
            }
            if (typeId != null) connector.typeId = typeId;
            return connector;
        },
        setPreparedConnector: function(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {

            var previous, previousClasses = "";
            // the connector will not be cleaned up if it was set as part of a type, because `typeId` will be set on it
            // and we havent passed in `true` for "force" here.
            if (this.connector != null) {
                previous = this.connector;
                previousClasses = previous.getClass();
                this.connector.cleanup();
                this.connector.destroy();
            }

            this.connector = connector;
            if (typeId) {
                this.cacheTypeItem("connector", connector, typeId);
            }

            this.canvas = this.connector.canvas;
            this.bgCanvas = this.connector.bgCanvas;

            // put classes from prior connector onto the canvas
            this.addClass(previousClasses);

            // new: instead of binding listeners per connector, we now just have one delegate on the container.
            // so for that handler we set the connection as the '_jsPlumb' member of the canvas element, and
            // bgCanvas, if it exists, which it does right now in the VML renderer, so it won't from v 2.0.0 onwards.
            if (this.canvas) this.canvas._jsPlumb = this;
            if (this.bgCanvas) this.bgCanvas._jsPlumb = this;

            if (previous != null) {
                var o = this.getOverlays();
                for (var i = 0; i < o.length; i++) {
                    if (o[i].transfer) o[i].transfer(this.connector);
                }
            }

            if (!doNotChangeListenerComponent) this.setListenerComponent(this.connector);
            if (!doNotRepaint) this.repaint();
        },
        setConnector: function (connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
            var connector = this.prepareConnector(connectorSpec, typeId);
            this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
        },
        paint: function (params) {

            if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
                params = params || {};
                var timestamp = params.timestamp,
                // if the moving object is not the source we must transpose the two references.
                    swap = false,
                    tId = swap ? this.sourceId : this.targetId, sId = swap ? this.targetId : this.sourceId,
                    tIdx = swap ? 0 : 1, sIdx = swap ? 1 : 0;

                if (timestamp == null || timestamp != this._jsPlumb.lastPaintedAt) {
                    var sourceInfo = this._jsPlumb.instance.updateOffset({elId:sId}).o,
                        targetInfo = this._jsPlumb.instance.updateOffset({elId:tId}).o,
                        sE = this.endpoints[sIdx], tE = this.endpoints[tIdx];

                    var sAnchorP = sE.anchor.getCurrentLocation({xy: [sourceInfo.left, sourceInfo.top], wh: [sourceInfo.width, sourceInfo.height], element: sE, timestamp: timestamp}),
                        tAnchorP = tE.anchor.getCurrentLocation({xy: [targetInfo.left, targetInfo.top], wh: [targetInfo.width, targetInfo.height], element: tE, timestamp: timestamp});

                    this.connector.resetBounds();

                    this.connector.compute({
                        sourcePos: sAnchorP,
                        targetPos: tAnchorP,
                        sourceEndpoint: this.endpoints[sIdx],
                        targetEndpoint: this.endpoints[tIdx],
                        "stroke-width": this._jsPlumb.paintStyleInUse.strokeWidth,
                        sourceInfo: sourceInfo,
                        targetInfo: targetInfo
                    });

                    var overlayExtents = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

                    // compute overlays. we do this first so we can get their placements, and adjust the
                    // container if needs be (if an overlay would be clipped)
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(o));
                                overlayExtents.minX = Math.min(overlayExtents.minX, this._jsPlumb.overlayPlacements[i].minX);
                                overlayExtents.maxX = Math.max(overlayExtents.maxX, this._jsPlumb.overlayPlacements[i].maxX);
                                overlayExtents.minY = Math.min(overlayExtents.minY, this._jsPlumb.overlayPlacements[i].minY);
                                overlayExtents.maxY = Math.max(overlayExtents.maxY, this._jsPlumb.overlayPlacements[i].maxY);
                            }
                        }
                    }

                    var lineWidth = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 1) / 2,
                        outlineWidth = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 0),
                        extents = {
                            xmin: Math.min(this.connector.bounds.minX - (lineWidth + outlineWidth), overlayExtents.minX),
                            ymin: Math.min(this.connector.bounds.minY - (lineWidth + outlineWidth), overlayExtents.minY),
                            xmax: Math.max(this.connector.bounds.maxX + (lineWidth + outlineWidth), overlayExtents.maxX),
                            ymax: Math.max(this.connector.bounds.maxY + (lineWidth + outlineWidth), overlayExtents.maxY)
                        };
                    // paint the connector.
                    this.connector.paint(this._jsPlumb.paintStyleInUse, null, extents);
                    // and then the overlays
                    for (var j in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(j)) {
                            var p = this._jsPlumb.overlays[j];
                            if (p.isVisible()) {
                                p.paint(this._jsPlumb.overlayPlacements[j], extents);
                            }
                        }
                    }
                }
                this._jsPlumb.lastPaintedAt = timestamp;
            }
        },
        repaint: function (params) {
            params = params || {};
            this.paint({ elId: this.sourceId, recalc: !(params.recalc === false), timestamp: params.timestamp});
        },
        prepareEndpoint: function (_jsPlumb, _newEndpoint, conn, existing, index, params, element, elementId) {
            var e;
            if (existing) {
                conn.endpoints[index] = existing;
                existing.addConnection(conn);
            } else {
                if (!params.endpoints) params.endpoints = [ null, null ];
                var ep = params.endpoints[index] || params.endpoint || _jsPlumb.Defaults.Endpoints[index] || _jp.Defaults.Endpoints[index] || _jsPlumb.Defaults.Endpoint || _jp.Defaults.Endpoint;
                if (!params.endpointStyles) params.endpointStyles = [ null, null ];
                if (!params.endpointHoverStyles) params.endpointHoverStyles = [ null, null ];
                var es = params.endpointStyles[index] || params.endpointStyle || _jsPlumb.Defaults.EndpointStyles[index] || _jp.Defaults.EndpointStyles[index] || _jsPlumb.Defaults.EndpointStyle || _jp.Defaults.EndpointStyle;
                // Endpoints derive their fill from the connector's stroke, if no fill was specified.
                if (es.fill == null && params.paintStyle != null)
                    es.fill = params.paintStyle.stroke;

                if (es.outlineStroke == null && params.paintStyle != null)
                    es.outlineStroke = params.paintStyle.outlineStroke;
                if (es.outlineWidth == null && params.paintStyle != null)
                    es.outlineWidth = params.paintStyle.outlineWidth;

                var ehs = params.endpointHoverStyles[index] || params.endpointHoverStyle || _jsPlumb.Defaults.EndpointHoverStyles[index] || _jp.Defaults.EndpointHoverStyles[index] || _jsPlumb.Defaults.EndpointHoverStyle || _jp.Defaults.EndpointHoverStyle;
                // endpoint hover fill style is derived from connector's hover stroke style
                if (params.hoverPaintStyle != null) {
                    if (ehs == null) ehs = {};
                    if (ehs.fill == null) {
                        ehs.fill = params.hoverPaintStyle.stroke;
                    }
                }
                var a = params.anchors ? params.anchors[index] :
                        params.anchor ? params.anchor :
                            _makeAnchor(_jsPlumb.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jsPlumb.Defaults.Anchor, elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchor, elementId, _jsPlumb),
                    u = params.uuids ? params.uuids[index] : null;

                e = _newEndpoint({
                    paintStyle: es, hoverPaintStyle: ehs, endpoint: ep, connections: [ conn ],
                    uuid: u, anchor: a, source: element, scope: params.scope,
                    reattach: params.reattach || _jsPlumb.Defaults.ReattachConnections,
                    detachable: params.detachable || _jsPlumb.Defaults.ConnectionsDetachable
                });
                if (existing == null) {
                    e.setDeleteOnEmpty(true);
                }
                conn.endpoints[index] = e;

                if (params.drawEndpoints === false) e.setVisible(false, true, true);

            }
            return e;
        }

    }); // END Connection class            
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for creating and manipulating anchors.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";

    var root = this,
        _ju = root.jsPlumbUtil,
        _jp = root.jsPlumb;

    //
    // manages anchors for all elements.
    //
    _jp.AnchorManager = function (params) {
        var _amEndpoints = {},
            continuousAnchorLocations = {},
            userDefinedContinuousAnchorLocations = {},
            continuousAnchorOrientations = {},
            Orientation = { HORIZONTAL: "horizontal", VERTICAL: "vertical", DIAGONAL: "diagonal", IDENTITY: "identity" },
            axes = ["left", "top", "right", "bottom"],
            connectionsByElementId = {},
            self = this,
            anchorLists = {},
            jsPlumbInstance = params.jsPlumbInstance,
            floatingConnections = {},
            calculateOrientation = function (sourceId, targetId, sd, td, sourceAnchor, targetAnchor) {

                if (sourceId === targetId) return {
                    orientation: Orientation.IDENTITY,
                    a: ["top", "top"]
                };

                var theta = Math.atan2((td.centery - sd.centery), (td.centerx - sd.centerx)),
                    theta2 = Math.atan2((sd.centery - td.centery), (sd.centerx - td.centerx));

// --------------------------------------------------------------------------------------

                // improved face calculation. get midpoints of each face for source and target, then put in an array with all combinations of
                // source/target faces. sort this array by distance between midpoints. the entry at index 0 is our preferred option. we can
                // go through the array one by one until we find an entry in which each requested face is supported.
                var candidates = [], midpoints = { };
                (function (types, dim) {
                    for (var i = 0; i < types.length; i++) {
                        midpoints[types[i]] = {
                            "left": [ dim[i].left, dim[i].centery ],
                            "right": [ dim[i].right, dim[i].centery ],
                            "top": [ dim[i].centerx, dim[i].top ],
                            "bottom": [ dim[i].centerx , dim[i].bottom]
                        };
                    }
                })([ "source", "target" ], [ sd, td ]);

                for (var sf = 0; sf < axes.length; sf++) {
                    for (var tf = 0; tf < axes.length; tf++) {
                        candidates.push({
                            source: axes[sf],
                            target: axes[tf],
                            dist: Biltong.lineLength(midpoints.source[axes[sf]], midpoints.target[axes[tf]])
                        });
                    }
                }

                candidates.sort(function (a, b) {
                    return a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0;
                });

                // now go through this list and try to get an entry that satisfies both (there will be one, unless one of the anchors
                // declares no available faces)
                var sourceEdge = candidates[0].source, targetEdge = candidates[0].target;
                for (var i = 0; i < candidates.length; i++) {

                    if (!sourceAnchor.isContinuous || sourceAnchor.isEdgeSupported(candidates[i].source))
                        sourceEdge = candidates[i].source;
                    else
                        sourceEdge = null;

                    if (!targetAnchor.isContinuous || targetAnchor.isEdgeSupported(candidates[i].target))
                        targetEdge = candidates[i].target;
                    else {
                        targetEdge = null;
                    }

                    if (sourceEdge != null && targetEdge != null) break;
                }

// --------------------------------------------------------------------------------------

                return {
                    a: [ sourceEdge, targetEdge ],
                    theta: theta,
                    theta2: theta2
                };
            },
        // used by placeAnchors function
            placeAnchorsOnLine = function (desc, elementDimensions, elementPosition, connections, horizontal, otherMultiplier, reverse) {
                var a = [], step = elementDimensions[horizontal ? 0 : 1] / (connections.length + 1);

                for (var i = 0; i < connections.length; i++) {
                    var val = (i + 1) * step, other = otherMultiplier * elementDimensions[horizontal ? 1 : 0];
                    if (reverse)
                        val = elementDimensions[horizontal ? 0 : 1] - val;

                    var dx = (horizontal ? val : other), x = elementPosition[0] + dx, xp = dx / elementDimensions[0],
                        dy = (horizontal ? other : val), y = elementPosition[1] + dy, yp = dy / elementDimensions[1];

                    a.push([ x, y, xp, yp, connections[i][1], connections[i][2] ]);
                }

                return a;
            },
        // used by edgeSortFunctions
            currySort = function (reverseAngles) {
                return function (a, b) {
                    var r = true;
                    if (reverseAngles) {
                        r = a[0][0] < b[0][0];
                    }
                    else {
                        r = a[0][0] > b[0][0];
                    }
                    return r === false ? -1 : 1;
                };
            },
        // used by edgeSortFunctions
            leftSort = function (a, b) {
                // first get adjusted values
                var p1 = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
                    p2 = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
                if (p1 > p2) return 1;
                else return -1;
            },
        // used by placeAnchors
            edgeSortFunctions = {
                "top": function (a, b) {
                    return a[0] > b[0] ? 1 : -1;
                },
                "right": currySort(true),
                "bottom": currySort(true),
                "left": leftSort
            },
        // used by placeAnchors
            _sortHelper = function (_array, _fn) {
                return _array.sort(_fn);
            },
        // used by AnchorManager.redraw
            placeAnchors = function (elementId, _anchorLists) {
                var cd = jsPlumbInstance.getCachedData(elementId), sS = cd.s, sO = cd.o,
                    placeSomeAnchors = function (desc, elementDimensions, elementPosition, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
                        if (unsortedConnections.length > 0) {
                            var sc = _sortHelper(unsortedConnections, edgeSortFunctions[desc]), // puts them in order based on the target element's pos on screen
                                reverse = desc === "right" || desc === "top",
                                anchors = placeAnchorsOnLine(desc, elementDimensions,
                                    elementPosition, sc,
                                    isHorizontal, otherMultiplier, reverse);

                            // takes a computed anchor position and adjusts it for parent offset and scroll, then stores it.
                            var _setAnchorLocation = function (endpoint, anchorPos) {
                                continuousAnchorLocations[endpoint.id] = [ anchorPos[0], anchorPos[1], anchorPos[2], anchorPos[3] ];
                                continuousAnchorOrientations[endpoint.id] = orientation;
                            };

                            for (var i = 0; i < anchors.length; i++) {
                                var c = anchors[i][4], weAreSource = c.endpoints[0].elementId === elementId, weAreTarget = c.endpoints[1].elementId === elementId;
                                if (weAreSource)
                                    _setAnchorLocation(c.endpoints[0], anchors[i]);
                                if (weAreTarget)
                                    _setAnchorLocation(c.endpoints[1], anchors[i]);
                            }
                        }
                    };

                placeSomeAnchors("bottom", sS, [sO.left, sO.top], _anchorLists.bottom, true, 1, [0, 1]);
                placeSomeAnchors("top", sS, [sO.left, sO.top], _anchorLists.top, true, 0, [0, -1]);
                placeSomeAnchors("left", sS, [sO.left, sO.top], _anchorLists.left, false, 0, [-1, 0]);
                placeSomeAnchors("right", sS, [sO.left, sO.top], _anchorLists.right, false, 1, [1, 0]);
            };

        this.reset = function () {
            _amEndpoints = {};
            connectionsByElementId = {};
            anchorLists = {};
        };
        this.addFloatingConnection = function (key, conn) {
            floatingConnections[key] = conn;
        };
        this.removeFloatingConnection = function (key) {
            delete floatingConnections[key];
        };
        this.newConnection = function (conn) {
            var sourceId = conn.sourceId, targetId = conn.targetId,
                ep = conn.endpoints,
                doRegisterTarget = true,
                registerConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                    if ((sourceId == targetId) && otherAnchor.isContinuous) {
                        // remove the target endpoint's canvas.  we dont need it.
                        conn._jsPlumb.instance.removeElement(ep[1].canvas);
                        doRegisterTarget = false;
                    }
                    _ju.addToList(connectionsByElementId, elId, [c, otherEndpoint, otherAnchor.constructor == _jp.DynamicAnchor]);
                };

            registerConnection(0, ep[0], ep[0].anchor, targetId, conn);
            if (doRegisterTarget)
                registerConnection(1, ep[1], ep[1].anchor, sourceId, conn);
        };
        var removeEndpointFromAnchorLists = function (endpoint) {
            (function (list, eId) {
                if (list) {  // transient anchors dont get entries in this list.
                    var f = function (e) {
                        return e[4] == eId;
                    };
                    _ju.removeWithFunction(list.top, f);
                    _ju.removeWithFunction(list.left, f);
                    _ju.removeWithFunction(list.bottom, f);
                    _ju.removeWithFunction(list.right, f);
                }
            })(anchorLists[endpoint.elementId], endpoint.id);
        };
        this.connectionDetached = function (connInfo, doNotRedraw) {
            var connection = connInfo.connection || connInfo,
                sourceId = connInfo.sourceId,
                targetId = connInfo.targetId,
                ep = connection.endpoints,
                removeConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                   _ju.removeWithFunction(connectionsByElementId[elId], function (_c) {
                        return _c[0].id == c.id;
                    });
                };

            removeConnection(1, ep[1], ep[1].anchor, sourceId, connection);
            removeConnection(0, ep[0], ep[0].anchor, targetId, connection);
            if (connection.floatingId) {
                removeConnection(connection.floatingIndex, connection.floatingEndpoint, connection.floatingEndpoint.anchor, connection.floatingId, connection);
                removeEndpointFromAnchorLists(connection.floatingEndpoint);
            }

            // remove from anchorLists            
            removeEndpointFromAnchorLists(connection.endpoints[0]);
            removeEndpointFromAnchorLists(connection.endpoints[1]);

            if (!doNotRedraw) {
                self.redraw(connection.sourceId);
                if (connection.targetId !== connection.sourceId)
                    self.redraw(connection.targetId);
            }
        };
        this.add = function (endpoint, elementId) {
            _ju.addToList(_amEndpoints, elementId, endpoint);
        };
        this.changeId = function (oldId, newId) {
            connectionsByElementId[newId] = connectionsByElementId[oldId];
            _amEndpoints[newId] = _amEndpoints[oldId];
            delete connectionsByElementId[oldId];
            delete _amEndpoints[oldId];
        };
        this.getConnectionsFor = function (elementId) {
            return connectionsByElementId[elementId] || [];
        };
        this.getEndpointsFor = function (elementId) {
            return _amEndpoints[elementId] || [];
        };
        this.deleteEndpoint = function (endpoint) {
            _ju.removeWithFunction(_amEndpoints[endpoint.elementId], function (e) {
                return e.id == endpoint.id;
            });
            removeEndpointFromAnchorLists(endpoint);
        };
        this.clearFor = function (elementId) {
            delete _amEndpoints[elementId];
            _amEndpoints[elementId] = [];
        };
        // updates the given anchor list by either updating an existing anchor's info, or adding it. this function
        // also removes the anchor from its previous list, if the edge it is on has changed.
        // all connections found along the way (those that are connected to one of the faces this function
        // operates on) are added to the connsToPaint list, as are their endpoints. in this way we know to repaint
        // them wthout having to calculate anything else about them.
        var _updateAnchorList = function (lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, elId, connsToPaint, endpointsToPaint) {
            // first try to find the exact match, but keep track of the first index of a matching element id along the way.s
            var exactIdx = -1,
                firstMatchingElIdx = -1,
                endpoint = conn.endpoints[idx],
                endpointId = endpoint.id,
                oIdx = [1, 0][idx],
                values = [
                    [ theta, order ],
                    conn,
                    aBoolean,
                    otherElId,
                    endpointId
                ],
                listToAddTo = lists[edgeId],
                listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
                i,
                candidate;

            if (listToRemoveFrom) {
                var rIdx = _ju.findWithFunction(listToRemoveFrom, function (e) {
                    return e[4] == endpointId;
                });
                if (rIdx != -1) {
                    listToRemoveFrom.splice(rIdx, 1);
                    // get all connections from this list
                    for (i = 0; i < listToRemoveFrom.length; i++) {
                        candidate = listToRemoveFrom[i][1];
                        _ju.addWithFunction(connsToPaint, candidate, function (c) {
                            return c.id == candidate.id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[idx], function (e) {
                            return e.id == candidate.endpoints[idx].id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[oIdx], function (e) {
                            return e.id == candidate.endpoints[oIdx].id;
                        });
                    }
                }
            }

            for (i = 0; i < listToAddTo.length; i++) {
                candidate = listToAddTo[i][1];
                if (params.idx == 1 && listToAddTo[i][3] === otherElId && firstMatchingElIdx == -1)
                    firstMatchingElIdx = i;
                _ju.addWithFunction(connsToPaint, candidate, function (c) {
                    return c.id == candidate.id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[idx], function (e) {
                    return e.id == candidate.endpoints[idx].id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[oIdx], function (e) {
                    return e.id == candidate.endpoints[oIdx].id;
                });
            }
            if (exactIdx != -1) {
                listToAddTo[exactIdx] = values;
            }
            else {
                var insertIdx = reverse ? firstMatchingElIdx != -1 ? firstMatchingElIdx : 0 : listToAddTo.length; // of course we will get this from having looked through the array shortly.
                listToAddTo.splice(insertIdx, 0, values);
            }

            // store this for next time.
            endpoint._continuousAnchorEdge = edgeId;
        };

        //
        // find the entry in an endpoint's list for this connection and update its target endpoint
        // with the current target in the connection.
        // This method and sourceChanged need to be folder into one.
        //
        this.updateOtherEndpoint = function (sourceElId, oldTargetId, newTargetId, connection) {
            var sIndex = _ju.findWithFunction(connectionsByElementId[sourceElId], function (i) {
                    return i[0].id === connection.id;
                }),
                tIndex = _ju.findWithFunction(connectionsByElementId[oldTargetId], function (i) {
                    return i[0].id === connection.id;
                });

            // update or add data for source
            if (sIndex != -1) {
                connectionsByElementId[sourceElId][sIndex][0] = connection;
                connectionsByElementId[sourceElId][sIndex][1] = connection.endpoints[1];
                connectionsByElementId[sourceElId][sIndex][2] = connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor;
            }

            // remove entry for previous target (if there)
            if (tIndex > -1) {
                connectionsByElementId[oldTargetId].splice(tIndex, 1);
                // add entry for new target
                _ju.addToList(connectionsByElementId, newTargetId, [connection, connection.endpoints[0], connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor]);
            }

            connection.updateConnectedClass();
        };

        //
        // notification that the connection given has changed source from the originalId to the newId.
        // This involves:
        // 1. removing the connection from the list of connections stored for the originalId
        // 2. updating the source information for the target of the connection
        // 3. re-registering the connection in connectionsByElementId with the newId
        //
        this.sourceChanged = function (originalId, newId, connection, newElement) {
            if (originalId !== newId) {

                connection.sourceId = newId;
                connection.source = newElement;

                // remove the entry that points from the old source to the target
                _ju.removeWithFunction(connectionsByElementId[originalId], function (info) {
                    return info[0].id === connection.id;
                });
                // find entry for target and update it
                var tIdx = _ju.findWithFunction(connectionsByElementId[connection.targetId], function (i) {
                    return i[0].id === connection.id;
                });
                if (tIdx > -1) {
                    connectionsByElementId[connection.targetId][tIdx][0] = connection;
                    connectionsByElementId[connection.targetId][tIdx][1] = connection.endpoints[0];
                    connectionsByElementId[connection.targetId][tIdx][2] = connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor;
                }
                // add entry for new source
                _ju.addToList(connectionsByElementId, newId, [connection, connection.endpoints[1], connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor]);

                // TODO SP not final on this yet. when a user drags an existing connection and it turns into a self
                // loop, then this code hides the target endpoint (by removing it from the DOM) But I think this should
                // occur only if the anchor is Continuous
                if (connection.endpoints[1].anchor.isContinuous) {
                    if (connection.source === connection.target) {
                        connection._jsPlumb.instance.removeElement(connection.endpoints[1].canvas);
                    }
                    else {
                        if (connection.endpoints[1].canvas.parentNode == null) {
                            connection._jsPlumb.instance.appendElement(connection.endpoints[1].canvas);
                        }
                    }
                }

                connection.updateConnectedClass();
            }
        };

        //
        // moves the given endpoint from `currentId` to `element`.
        // This involves:
        //
        // 1. changing the key in _amEndpoints under which the endpoint is stored
        // 2. changing the source or target values in all of the endpoint's connections
        // 3. changing the array in connectionsByElementId in which the endpoint's connections
        //    are stored (done by either sourceChanged or updateOtherEndpoint)
        //
        this.rehomeEndpoint = function (ep, currentId, element) {
            var eps = _amEndpoints[currentId] || [],
                elementId = jsPlumbInstance.getId(element);

            if (elementId !== currentId) {
                var idx = eps.indexOf(ep);
                if (idx > -1) {
                    var _ep = eps.splice(idx, 1)[0];
                    self.add(_ep, elementId);
                }
            }

            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId == currentId) {
                    //ep.connections[i].sourceId = ep.elementId;
                    //ep.connections[i].source = ep.element;
                    self.sourceChanged(currentId, ep.elementId, ep.connections[i], ep.element);
                }
                else if (ep.connections[i].targetId == currentId) {
                    ep.connections[i].targetId = ep.elementId;
                    ep.connections[i].target = ep.element;
                    self.updateOtherEndpoint(ep.connections[i].sourceId, currentId, ep.elementId, ep.connections[i]);
                }
            }
        };

        this.redraw = function (elementId, ui, timestamp, offsetToUI, clearEdits, doNotRecalcEndpoint) {

            if (!jsPlumbInstance.isSuspendDrawing()) {
                // get all the endpoints for this element
                var ep = _amEndpoints[elementId] || [],
                    endpointConnections = connectionsByElementId[elementId] || [],
                    connectionsToPaint = [],
                    endpointsToPaint = [],
                    anchorsToUpdate = [];

                timestamp = timestamp || jsPlumbInstance.timestamp();
                // offsetToUI are values that would have been calculated in the dragManager when registering
                // an endpoint for an element that had a parent (somewhere in the hierarchy) that had been
                // registered as draggable.
                offsetToUI = offsetToUI || {left: 0, top: 0};
                if (ui) {
                    ui = {
                        left: ui.left + offsetToUI.left,
                        top: ui.top + offsetToUI.top
                    };
                }

                // valid for one paint cycle.
                var myOffset = jsPlumbInstance.updateOffset({ elId: elementId, offset: ui, recalc: false, timestamp: timestamp }),
                    orientationCache = {};

                // actually, first we should compute the orientation of this element to all other elements to which
                // this element is connected with a continuous anchor (whether both ends of the connection have
                // a continuous anchor or just one)

                for (var i = 0; i < endpointConnections.length; i++) {
                    var conn = endpointConnections[i][0],
                        sourceId = conn.sourceId,
                        targetId = conn.targetId,
                        sourceContinuous = conn.endpoints[0].anchor.isContinuous,
                        targetContinuous = conn.endpoints[1].anchor.isContinuous;

                    if (sourceContinuous || targetContinuous) {
                        var oKey = sourceId + "_" + targetId,
                            o = orientationCache[oKey],
                            oIdx = conn.sourceId == elementId ? 1 : 0;

                        if (sourceContinuous && !anchorLists[sourceId]) anchorLists[sourceId] = { top: [], right: [], bottom: [], left: [] };
                        if (targetContinuous && !anchorLists[targetId]) anchorLists[targetId] = { top: [], right: [], bottom: [], left: [] };

                        if (elementId != targetId) jsPlumbInstance.updateOffset({ elId: targetId, timestamp: timestamp });
                        if (elementId != sourceId) jsPlumbInstance.updateOffset({ elId: sourceId, timestamp: timestamp });

                        var td = jsPlumbInstance.getCachedData(targetId),
                            sd = jsPlumbInstance.getCachedData(sourceId);

                        if (targetId == sourceId && (sourceContinuous || targetContinuous)) {
                            // here we may want to improve this by somehow determining the face we'd like
                            // to put the connector on.  ideally, when drawing, the face should be calculated
                            // by determining which face is closest to the point at which the mouse button
                            // was released.  for now, we're putting it on the top face.
                            _updateAnchorList( anchorLists[sourceId], -Math.PI / 2, 0, conn, false, targetId, 0, false, "top", sourceId, connectionsToPaint, endpointsToPaint);
                            _updateAnchorList( anchorLists[targetId], -Math.PI / 2, 0, conn, false, sourceId, 1, false, "top", targetId, connectionsToPaint, endpointsToPaint);
                        }
                        else {
                            if (!o) {
                                o = calculateOrientation(sourceId, targetId, sd.o, td.o, conn.endpoints[0].anchor, conn.endpoints[1].anchor);
                                orientationCache[oKey] = o;
                                // this would be a performance enhancement, but the computed angles need to be clamped to
                                //the (-PI/2 -> PI/2) range in order for the sorting to work properly.
                                /*  orientationCache[oKey2] = {
                                 orientation:o.orientation,
                                 a:[o.a[1], o.a[0]],
                                 theta:o.theta + Math.PI,
                                 theta2:o.theta2 + Math.PI
                                 };*/
                            }
                            if (sourceContinuous) _updateAnchorList(anchorLists[sourceId], o.theta, 0, conn, false, targetId, 0, false, o.a[0], sourceId, connectionsToPaint, endpointsToPaint);
                            if (targetContinuous) _updateAnchorList(anchorLists[targetId], o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], targetId, connectionsToPaint, endpointsToPaint);
                        }

                        if (sourceContinuous) _ju.addWithFunction(anchorsToUpdate, sourceId, function (a) {
                            return a === sourceId;
                        });
                        if (targetContinuous) _ju.addWithFunction(anchorsToUpdate, targetId, function (a) {
                            return a === targetId;
                        });
                        _ju.addWithFunction(connectionsToPaint, conn, function (c) {
                            return c.id == conn.id;
                        });
                        if ((sourceContinuous && oIdx === 0) || (targetContinuous && oIdx === 1))
                            _ju.addWithFunction(endpointsToPaint, conn.endpoints[oIdx], function (e) {
                                return e.id == conn.endpoints[oIdx].id;
                            });
                    }
                }

                // place Endpoints whose anchors are continuous but have no Connections
                for (i = 0; i < ep.length; i++) {
                    if (ep[i].connections.length === 0 && ep[i].anchor.isContinuous) {
                        if (!anchorLists[elementId]) anchorLists[elementId] = { top: [], right: [], bottom: [], left: [] };
                        _updateAnchorList(anchorLists[elementId], -Math.PI / 2, 0, {endpoints: [ep[i], ep[i]], paint: function () {
                        }}, false, elementId, 0, false, ep[i].anchor.getDefaultFace(), elementId, connectionsToPaint, endpointsToPaint);
                        _ju.addWithFunction(anchorsToUpdate, elementId, function (a) {
                            return a === elementId;
                        });
                    }
                }


                // now place all the continuous anchors we need to;
                for (i = 0; i < anchorsToUpdate.length; i++) {
                    placeAnchors(anchorsToUpdate[i], anchorLists[anchorsToUpdate[i]]);
                }

                // now that continuous anchors have been placed, paint all the endpoints for this element
                // TODO performance: add the endpoint ids to a temp array, and then when iterating in the next
                // loop, check that we didn't just paint that endpoint. we can probably shave off a few more milliseconds this way.
                for (i = 0; i < ep.length; i++) {
                    ep[i].paint({ timestamp: timestamp, offset: myOffset, dimensions: myOffset.s, recalc: doNotRecalcEndpoint !== true });
                }

                // ... and any other endpoints we came across as a result of the continuous anchors.
                for (i = 0; i < endpointsToPaint.length; i++) {
                    var cd = jsPlumbInstance.getCachedData(endpointsToPaint[i].elementId);
                    endpointsToPaint[i].paint({ timestamp: timestamp, offset: cd, dimensions: cd.s });
                }

                // paint all the standard and "dynamic connections", which are connections whose other anchor is
                // static and therefore does need to be recomputed; we make sure that happens only one time.

                // TODO we could have compiled a list of these in the first pass through connections; might save some time.
                for (i = 0; i < endpointConnections.length; i++) {
                    var otherEndpoint = endpointConnections[i][1];
                    if (otherEndpoint.anchor.constructor == _jp.DynamicAnchor) {
                        otherEndpoint.paint({ elementWithPrecedence: elementId, timestamp: timestamp });
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id == endpointConnections[i][0].id;
                        });
                        // all the connections for the other endpoint now need to be repainted
                        for (var k = 0; k < otherEndpoint.connections.length; k++) {
                            if (otherEndpoint.connections[k] !== endpointConnections[i][0])
                                _ju.addWithFunction(connectionsToPaint, otherEndpoint.connections[k], function (c) {
                                    return c.id == otherEndpoint.connections[k].id;
                                });
                        }
                    } else if (otherEndpoint.anchor.constructor == _jp.Anchor) {
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id == endpointConnections[i][0].id;
                        });
                    }
                }

                // paint current floating connection for this element, if there is one.
                var fc = floatingConnections[elementId];
                if (fc)
                    fc.paint({timestamp: timestamp, recalc: false, elId: elementId});

                // paint all the connections
                for (i = 0; i < connectionsToPaint.length; i++) {
                    connectionsToPaint[i].paint({elId: elementId, timestamp: timestamp, recalc: false, clearEdits: clearEdits});
                }
            }
        };

        var ContinuousAnchor = function (anchorParams) {
            _ju.EventGenerator.apply(this);
            this.type = "Continuous";
            this.isDynamic = true;
            this.isContinuous = true;
            var faces = anchorParams.faces || ["top", "right", "bottom", "left"],
                clockwise = !(anchorParams.clockwise === false),
                availableFaces = { },
                opposites = { "top": "bottom", "right": "left", "left": "right", "bottom": "top" },
                clockwiseOptions = { "top": "right", "right": "bottom", "left": "top", "bottom": "left" },
                antiClockwiseOptions = { "top": "left", "right": "top", "left": "bottom", "bottom": "right" },
                secondBest = clockwise ? clockwiseOptions : antiClockwiseOptions,
                lastChoice = clockwise ? antiClockwiseOptions : clockwiseOptions,
                cssClass = anchorParams.cssClass || "";

            for (var i = 0; i < faces.length; i++) {
                availableFaces[faces[i]] = true;
            }

            this.getDefaultFace = function () {
                return faces.length === 0 ? "top" : faces[0];
            };

            // if the given edge is supported, returns it. otherwise looks for a substitute that _is_
            // supported. if none supported we also return the request edge.
            this.verifyEdge = function (edge) {
                if (availableFaces[edge]) return edge;
                else if (availableFaces[opposites[edge]]) return opposites[edge];
                else if (availableFaces[secondBest[edge]]) return secondBest[edge];
                else if (availableFaces[lastChoice[edge]]) return lastChoice[edge];
                return edge; // we have to give them something.
            };

            this.isEdgeSupported = function (edge) {
                return availableFaces[edge] === true;
            };

            this.compute = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getCurrentLocation = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getOrientation = function (endpoint) {
                return continuousAnchorOrientations[endpoint.id] || [0, 0];
            };
            this.clearUserDefinedLocation = function () {
                delete userDefinedContinuousAnchorLocations[anchorParams.elementId];
            };
            this.setUserDefinedLocation = function (loc) {
                userDefinedContinuousAnchorLocations[anchorParams.elementId] = loc;
            };
            this.getCssClass = function () {
                return cssClass;
            };
        };

        // continuous anchors
        jsPlumbInstance.continuousAnchorFactory = {
            get: function (params) {
                return new ContinuousAnchor(params);
            },
            clear: function (elementId) {
                delete userDefinedContinuousAnchorLocations[elementId];
                delete continuousAnchorLocations[elementId];
            }
        };
    };

    /**
     * Anchors model a position on some element at which an Endpoint may be located.  They began as a first class citizen of jsPlumb, ie. a user
     * was required to create these themselves, but over time this has been replaced by the concept of referring to them either by name (eg. "TopMiddle"),
     * or by an array describing their coordinates (eg. [ 0, 0.5, 0, -1 ], which is the same as "TopMiddle").  jsPlumb now handles all of the
     * creation of Anchors without user intervention.
     */
    _jp.Anchor = function (params) {
        this.x = params.x || 0;
        this.y = params.y || 0;
        this.elementId = params.elementId;
        this.cssClass = params.cssClass || "";
        this.userDefinedLocation = null;
        this.orientation = params.orientation || [ 0, 0 ];
        this.lastReturnValue = null;
        this.offsets = params.offsets || [ 0, 0 ];
        this.timestamp = null;

        _ju.EventGenerator.apply(this);

        this.compute = function (params) {

            var xy = params.xy, wh = params.wh, timestamp = params.timestamp;

            if (params.clearUserDefinedLocation)
                this.userDefinedLocation = null;

            if (timestamp && timestamp === this.timestamp)
                return this.lastReturnValue;

            if (this.userDefinedLocation != null) {
                this.lastReturnValue = this.userDefinedLocation;
            }
            else {
                this.lastReturnValue = [ xy[0] + (this.x * wh[0]) + this.offsets[0], xy[1] + (this.y * wh[1]) + this.offsets[1] ];
            }

            this.timestamp = timestamp;
            return this.lastReturnValue;
        };

        this.getCurrentLocation = function (params) {
            params = params || {};
            return (this.lastReturnValue == null || (params.timestamp != null && this.timestamp != params.timestamp)) ? this.compute(params) : this.lastReturnValue;
        };
    };
    _ju.extend(_jp.Anchor, _ju.EventGenerator, {
        equals: function (anchor) {
            if (!anchor) return false;
            var ao = anchor.getOrientation(),
                o = this.getOrientation();
            return this.x == anchor.x && this.y == anchor.y && this.offsets[0] == anchor.offsets[0] && this.offsets[1] == anchor.offsets[1] && o[0] == ao[0] && o[1] == ao[1];
        },
        getUserDefinedLocation: function () {
            return this.userDefinedLocation;
        },
        setUserDefinedLocation: function (l) {
            this.userDefinedLocation = l;
        },
        clearUserDefinedLocation: function () {
            this.userDefinedLocation = null;
        },
        getOrientation: function () {
            return this.orientation;
        },
        getCssClass: function () {
            return this.cssClass;
        }
    });

    /**
     * An Anchor that floats. its orientation is computed dynamically from
     * its position relative to the anchor it is floating relative to.  It is used when creating
     * a connection through drag and drop.
     *
     * TODO FloatingAnchor could totally be refactored to extend Anchor just slightly.
     */
    _jp.FloatingAnchor = function (params) {

        _jp.Anchor.apply(this, arguments);

        // this is the anchor that this floating anchor is referenced to for
        // purposes of calculating the orientation.
        var ref = params.reference,
            // the canvas this refers to.
            refCanvas = params.referenceCanvas,
            size = _jp.getSize(refCanvas),
            // these are used to store the current relative position of our
            // anchor wrt the reference anchor. they only indicate
            // direction, so have a value of 1 or -1 (or, very rarely, 0). these
            // values are written by the compute method, and read
            // by the getOrientation method.
            xDir = 0, yDir = 0,
            // temporary member used to store an orientation when the floating
            // anchor is hovering over another anchor.
            orientation = null,
            _lastResult = null;

        // clear from parent. we want floating anchor orientation to always be computed.
        this.orientation = null;

        // set these to 0 each; they are used by certain types of connectors in the loopback case,
        // when the connector is trying to clear the element it is on. but for floating anchor it's not
        // very important.
        this.x = 0;
        this.y = 0;

        this.isFloating = true;

        this.compute = function (params) {
            var xy = params.xy,
                result = [ xy[0] + (size[0] / 2), xy[1] + (size[1] / 2) ]; // return origin of the element. we may wish to improve this so that any object can be the drag proxy.
            _lastResult = result;
            return result;
        };

        this.getOrientation = function (_endpoint) {
            if (orientation) return orientation;
            else {
                var o = ref.getOrientation(_endpoint);
                // here we take into account the orientation of the other
                // anchor: if it declares zero for some direction, we declare zero too. this might not be the most awesome. perhaps we can come
                // up with a better way. it's just so that the line we draw looks like it makes sense. maybe this wont make sense.
                return [ Math.abs(o[0]) * xDir * -1,
                        Math.abs(o[1]) * yDir * -1 ];
            }
        };

        /**
         * notification the endpoint associated with this anchor is hovering
         * over another anchor; we want to assume that anchor's orientation
         * for the duration of the hover.
         */
        this.over = function (anchor, endpoint) {
            orientation = anchor.getOrientation(endpoint);
        };

        /**
         * notification the endpoint associated with this anchor is no
         * longer hovering over another anchor; we should resume calculating
         * orientation as we normally do.
         */
        this.out = function () {
            orientation = null;
        };

        this.getCurrentLocation = function (params) {
            return _lastResult == null ? this.compute(params) : _lastResult;
        };
    };
    _ju.extend(_jp.FloatingAnchor, _jp.Anchor);

    var _convertAnchor = function (anchor, jsPlumbInstance, elementId) {
        return anchor.constructor == _jp.Anchor ? anchor : jsPlumbInstance.makeAnchor(anchor, elementId, jsPlumbInstance);
    };

    /* 
     * A DynamicAnchor is an Anchor that contains a list of other Anchors, which it cycles
     * through at compute time to find the one that is located closest to
     * the center of the target element, and returns that Anchor's compute
     * method result. this causes endpoints to follow each other with
     * respect to the orientation of their target elements, which is a useful
     * feature for some applications.
     * 
     */
    _jp.DynamicAnchor = function (params) {
        _jp.Anchor.apply(this, arguments);

        this.isDynamic = true;
        this.anchors = [];
        this.elementId = params.elementId;
        this.jsPlumbInstance = params.jsPlumbInstance;

        for (var i = 0; i < params.anchors.length; i++)
            this.anchors[i] = _convertAnchor(params.anchors[i], this.jsPlumbInstance, this.elementId);

        this.getAnchors = function () {
            return this.anchors;
        };
        this.locked = false;
        var _curAnchor = this.anchors.length > 0 ? this.anchors[0] : null,
            _lastAnchor = _curAnchor,
            self = this,

        // helper method to calculate the distance between the centers of the two elements.
            _distance = function (anchor, cx, cy, xy, wh) {
                var ax = xy[0] + (anchor.x * wh[0]), ay = xy[1] + (anchor.y * wh[1]),
                    acx = xy[0] + (wh[0] / 2), acy = xy[1] + (wh[1] / 2);
                return (Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) +
                    Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2)));
            },
        // default method uses distance between element centers.  you can provide your own method in the dynamic anchor
        // constructor (and also to jsPlumb.makeDynamicAnchor). the arguments to it are four arrays:
        // xy - xy loc of the anchor's element
        // wh - anchor's element's dimensions
        // txy - xy loc of the element of the other anchor in the connection
        // twh - dimensions of the element of the other anchor in the connection.
        // anchors - the list of selectable anchors
            _anchorSelector = params.selector || function (xy, wh, txy, twh, anchors) {
                var cx = txy[0] + (twh[0] / 2), cy = txy[1] + (twh[1] / 2);
                var minIdx = -1, minDist = Infinity;
                for (var i = 0; i < anchors.length; i++) {
                    var d = _distance(anchors[i], cx, cy, xy, wh);
                    if (d < minDist) {
                        minIdx = i + 0;
                        minDist = d;
                    }
                }
                return anchors[minIdx];
            };

        this.compute = function (params) {
            var xy = params.xy, wh = params.wh, txy = params.txy, twh = params.twh;

            this.timestamp = params.timestamp;

            var udl = self.getUserDefinedLocation();
            if (udl != null) {
                return udl;
            }

            // if anchor is locked or an opposite element was not given, we
            // maintain our state. anchor will be locked
            // if it is the source of a drag and drop.
            if (this.locked || txy == null || twh == null)
                return _curAnchor.compute(params);
            else
                params.timestamp = null; // otherwise clear this, i think. we want the anchor to compute.

            _curAnchor = _anchorSelector(xy, wh, txy, twh, this.anchors);
            this.x = _curAnchor.x;
            this.y = _curAnchor.y;

            if (_curAnchor != _lastAnchor)
                this.fire("anchorChanged", _curAnchor);

            _lastAnchor = _curAnchor;

            return _curAnchor.compute(params);
        };

        this.getCurrentLocation = function (params) {
            return this.getUserDefinedLocation() || (_curAnchor != null ? _curAnchor.getCurrentLocation(params) : null);
        };

        this.getOrientation = function (_endpoint) {
            return _curAnchor != null ? _curAnchor.getOrientation(_endpoint) : [ 0, 0 ];
        };
        this.over = function (anchor, endpoint) {
            if (_curAnchor != null) _curAnchor.over(anchor, endpoint);
        };
        this.out = function () {
            if (_curAnchor != null) _curAnchor.out();
        };

        this.getCssClass = function () {
            return (_curAnchor && _curAnchor.getCssClass()) || "";
        };
    };
    _ju.extend(_jp.DynamicAnchor, _jp.Anchor);

// -------- basic anchors ------------------    
    var _curryAnchor = function (x, y, ox, oy, type, fnInit) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor([ x, y, ox, oy, 0, 0 ], params.elementId, params.jsPlumbInstance);
            a.type = type;
            if (fnInit) fnInit(a, params);
            return a;
        };
    };

    _curryAnchor(0.5, 0, 0, -1, "TopCenter");
    _curryAnchor(0.5, 1, 0, 1, "BottomCenter");
    _curryAnchor(0, 0.5, -1, 0, "LeftMiddle");
    _curryAnchor(1, 0.5, 1, 0, "RightMiddle");

    _curryAnchor(0.5, 0, 0, -1, "Top");
    _curryAnchor(0.5, 1, 0, 1, "Bottom");
    _curryAnchor(0, 0.5, -1, 0, "Left");
    _curryAnchor(1, 0.5, 1, 0, "Right");
    _curryAnchor(0.5, 0.5, 0, 0, "Center");
    _curryAnchor(1, 0, 0, -1, "TopRight");
    _curryAnchor(1, 1, 0, 1, "BottomRight");
    _curryAnchor(0, 0, 0, -1, "TopLeft");
    _curryAnchor(0, 1, 0, 1, "BottomLeft");

// ------- dynamic anchors -------------------    

    // default dynamic anchors chooses from Top, Right, Bottom, Left
    _jp.Defaults.DynamicAnchors = function (params) {
        return params.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], params.elementId, params.jsPlumbInstance);
    };

    // default dynamic anchors bound to name 'AutoDefault'
    _jp.Anchors.AutoDefault = function (params) {
        var a = params.jsPlumbInstance.makeDynamicAnchor(_jp.Defaults.DynamicAnchors(params));
        a.type = "AutoDefault";
        return a;
    };

// ------- continuous anchors -------------------    

    var _curryContinuousAnchor = function (type, faces) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor(["Continuous", { faces: faces }], params.elementId, params.jsPlumbInstance);
            a.type = type;
            return a;
        };
    };

    _jp.Anchors.Continuous = function (params) {
        return params.jsPlumbInstance.continuousAnchorFactory.get(params);
    };

    _curryContinuousAnchor("ContinuousLeft", ["left"]);
    _curryContinuousAnchor("ContinuousTop", ["top"]);
    _curryContinuousAnchor("ContinuousBottom", ["bottom"]);
    _curryContinuousAnchor("ContinuousRight", ["right"]);

// ------- position assign anchors -------------------    

    // this anchor type lets you assign the position at connection time.
    _curryAnchor(0, 0, 0, 0, "Assign", function (anchor, params) {
        // find what to use as the "position finder". the user may have supplied a String which represents
        // the id of a position finder in jsPlumb.AnchorPositionFinders, or the user may have supplied the
        // position finder as a function.  we find out what to use and then set it on the anchor.
        var pf = params.position || "Fixed";
        anchor.positionFinder = pf.constructor == String ? params.jsPlumbInstance.AnchorPositionFinders[pf] : pf;
        // always set the constructor params; the position finder might need them later (the Grid one does,
        // for example)
        anchor.constructorParams = params;
    });

    // these are the default anchor positions finders, which are used by the makeTarget function.  supplying
    // a position finder argument to that function allows you to specify where the resulting anchor will
    // be located
    root.jsPlumbInstance.prototype.AnchorPositionFinders = {
        "Fixed": function (dp, ep, es) {
            return [ (dp.left - ep.left) / es[0], (dp.top - ep.top) / es[1] ];
        },
        "Grid": function (dp, ep, es, params) {
            var dx = dp.left - ep.left, dy = dp.top - ep.top,
                gx = es[0] / (params.grid[0]), gy = es[1] / (params.grid[1]),
                mx = Math.floor(dx / gx), my = Math.floor(dy / gy);
            return [ ((mx * gx) + (gx / 2)) / es[0], ((my * gy) + (gy / 2)) / es[1] ];
        }
    };

// ------- perimeter anchors -------------------    

    _jp.Anchors.Perimeter = function (params) {
        params = params || {};
        var anchorCount = params.anchorCount || 60,
            shape = params.shape;

        if (!shape) throw new Error("no shape supplied to Perimeter Anchor type");

        var _circle = function () {
                var r = 0.5, step = Math.PI * 2 / anchorCount, current = 0, a = [];
                for (var i = 0; i < anchorCount; i++) {
                    var x = r + (r * Math.sin(current)),
                        y = r + (r * Math.cos(current));
                    a.push([ x, y, 0, 0 ]);
                    current += step;
                }
                return a;
            },
            _path = function (segments) {
                var anchorsPerFace = anchorCount / segments.length, a = [],
                    _computeFace = function (x1, y1, x2, y2, fractionalLength) {
                        anchorsPerFace = anchorCount * fractionalLength;
                        var dx = (x2 - x1) / anchorsPerFace, dy = (y2 - y1) / anchorsPerFace;
                        for (var i = 0; i < anchorsPerFace; i++) {
                            a.push([
                                    x1 + (dx * i),
                                    y1 + (dy * i),
                                0,
                                0
                            ]);
                        }
                    };

                for (var i = 0; i < segments.length; i++)
                    _computeFace.apply(null, segments[i]);

                return a;
            },
            _shape = function (faces) {
                var s = [];
                for (var i = 0; i < faces.length; i++) {
                    s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length]);
                }
                return _path(s);
            },
            _rectangle = function () {
                return _shape([
                    [ 0, 0, 1, 0 ],
                    [ 1, 0, 1, 1 ],
                    [ 1, 1, 0, 1 ],
                    [ 0, 1, 0, 0 ]
                ]);
            };

        var _shapes = {
                "Circle": _circle,
                "Ellipse": _circle,
                "Diamond": function () {
                    return _shape([
                        [ 0.5, 0, 1, 0.5 ],
                        [ 1, 0.5, 0.5, 1 ],
                        [ 0.5, 1, 0, 0.5 ],
                        [ 0, 0.5, 0.5, 0 ]
                    ]);
                },
                "Rectangle": _rectangle,
                "Square": _rectangle,
                "Triangle": function () {
                    return _shape([
                        [ 0.5, 0, 1, 1 ],
                        [ 1, 1, 0, 1 ],
                        [ 0, 1, 0.5, 0]
                    ]);
                },
                "Path": function (params) {
                    var points = params.points, p = [], tl = 0;
                    for (var i = 0; i < points.length - 1; i++) {
                        var l = Math.sqrt(Math.pow(points[i][2] - points[i][0]) + Math.pow(points[i][3] - points[i][1]));
                        tl += l;
                        p.push([points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], l]);
                    }
                    for (var j = 0; j < p.length; j++) {
                        p[j][4] = p[j][4] / tl;
                    }
                    return _path(p);
                }
            },
            _rotate = function (points, amountInDegrees) {
                var o = [], theta = amountInDegrees / 180 * Math.PI;
                for (var i = 0; i < points.length; i++) {
                    var _x = points[i][0] - 0.5,
                        _y = points[i][1] - 0.5;

                    o.push([
                            0.5 + ((_x * Math.cos(theta)) - (_y * Math.sin(theta))),
                            0.5 + ((_x * Math.sin(theta)) + (_y * Math.cos(theta))),
                        points[i][2],
                        points[i][3]
                    ]);
                }
                return o;
            };

        if (!_shapes[shape]) throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");

        var da = _shapes[shape](params);
        if (params.rotation) da = _rotate(da, params.rotation);
        var a = params.jsPlumbInstance.makeDynamicAnchor(da);
        a.type = "Perimeter";
        return a;
    };
}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the default Connectors, Endpoint and Overlay definitions.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil, _jg = root.Biltong;

    _jp.Segments = {

        /*
         * Class: AbstractSegment
         * A Connector is made up of 1..N Segments, each of which has a Type, such as 'Straight', 'Arc',
         * 'Bezier'. This is new from 1.4.2, and gives us a lot more flexibility when drawing connections: things such
         * as rounded corners for flowchart connectors, for example, or a straight line stub for Bezier connections, are
         * much easier to do now.
         *
         * A Segment is responsible for providing coordinates for painting it, and also must be able to report its length.
         * 
         */
        AbstractSegment: function (params) {
            this.params = params;

            /**
             * Function: findClosestPointOnPath
             * Finds the closest point on this segment to the given [x, y],
             * returning both the x and y of the point plus its distance from
             * the supplied point, and its location along the length of the
             * path inscribed by the segment.  This implementation returns
             * Infinity for distance and null values for everything else;
             * subclasses are expected to override.
             */
            this.findClosestPointOnPath = function (x, y) {
                return {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null
                };
            };

            this.getBounds = function () {
                return {
                    minX: Math.min(params.x1, params.x2),
                    minY: Math.min(params.y1, params.y2),
                    maxX: Math.max(params.x1, params.x2),
                    maxY: Math.max(params.y1, params.y2)
                };
            };
        },
        Straight: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                length, m, m2, x1, x2, y1, y2,
                _recalc = function () {
                    length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    m = _jg.gradient({x: x1, y: y1}, {x: x2, y: y2});
                    m2 = -1 / m;
                };

            this.type = "Straight";

            this.getLength = function () {
                return length;
            };
            this.getGradient = function () {
                return m;
            };

            this.getCoordinates = function () {
                return { x1: x1, y1: y1, x2: x2, y2: y2 };
            };
            this.setCoordinates = function (coords) {
                x1 = coords.x1;
                y1 = coords.y1;
                x2 = coords.x2;
                y2 = coords.y2;
                _recalc();
            };
            this.setCoordinates({x1: params.x1, y1: params.y1, x2: params.x2, y2: params.y2});

            this.getBounds = function () {
                return {
                    minX: Math.min(x1, x2),
                    minY: Math.min(y1, y2),
                    maxX: Math.max(x1, x2),
                    maxY: Math.max(y1, y2)
                };
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive. for the straight line segment this is simple maths.
             */
            this.pointOnPath = function (location, absolute) {
                if (location === 0 && !absolute)
                    return { x: x1, y: y1 };
                else if (location == 1 && !absolute)
                    return { x: x2, y: y2 };
                else {
                    var l = absolute ? location > 0 ? location : length + location : location * length;
                    return _jg.pointOnLine({x: x1, y: y1}, {x: x2, y: y2}, l);
                }
            };

            /**
             * returns the gradient of the segment at the given point - which for us is constant.
             */
            this.gradientAtPoint = function (_) {
                return m;
            };

            /**
             * returns the point on the segment's path that is 'distance' along the length of the path from 'location', where
             * 'location' is a decimal from 0 to 1 inclusive, and 'distance' is a number of pixels.
             * this hands off to jsPlumbUtil to do the maths, supplying two points and the distance.
             */
            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    farAwayPoint = distance <= 0 ? {x: x1, y: y1} : {x: x2, y: y2 };

                /*
                 location == 1 ? {
                 x:x1 + ((x2 - x1) * 10),
                 y:y1 + ((y1 - y2) * 10)
                 } :
                 */

                if (distance <= 0 && Math.abs(distance) > 1) distance *= -1;

                return _jg.pointOnLine(p, farAwayPoint, distance);
            };

            // is c between a and b?
            var within = function (a, b, c) {
                return c >= Math.min(a, b) && c <= Math.max(a, b);
            };
            // find which of a and b is closest to c
            var closest = function (a, b, c) {
                return Math.abs(c - a) < Math.abs(c - b) ? a : b;
            };

            /**
             Function: findClosestPointOnPath
             Finds the closest point on this segment to [x,y]. See
             notes on this method in AbstractSegment.
             */
            this.findClosestPointOnPath = function (x, y) {
                var out = {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null,
                    x1: x1,
                    x2: x2,
                    y1: y1,
                    y2: y2
                };

                if (m === 0) {
                    out.y = y1;
                    out.x = within(x1, x2, x) ? x : closest(x1, x2, x);
                }
                else if (m == Infinity || m == -Infinity) {
                    out.x = x1;
                    out.y = within(y1, y2, y) ? y : closest(y1, y2, y);
                }
                else {
                    // closest point lies on normal from given point to this line.  
                    var b = y1 - (m * x1),
                        b2 = y - (m2 * x),
                    // y1 = m.x1 + b and y1 = m2.x1 + b2
                    // so m.x1 + b = m2.x1 + b2
                    // x1(m - m2) = b2 - b
                    // x1 = (b2 - b) / (m - m2)
                        _x1 = (b2 - b) / (m - m2),
                        _y1 = (m * _x1) + b;

                    out.x = within(x1, x2, _x1) ? _x1 : closest(x1, x2, _x1);//_x1;
                    out.y = within(y1, y2, _y1) ? _y1 : closest(y1, y2, _y1);//_y1;
                }

                var fractionInSegment = _jg.lineLength([ out.x, out.y ], [ x1, y1 ]);
                out.d = _jg.lineLength([x, y], [out.x, out.y]);
                out.l = fractionInSegment / length;
                return out;
            };
        },

        /*
         Arc Segment. You need to supply:

         r   -   radius
         cx  -   center x for the arc
         cy  -   center y for the arc
         ac  -   whether the arc is anticlockwise or not. default is clockwise.

         and then either:

         startAngle  -   startAngle for the arc.
         endAngle    -   endAngle for the arc.

         or:

         x1          -   x for start point
         y1          -   y for start point
         x2          -   x for end point
         y2          -   y for end point

         */
        Arc: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                _calcAngle = function (_x, _y) {
                    return _jg.theta([params.cx, params.cy], [_x, _y]);
                },
                _calcAngleForLocation = function (segment, location) {
                    if (segment.anticlockwise) {
                        var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
                            s = Math.abs(sa - segment.endAngle);
                        return sa - (s * location);
                    }
                    else {
                        var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
                            ss = Math.abs(ea - segment.startAngle);

                        return segment.startAngle + (ss * location);
                    }
                },
                TWO_PI = 2 * Math.PI;

            this.radius = params.r;
            this.anticlockwise = params.ac;
            this.type = "Arc";

            if (params.startAngle && params.endAngle) {
                this.startAngle = params.startAngle;
                this.endAngle = params.endAngle;
                this.x1 = params.cx + (this.radius * Math.cos(params.startAngle));
                this.y1 = params.cy + (this.radius * Math.sin(params.startAngle));
                this.x2 = params.cx + (this.radius * Math.cos(params.endAngle));
                this.y2 = params.cy + (this.radius * Math.sin(params.endAngle));
            }
            else {
                this.startAngle = _calcAngle(params.x1, params.y1);
                this.endAngle = _calcAngle(params.x2, params.y2);
                this.x1 = params.x1;
                this.y1 = params.y1;
                this.x2 = params.x2;
                this.y2 = params.y2;
            }

            if (this.endAngle < 0) this.endAngle += TWO_PI;
            if (this.startAngle < 0) this.startAngle += TWO_PI;

            // segment is used by vml     
            //this.segment = _jg.quadrant([this.x1, this.y1], [this.x2, this.y2]);

            // we now have startAngle and endAngle as positive numbers, meaning the
            // absolute difference (|d|) between them is the sweep (s) of this arc, unless the
            // arc is 'anticlockwise' in which case 's' is given by 2PI - |d|.

            var ea = this.endAngle < this.startAngle ? this.endAngle + TWO_PI : this.endAngle;
            this.sweep = Math.abs(ea - this.startAngle);
            if (this.anticlockwise) this.sweep = TWO_PI - this.sweep;
            var circumference = 2 * Math.PI * this.radius,
                frac = this.sweep / TWO_PI,
                length = circumference * frac;

            this.getLength = function () {
                return length;
            };

            this.getBounds = function () {
                return {
                    minX: params.cx - params.r,
                    maxX: params.cx + params.r,
                    minY: params.cy - params.r,
                    maxY: params.cy + params.r
                };
            };

            var VERY_SMALL_VALUE = 0.0000000001,
                gentleRound = function (n) {
                    var f = Math.floor(n), r = Math.ceil(n);
                    if (n - f < VERY_SMALL_VALUE)
                        return f;
                    else if (r - n < VERY_SMALL_VALUE)
                        return r;
                    return n;
                };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {

                if (location === 0) {
                    return { x: this.x1, y: this.y1, theta: this.startAngle };
                }
                else if (location == 1) {
                    return { x: this.x2, y: this.y2, theta: this.endAngle };
                }

                if (absolute) {
                    location = location / length;
                }

                var angle = _calcAngleForLocation(this, location),
                    _x = params.cx + (params.r * Math.cos(angle)),
                    _y = params.cy + (params.r * Math.sin(angle));

                return { x: gentleRound(_x), y: gentleRound(_y), theta: angle };
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                var p = this.pointOnPath(location, absolute);
                var m = _jg.normal([ params.cx, params.cy ], [p.x, p.y ]);
                if (!this.anticlockwise && (m == Infinity || m == -Infinity)) m *= -1;
                return m;
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    arcSpan = distance / circumference * 2 * Math.PI,
                    dir = this.anticlockwise ? -1 : 1,
                    startAngle = p.theta + (dir * arcSpan),
                    startX = params.cx + (this.radius * Math.cos(startAngle)),
                    startY = params.cy + (this.radius * Math.sin(startAngle));

                return {x: startX, y: startY};
            };
        },

        Bezier: function (params) {
            this.curve = [
                { x: params.x1, y: params.y1},
                { x: params.cp1x, y: params.cp1y },
                { x: params.cp2x, y: params.cp2y },
                { x: params.x2, y: params.y2 }
            ];

            var _super = _jp.Segments.AbstractSegment.apply(this, arguments);
            // although this is not a strictly rigorous determination of bounds
            // of a bezier curve, it works for the types of curves that this segment
            // type produces.
            this.bounds = {
                minX: Math.min(params.x1, params.x2, params.cp1x, params.cp2x),
                minY: Math.min(params.y1, params.y2, params.cp1y, params.cp2y),
                maxX: Math.max(params.x1, params.x2, params.cp1x, params.cp2x),
                maxY: Math.max(params.y1, params.y2, params.cp1y, params.cp2y)
            };

            this.type = "Bezier";

            var _translateLocation = function (_curve, location, absolute) {
                if (absolute)
                    location = root.jsBezier.locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);

                return location;
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointOnCurve(this.curve, location);
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.gradientAtPoint(this.curve, location);
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointAlongCurveFrom(this.curve, location, distance);
            };

            this.getLength = function () {
                return root.jsBezier.getLength(this.curve);
            };

            this.getBounds = function () {
                return this.bounds;
            };
        }
    };

    _jp.SegmentRenderer = {
        getPath: function (segment) {
            return ({
                "Straight": function () {
                    var d = segment.getCoordinates();
                    return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;
                },
                "Bezier": function () {
                    var d = segment.params;
                    return "M " + d.x1 + " " + d.y1 +
                        " C " + d.cp1x + " " + d.cp1y + " " + d.cp2x + " " + d.cp2y + " " + d.x2 + " " + d.y2;
                },
                "Arc": function () {
                    var d = segment.params,
                        laf = segment.sweep > Math.PI ? 1 : 0,
                        sf = segment.anticlockwise ? 0 : 1;

                    return "M" + segment.x1 + " " + segment.y1 + " A " + segment.radius + " " + d.r + " 0 " + laf + "," + sf + " " + segment.x2 + " " + segment.y2;
                }
            })[segment.type]();
        }
    };

    /*
     Class: AbstractComponent
     Superclass for AbstractConnector and AbstractEndpoint.
     */
    var AbstractComponent = function () {
        this.resetBounds = function () {
            this.bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
        };
        this.resetBounds();
    };

    /*
     * Class: AbstractConnector
     * Superclass for all Connectors; here is where Segments are managed.  This is exposed on jsPlumb just so it
     * can be accessed from other files. You should not try to instantiate one of these directly.
     *
     * When this class is asked for a pointOnPath, or gradient etc, it must first figure out which segment to dispatch
     * that request to. This is done by keeping track of the total connector length as segments are added, and also
     * their cumulative ratios to the total length.  Then when the right segment is found it is a simple case of dispatching
     * the request to it (and adjusting 'location' so that it is relative to the beginning of that segment.)
     */
    _jp.Connectors.AbstractConnector = function (params) {

        AbstractComponent.apply(this, arguments);

        var segments = [],
            totalLength = 0,
            segmentProportions = [],
            segmentProportionalLengths = [],
            stub = params.stub || 0,
            sourceStub = _ju.isArray(stub) ? stub[0] : stub,
            targetStub = _ju.isArray(stub) ? stub[1] : stub,
            gap = params.gap || 0,
            sourceGap = _ju.isArray(gap) ? gap[0] : gap,
            targetGap = _ju.isArray(gap) ? gap[1] : gap,
            userProvidedSegments = null,
            edited = false,
            paintInfo = null,
            geometry = null,
            editable = params.editable !== false && _jp.ConnectorEditors != null && _jp.ConnectorEditors[this.type] != null;

        var _setGeometry = this.setGeometry = function(g, internallyComputed) {
            edited = (!internallyComputed);
            geometry = g;
        };
        var _getGeometry = this.getGeometry = function() {
            return geometry;
        };

        this.getPathData = function() {
            var p = "";
            for (var i = 0; i < segments.length; i++) {
                p += _jp.SegmentRenderer.getPath(segments[i]);
                p += " ";
            }
            return p;
        };

        this.hasBeenEdited = function() { return edited; };
        this.isEditing = function() { return this.editor != null && this.editor.isActive(); };
        this.setEditable = function(e) {
            // if this connector has an editor already, or
            // if an editor for this connector's type is available, or
            // if the child declares an overrideSetEditable and it does not return false, editable is true.
            if (e && _jp.ConnectorEditors != null && _jp.ConnectorEditors[this.type] != null && (this.overrideSetEditable == null || this.overrideSetEditable())) {
                editable = e;
            } else {
                editable = false;
            }
            return editable;
        };
        this.isEditable = function() { return editable; };

        /**
         * Function: findSegmentForPoint
         * Returns the segment that is closest to the given [x,y],
         * null if nothing found.  This function returns a JS
         * object with:
         *
         *   d   -   distance from segment
         *   l   -   proportional location in segment
         *   x   -   x point on the segment
         *   y   -   y point on the segment
         *   s   -   the segment itself.
         */
        this.findSegmentForPoint = function (x, y) {
            var out = { d: Infinity, s: null, x: null, y: null, l: null };
            for (var i = 0; i < segments.length; i++) {
                var _s = segments[i].findClosestPointOnPath(x, y);
                if (_s.d < out.d) {
                    out.d = _s.d;
                    out.l = _s.l;
                    out.x = _s.x;
                    out.y = _s.y;
                    out.s = segments[i];
                    out.x1 = _s.x1;
                    out.x2 = _s.x2;
                    out.y1 = _s.y1;
                    out.y2 = _s.y2;
                    out.index = i;
                }
            }

            return out;
        };

        var _updateSegmentProportions = function () {
                var curLoc = 0;
                for (var i = 0; i < segments.length; i++) {
                    var sl = segments[i].getLength();
                    segmentProportionalLengths[i] = sl / totalLength;
                    segmentProportions[i] = [curLoc, (curLoc += (sl / totalLength)) ];
                }
            },

            /**
             * returns [segment, proportion of travel in segment, segment index] for the segment
             * that contains the point which is 'location' distance along the entire path, where
             * 'location' is a decimal between 0 and 1 inclusive. in this connector type, paths
             * are made up of a list of segments, each of which contributes some fraction to
             * the total length.
             * From 1.3.10 this also supports the 'absolute' property, which lets us specify a location
             * as the absolute distance in pixels, rather than a proportion of the total path.
             */
            _findSegmentForLocation = function (location, absolute) {
                if (absolute) {
                    location = location > 0 ? location / totalLength : (totalLength + location) / totalLength;
                }
                var idx = segmentProportions.length - 1, inSegmentProportion = 1;
                for (var i = 0; i < segmentProportions.length; i++) {
                    if (segmentProportions[i][1] >= location) {
                        idx = i;
                        // todo is this correct for all connector path types?
                        inSegmentProportion = location == 1 ? 1 : location === 0 ? 0 : (location - segmentProportions[i][0]) / segmentProportionalLengths[i];
                        break;
                    }
                }
                return { segment: segments[idx], proportion: inSegmentProportion, index: idx };
            },
            _addSegment = function (conn, type, params) {
                if (params.x1 == params.x2 && params.y1 == params.y2) return;
                var s = new _jp.Segments[type](params);
                segments.push(s);
                totalLength += s.getLength();
                conn.updateBounds(s);
            },
            _clearSegments = function () {
                totalLength = segments.length = segmentProportions.length = segmentProportionalLengths.length = 0;
            };

        this.setSegments = function (_segs) {
            userProvidedSegments = [];
            totalLength = 0;
            for (var i = 0; i < _segs.length; i++) {
                userProvidedSegments.push(_segs[i]);
                totalLength += _segs[i].getLength();
            }
        };

        this.getLength = function() {
            return totalLength;
        };

        var _prepareCompute = function (params) {
            this.strokeWidth = params.strokeWidth;
            var segment = _jg.quadrant(params.sourcePos, params.targetPos),
                swapX = params.targetPos[0] < params.sourcePos[0],
                swapY = params.targetPos[1] < params.sourcePos[1],
                lw = params.strokeWidth || 1,
                so = params.sourceEndpoint.anchor.getOrientation(params.sourceEndpoint),
                to = params.targetEndpoint.anchor.getOrientation(params.targetEndpoint),
                x = swapX ? params.targetPos[0] : params.sourcePos[0],
                y = swapY ? params.targetPos[1] : params.sourcePos[1],
                w = Math.abs(params.targetPos[0] - params.sourcePos[0]),
                h = Math.abs(params.targetPos[1] - params.sourcePos[1]);

            // if either anchor does not have an orientation set, we derive one from their relative
            // positions.  we fix the axis to be the one in which the two elements are further apart, and
            // point each anchor at the other element.  this is also used when dragging a new connection.
            if (so[0] === 0 && so[1] === 0 || to[0] === 0 && to[1] === 0) {
                var index = w > h ? 0 : 1, oIndex = [1, 0][index];
                so = [];
                to = [];
                so[index] = params.sourcePos[index] > params.targetPos[index] ? -1 : 1;
                to[index] = params.sourcePos[index] > params.targetPos[index] ? 1 : -1;
                so[oIndex] = 0;
                to[oIndex] = 0;
            }

            var sx = swapX ? w + (sourceGap * so[0]) : sourceGap * so[0],
                sy = swapY ? h + (sourceGap * so[1]) : sourceGap * so[1],
                tx = swapX ? targetGap * to[0] : w + (targetGap * to[0]),
                ty = swapY ? targetGap * to[1] : h + (targetGap * to[1]),
                oProduct = ((so[0] * to[0]) + (so[1] * to[1]));

            var result = {
                sx: sx, sy: sy, tx: tx, ty: ty, lw: lw,
                xSpan: Math.abs(tx - sx),
                ySpan: Math.abs(ty - sy),
                mx: (sx + tx) / 2,
                my: (sy + ty) / 2,
                so: so, to: to, x: x, y: y, w: w, h: h,
                segment: segment,
                startStubX: sx + (so[0] * sourceStub),
                startStubY: sy + (so[1] * sourceStub),
                endStubX: tx + (to[0] * targetStub),
                endStubY: ty + (to[1] * targetStub),
                isXGreaterThanStubTimes2: Math.abs(sx - tx) > (sourceStub + targetStub),
                isYGreaterThanStubTimes2: Math.abs(sy - ty) > (sourceStub + targetStub),
                opposite: oProduct == -1,
                perpendicular: oProduct === 0,
                orthogonal: oProduct == 1,
                sourceAxis: so[0] === 0 ? "y" : "x",
                points: [x, y, w, h, sx, sy, tx, ty ]
            };
            result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
            return result;
        };

        this.getSegments = function () {
            return segments;
        };

        this.updateBounds = function (segment) {
            var segBounds = segment.getBounds();
            this.bounds.minX = Math.min(this.bounds.minX, segBounds.minX);
            this.bounds.maxX = Math.max(this.bounds.maxX, segBounds.maxX);
            this.bounds.minY = Math.min(this.bounds.minY, segBounds.minY);
            this.bounds.maxY = Math.max(this.bounds.maxY, segBounds.maxY);
        };

        var dumpSegmentsToConsole = function () {
            console.log("SEGMENTS:");
            for (var i = 0; i < segments.length; i++) {
                console.log(segments[i].type, segments[i].getLength(), segmentProportions[i]);
            }
        };

        this.pointOnPath = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || [0, 0];
        };

        this.gradientAtPoint = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
        };

        this.pointAlongPathFrom = function (location, distance, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            // TODO what happens if this crosses to the next segment?
            return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || [0, 0];
        };

        this.compute = function (params) {
            paintInfo = _prepareCompute.call(this, params);

            _clearSegments();
            this._compute(paintInfo, params);
            this.x = paintInfo.points[0];
            this.y = paintInfo.points[1];
            this.w = paintInfo.points[2];
            this.h = paintInfo.points[3];
            this.segment = paintInfo.segment;
            _updateSegmentProportions();
        };

        return {
            addSegment: _addSegment,
            prepareCompute: _prepareCompute,
            sourceStub: sourceStub,
            targetStub: targetStub,
            maxStub: Math.max(sourceStub, targetStub),
            sourceGap: sourceGap,
            targetGap: targetGap,
            maxGap: Math.max(sourceGap, targetGap),
            setGeometry:_setGeometry,
            getGeometry:_getGeometry
        };
    };
    _ju.extend(_jp.Connectors.AbstractConnector, AbstractComponent);


    // ********************************* END OF CONNECTOR TYPES *******************************************************************

    // ********************************* ENDPOINT TYPES *******************************************************************

    _jp.Endpoints.AbstractEndpoint = function (params) {
        AbstractComponent.apply(this, arguments);
        var compute = this.compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var out = this._compute.apply(this, arguments);
            this.x = out[0];
            this.y = out[1];
            this.w = out[2];
            this.h = out[3];
            this.bounds.minX = this.x;
            this.bounds.minY = this.y;
            this.bounds.maxX = this.x + this.w;
            this.bounds.maxY = this.y + this.h;
            return out;
        };
        return {
            compute: compute,
            cssClass: params.cssClass
        };
    };
    _ju.extend(_jp.Endpoints.AbstractEndpoint, AbstractComponent);

    /**
     * Class: Endpoints.Dot
     * A round endpoint, with default radius 10 pixels.
     */

    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    radius    -    radius of the endpoint.  defaults to 10 pixels.
     */
    _jp.Endpoints.Dot = function (params) {
        this.type = "Dot";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.radius = params.radius || 10;
        this.defaultOffset = 0.5 * this.radius;
        this.defaultInnerRadius = this.radius / 3;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.radius = endpointStyle.radius || this.radius;
            var x = anchorPoint[0] - this.radius,
                y = anchorPoint[1] - this.radius,
                w = this.radius * 2,
                h = this.radius * 2;

            if (endpointStyle.stroke) {
                var lw = endpointStyle.strokeWidth || 1;
                x -= lw;
                y -= lw;
                w += (lw * 2);
                h += (lw * 2);
            }
            return [ x, y, w, h, this.radius ];
        };
    };
    _ju.extend(_jp.Endpoints.Dot, _jp.Endpoints.AbstractEndpoint);

    _jp.Endpoints.Rectangle = function (params) {
        this.type = "Rectangle";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.width = params.width || 20;
        this.height = params.height || 20;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || this.width,
                height = endpointStyle.height || this.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);

            return [ x, y, width, height];
        };
    };
    _ju.extend(_jp.Endpoints.Rectangle, _jp.Endpoints.AbstractEndpoint);

    var DOMElementEndpoint = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.displayElements = [];
    };
    _ju.extend(DOMElementEndpoint, _jp.jsPlumbUIComponent, {
        getDisplayElements: function () {
            return this._jsPlumb.displayElements;
        },
        appendDisplayElement: function (el) {
            this._jsPlumb.displayElements.push(el);
        }
    });

    /**
     * Class: Endpoints.Image
     * Draws an image as the Endpoint.
     */
    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    src    -    location of the image to use.

     TODO: multiple references to self. not sure quite how to get rid of them entirely. perhaps self = null in the cleanup
     function will suffice

     TODO this class still might leak memory.

     */
    _jp.Endpoints.Image = function (params) {

        this.type = "Image";
        DOMElementEndpoint.apply(this, arguments);
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);

        var _onload = params.onload,
            src = params.src || params.url,
            clazz = params.cssClass ? " " + params.cssClass : "";

        this._jsPlumb.img = new Image();
        this._jsPlumb.ready = false;
        this._jsPlumb.initialized = false;
        this._jsPlumb.deleted = false;
        this._jsPlumb.widthToUse = params.width;
        this._jsPlumb.heightToUse = params.height;
        this._jsPlumb.endpoint = params.endpoint;

        this._jsPlumb.img.onload = function () {
            if (this._jsPlumb != null) {
                this._jsPlumb.ready = true;
                this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width;
                this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height;
                if (_onload) {
                    _onload(this);
                }
            }
        }.bind(this);

        /*
         Function: setImage
         Sets the Image to use in this Endpoint.

         Parameters:
         img         -   may be a URL or an Image object
         onload      -   optional; a callback to execute once the image has loaded.
         */
        this._jsPlumb.endpoint.setImage = function (_img, onload) {
            var s = _img.constructor == String ? _img : _img.src;
            _onload = onload;
            this._jsPlumb.img.src = s;

            if (this.canvas != null)
                this.canvas.setAttribute("src", this._jsPlumb.img.src);
        }.bind(this);

        this._jsPlumb.endpoint.setImage(src, _onload);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.anchorPoint = anchorPoint;
            if (this._jsPlumb.ready) return [anchorPoint[0] - this._jsPlumb.widthToUse / 2, anchorPoint[1] - this._jsPlumb.heightToUse / 2,
                this._jsPlumb.widthToUse, this._jsPlumb.heightToUse];
            else return [0, 0, 0, 0];
        };

        this.canvas = _jp.createElement("img", {
            position:"absolute",
            margin:0,
            padding:0,
            outline:0
        }, this._jsPlumb.instance.endpointClass + clazz);

        if (this._jsPlumb.widthToUse) this.canvas.setAttribute("width", this._jsPlumb.widthToUse);
        if (this._jsPlumb.heightToUse) this.canvas.setAttribute("height", this._jsPlumb.heightToUse);
        this._jsPlumb.instance.appendElement(this.canvas);

        this.actuallyPaint = function (d, style, anchor) {
            if (!this._jsPlumb.deleted) {
                if (!this._jsPlumb.initialized) {
                    this.canvas.setAttribute("src", this._jsPlumb.img.src);
                    this.appendDisplayElement(this.canvas);
                    this._jsPlumb.initialized = true;
                }
                var x = this.anchorPoint[0] - (this._jsPlumb.widthToUse / 2),
                    y = this.anchorPoint[1] - (this._jsPlumb.heightToUse / 2);
                _ju.sizeElement(this.canvas, x, y, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse);
            }
        };

        this.paint = function (style, anchor) {
            if (this._jsPlumb != null) {  // may have been deleted
                if (this._jsPlumb.ready) {
                    this.actuallyPaint(style, anchor);
                }
                else {
                    root.setTimeout(function () {
                        this.paint(style, anchor);
                    }.bind(this), 200);
                }
            }
        };
    };
    _ju.extend(_jp.Endpoints.Image, [ DOMElementEndpoint, _jp.Endpoints.AbstractEndpoint ], {
        cleanup: function (force) {
            if (force) {
                this._jsPlumb.deleted = true;
                if (this.canvas) this.canvas.parentNode.removeChild(this.canvas);
                this.canvas = null;
            }
        }
    });

    /*
     * Class: Endpoints.Blank
     * An Endpoint that paints nothing (visible) on the screen.  Supports cssClass and hoverClass parameters like all Endpoints.
     */
    _jp.Endpoints.Blank = function (params) {
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        this.type = "Blank";
        DOMElementEndpoint.apply(this, arguments);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            return [anchorPoint[0], anchorPoint[1], 10, 0];
        };

        var clazz = params.cssClass ? " " + params.cssClass : "";

        this.canvas = _jp.createElement("div", {
            display: "block",
            width: "1px",
            height: "1px",
            background: "transparent",
            position: "absolute"
        }, this._jsPlumb.instance.endpointClass + clazz);

        this._jsPlumb.instance.appendElement(this.canvas);

        this.paint = function (style, anchor) {
            _ju.sizeElement(this.canvas, this.x, this.y, this.w, this.h);
        };
    };
    _ju.extend(_jp.Endpoints.Blank, [_jp.Endpoints.AbstractEndpoint, DOMElementEndpoint], {
        cleanup: function () {
            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
        }
    });

    /*
     * Class: Endpoints.Triangle
     * A triangular Endpoint.
     */
    /*
     * Function: Constructor
     *
     * Parameters:
     *
     * 	width	-	width of the triangle's base.  defaults to 55 pixels.
     * 	height	-	height of the triangle from base to apex.  defaults to 55 pixels.
     */
    _jp.Endpoints.Triangle = function (params) {
        this.type = "Triangle";
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {  };
        params.width = params.width || 55;
        params.height = params.height || 55;
        this.width = params.width;
        this.height = params.height;
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || self.width,
                height = endpointStyle.height || self.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);
            return [ x, y, width, height ];
        };
    };
// ********************************* END OF ENDPOINT TYPES *******************************************************************


// ********************************* OVERLAY DEFINITIONS ***********************************************************************    

    var AbstractOverlay = _jp.Overlays.AbstractOverlay = function (params) {
        this.visible = true;
        this.isAppendedAtTopLevel = true;
        this.component = params.component;
        this.loc = params.location == null ? 0.5 : params.location;
        this.endpointLoc = params.endpointLocation == null ? [ 0.5, 0.5] : params.endpointLocation;
        this.visible = params.visible !== false;
    };
    AbstractOverlay.prototype = {
        cleanup: function (force) {
            if (force) {
                this.component = null;
                this.canvas = null;
                this.endpointLoc = null;
            }
        },
        reattach:function(instance) {

        },
        setVisible: function (val) {
            this.visible = val;
            this.component.repaint();
        },
        isVisible: function () {
            return this.visible;
        },
        hide: function () {
            this.setVisible(false);
        },
        show: function () {
            this.setVisible(true);
        },
        incrementLocation: function (amount) {
            this.loc += amount;
            this.component.repaint();
        },
        setLocation: function (l) {
            this.loc = l;
            this.component.repaint();
        },
        getLocation: function () {
            return this.loc;
        },
        updateFrom:function() { }
    };


    /*
     * Class: Overlays.Arrow
     *
     * An arrow overlay, defined by four points: the head, the two sides of the tail, and a 'foldback' point at some distance along the length
     * of the arrow that lines from each tail point converge into.  The foldback point is defined using a decimal that indicates some fraction
     * of the length of the arrow and has a default value of 0.623.  A foldback point value of 1 would mean that the arrow had a straight line
     * across the tail.
     */
    /*
     * @constructor
     *
     * @param {Object} params Constructor params.
     * @param {Number} [params.length] Distance in pixels from head to tail baseline. default 20.
     * @param {Number} [params.width] Width in pixels of the tail baseline. default 20.
     * @param {String} [params.fill] Style to use when filling the arrow.  defaults to "black".
     * @param {String} [params.stroke] Style to use when stroking the arrow. defaults to null, which means the arrow is not stroked.
     * @param {Number} [params.stroke-width] Line width to use when stroking the arrow. defaults to 1, but only used if stroke is not null.
     * @param {Number} [params.foldback] Distance (as a decimal from 0 to 1 inclusive) along the length of the arrow marking the point the tail points should fold back to.  defaults to 0.623.
     * @param {Number} [params.location] Distance (as a decimal from 0 to 1 inclusive) marking where the arrow should sit on the connector. defaults to 0.5.
     * @param {NUmber} [params.direction] Indicates the direction the arrow points in. valid values are -1 and 1; 1 is default.
     */
    _jp.Overlays.Arrow = function (params) {
        this.type = "Arrow";
        AbstractOverlay.apply(this, arguments);
        this.isAppendedAtTopLevel = false;
        params = params || {};

        this.length = params.length || 20;
        this.width = params.width || 20;
        this.id = params.id;
        var direction = (params.direction || 1) < 0 ? -1 : 1,
            paintStyle = params.paintStyle || { "stroke-width": 1 },
        // how far along the arrow the lines folding back in come to. default is 62.3%.
            foldback = params.foldback || 0.623;

        this.computeMaxSize = function () {
            return self.width * 1.5;
        };

        this.elementCreated = function(p, component) {
            this.path = p;
            if (params.events) {
                for (var i in params.events) {
                    _jp.on(p, i, params.events[i]);
                }
            }
        };

        this.draw = function (component, currentConnectionPaintStyle) {

            var hxy, mid, txy, tail, cxy;
            if (component.pointAlongPathFrom) {

                if (_ju.isString(this.loc) || this.loc > 1 || this.loc < 0) {
                    var l = parseInt(this.loc, 10),
                        fromLoc = this.loc < 0 ? 1 : 0;
                    hxy = component.pointAlongPathFrom(fromLoc, l, false);
                    mid = component.pointAlongPathFrom(fromLoc, l - (direction * this.length / 2), false);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }
                else if (this.loc == 1) {
                    hxy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, -(this.length));
                    txy = _jg.pointOnLine(hxy, mid, this.length);

                    if (direction == -1) {
                        var _ = txy;
                        txy = hxy;
                        hxy = _;
                    }
                }
                else if (this.loc === 0) {
                    txy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, this.length);
                    hxy = _jg.pointOnLine(txy, mid, this.length);
                    if (direction == -1) {
                        var __ = txy;
                        txy = hxy;
                        hxy = __;
                    }
                }
                else {
                    hxy = component.pointAlongPathFrom(this.loc, direction * this.length / 2);
                    mid = component.pointOnPath(this.loc);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }

                tail = _jg.perpendicularLineTo(hxy, txy, this.width);
                cxy = _jg.pointOnLine(hxy, txy, foldback * this.length);

                var d = { hxy: hxy, tail: tail, cxy: cxy },
                    stroke = paintStyle.stroke || currentConnectionPaintStyle.stroke,
                    fill = paintStyle.fill || currentConnectionPaintStyle.stroke,
                    lineWidth = paintStyle.strokeWidth || currentConnectionPaintStyle.strokeWidth;

                return {
                    component: component,
                    d: d,
                    "stroke-width": lineWidth,
                    stroke: stroke,
                    fill: fill,
                    minX: Math.min(hxy.x, tail[0].x, tail[1].x),
                    maxX: Math.max(hxy.x, tail[0].x, tail[1].x),
                    minY: Math.min(hxy.y, tail[0].y, tail[1].y),
                    maxY: Math.max(hxy.y, tail[0].y, tail[1].y)
                };
            }
            else return {component: component, minX: 0, maxX: 0, minY: 0, maxY: 0};
        };
    };
    _ju.extend(_jp.Overlays.Arrow, AbstractOverlay, {
        updateFrom:function(d) {
            this.length = d.length || this.length;
            this.width = d.width|| this.width;
            this.direction = d.direction != null ? d.direction : this.direction;
            this.foldback = d.foldback|| this.foldback;
        }
    });

    /*
     * Class: Overlays.PlainArrow
     *
     * A basic arrow.  This is in fact just one instance of the more generic case in which the tail folds back on itself to some
     * point along the length of the arrow: in this case, that foldback point is the full length of the arrow.  so it just does
     * a 'call' to Arrow with foldback set appropriately.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.PlainArrow = function (params) {
        params = params || {};
        var p = _jp.extend(params, {foldback: 1});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "PlainArrow";
    };
    _ju.extend(_jp.Overlays.PlainArrow, _jp.Overlays.Arrow);

    /*
     * Class: Overlays.Diamond
     * 
     * A diamond. Like PlainArrow, this is a concrete case of the more generic case of the tail points converging on some point...it just
     * happens that in this case, that point is greater than the length of the the arrow.
     *
     *      this could probably do with some help with positioning...due to the way it reuses the Arrow paint code, what Arrow thinks is the
     *      center is actually 1/4 of the way along for this guy.  but we don't have any knowledge of pixels at this point, so we're kind of
     *      stuck when it comes to helping out the Arrow class. possibly we could pass in a 'transpose' parameter or something. the value
     *      would be -l/4 in this case - move along one quarter of the total length.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.Diamond = function (params) {
        params = params || {};
        var l = params.length || 40,
            p = _jp.extend(params, {length: l / 2, foldback: 2});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "Diamond";
    };
    _ju.extend(_jp.Overlays.Diamond, _jp.Overlays.Arrow);

    var _getDimensions = function (component, forceRefresh) {
        if (component._jsPlumb.cachedDimensions == null || forceRefresh)
            component._jsPlumb.cachedDimensions = component.getDimensions();
        return component._jsPlumb.cachedDimensions;
    };

    // abstract superclass for overlays that add an element to the DOM.
    var AbstractDOMOverlay = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        AbstractOverlay.apply(this, arguments);

        // hand off fired events to associated component.
        var _f = this.fire;
        this.fire = function () {
            _f.apply(this, arguments);
            if (this.component) this.component.fire.apply(this.component, arguments);
        };

        this.detached=false;
        this.id = params.id;
        this._jsPlumb.div = null;
        this._jsPlumb.initialised = false;
        this._jsPlumb.component = params.component;
        this._jsPlumb.cachedDimensions = null;
        this._jsPlumb.create = params.create;
        this._jsPlumb.initiallyInvisible = params.visible === false;

        this.getElement = function () {
            if (this._jsPlumb.div == null) {
                var div = this._jsPlumb.div = _jp.getElement(this._jsPlumb.create(this._jsPlumb.component));
                div.style.position = "absolute";
                div.className = this._jsPlumb.instance.overlayClass + " " +
                    (this.cssClass ? this.cssClass :
                        params.cssClass ? params.cssClass : "");
                this._jsPlumb.instance.appendElement(div);
                this._jsPlumb.instance.getId(div);
                this.canvas = div;

                // in IE the top left corner is what it placed at the desired location.  This will not
                // be fixed. IE8 is not going to be supported for much longer.
                var ts = "translate(-50%, -50%)";
                div.style.webkitTransform = ts;
                div.style.mozTransform = ts;
                div.style.msTransform = ts;
                div.style.oTransform = ts;
                div.style.transform = ts;

                // write the related component into the created element
                div._jsPlumb = this;

                if (params.visible === false)
                    div.style.display = "none";
            }
            return this._jsPlumb.div;
        };

        this.draw = function (component, currentConnectionPaintStyle, absolutePosition) {
            var td = _getDimensions(this);
            if (td != null && td.length == 2) {
                var cxy = { x: 0, y: 0 };

                // absolutePosition would have been set by a call to connection.setAbsoluteOverlayPosition.
                if (absolutePosition) {
                    cxy = { x: absolutePosition[0], y: absolutePosition[1] };
                }
                else if (component.pointOnPath) {
                    var loc = this.loc, absolute = false;
                    if (_ju.isString(this.loc) || this.loc < 0 || this.loc > 1) {
                        loc = parseInt(this.loc, 10);
                        absolute = true;
                    }
                    cxy = component.pointOnPath(loc, absolute);  // a connection
                }
                else {
                    var locToUse = this.loc.constructor == Array ? this.loc : this.endpointLoc;
                    cxy = { x: locToUse[0] * component.w,
                        y: locToUse[1] * component.h };
                }

                var minx = cxy.x - (td[0] / 2),
                    miny = cxy.y - (td[1] / 2);

                return {
                    component: component,
                    d: { minx: minx, miny: miny, td: td, cxy: cxy },
                    minX: minx,
                    maxX: minx + td[0],
                    minY: miny,
                    maxY: miny + td[1]
                };
            }
            else return {minX: 0, maxX: 0, minY: 0, maxY: 0};
        };
    };
    _ju.extend(AbstractDOMOverlay, [_jp.jsPlumbUIComponent, AbstractOverlay], {
        getDimensions: function () {
            return [1,1];
        },
        setVisible: function (state) {
            if (this._jsPlumb.div) {
                this._jsPlumb.div.style.display = state ? "block" : "none";
                // if initially invisible, dimensions are 0,0 and never get updated
                if (state && this._jsPlumb.initiallyInvisible) {
                    _getDimensions(this, true);
                    this.component.repaint();
                    this._jsPlumb.initiallyInvisible = false;
                }
            }
        },
        /*
         * Function: clearCachedDimensions
         * Clears the cached dimensions for the label. As a performance enhancement, label dimensions are
         * cached from 1.3.12 onwards. The cache is cleared when you change the label text, of course, but
         * there are other reasons why the text dimensions might change - if you make a change through CSS, for
         * example, you might change the font size.  in that case you should explicitly call this method.
         */
        clearCachedDimensions: function () {
            this._jsPlumb.cachedDimensions = null;
        },
        cleanup: function (force) {
            if (force) {
                if (this._jsPlumb.div != null) {
                    this._jsPlumb.div._jsPlumb = null;
                    this._jsPlumb.instance.removeElement(this._jsPlumb.div);
                }
            }
            else {
                // if not a forced cleanup, just detach child from parent for now.
                if (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode)
                    this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
                this.detached = true;
            }

        },
        reattach:function(instance) {
            if (this._jsPlumb.div != null) instance.getContainer().appendChild(this._jsPlumb.div);
            this.detached = false;
        },
        computeMaxSize: function () {
            var td = _getDimensions(this);
            return Math.max(td[0], td[1]);
        },
        paint: function (p, containerExtents) {
            if (!this._jsPlumb.initialised) {
                this.getElement();
                p.component.appendDisplayElement(this._jsPlumb.div);
                this._jsPlumb.initialised = true;
                if (this.detached) this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
            }
            this._jsPlumb.div.style.left = (p.component.x + p.d.minx) + "px";
            this._jsPlumb.div.style.top = (p.component.y + p.d.miny) + "px";
        }
    });

    /*
     * Class: Overlays.Custom
     * A Custom overlay. You supply a 'create' function which returns some DOM element, and jsPlumb positions it.
     * The 'create' function is passed a Connection or Endpoint.
     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	create - function for jsPlumb to call that returns a DOM element.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 	
     */
    _jp.Overlays.Custom = function (params) {
        this.type = "Custom";
        AbstractDOMOverlay.apply(this, arguments);
    };
    _ju.extend(_jp.Overlays.Custom, AbstractDOMOverlay);

    _jp.Overlays.GuideLines = function () {
        var self = this;
        self.length = 50;
        self.strokeWidth = 5;
        this.type = "GuideLines";
        AbstractOverlay.apply(this, arguments);
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this.draw = function (connector, currentConnectionPaintStyle) {

            var head = connector.pointAlongPathFrom(self.loc, self.length / 2),
                mid = connector.pointOnPath(self.loc),
                tail = _jg.pointOnLine(head, mid, self.length),
                tailLine = _jg.perpendicularLineTo(head, tail, 40),
                headLine = _jg.perpendicularLineTo(tail, head, 20);

            return {
                connector: connector,
                head: head,
                tail: tail,
                headLine: headLine,
                tailLine: tailLine,
                minX: Math.min(head.x, tail.x, headLine[0].x, headLine[1].x),
                minY: Math.min(head.y, tail.y, headLine[0].y, headLine[1].y),
                maxX: Math.max(head.x, tail.x, headLine[0].x, headLine[1].x),
                maxY: Math.max(head.y, tail.y, headLine[0].y, headLine[1].y)
            };
        };

        // this.cleanup = function() { };  // nothing to clean up for GuideLines
    };

    /*
     * Class: Overlays.Label

     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * 	cssClass - optional css class string to append to css class. This string is appended "as-is", so you can of course have multiple classes
     *             defined.  This parameter is preferred to using labelStyle, borderWidth and borderStyle.
     * 	label - the label to paint.  May be a string or a function that returns a string.  Nothing will be painted if your label is null or your
     *         label function returns null.  empty strings _will_ be painted.
     * 	location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * 	id - optional id to use for later retrieval of this overlay.
     * 
     * 	
     */
    _jp.Overlays.Label = function (params) {
        this.labelStyle = params.labelStyle;

        var labelWidth = null, labelHeight = null, labelText = null, labelPadding = null;
        this.cssClass = this.labelStyle != null ? this.labelStyle.cssClass : null;
        var p = _jp.extend({
            create: function () {
                return _jp.createElement("div");
            }}, params);
        _jp.Overlays.Custom.call(this, p);
        this.type = "Label";
        this.label = params.label || "";
        this.labelText = null;
        if (this.labelStyle) {
            var el = this.getElement();
            this.labelStyle.font = this.labelStyle.font || "12px sans-serif";
            el.style.font = this.labelStyle.font;
            el.style.color = this.labelStyle.color || "black";
            if (this.labelStyle.fill) el.style.background = this.labelStyle.fill;
            if (this.labelStyle.borderWidth > 0) {
                var dStyle = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : "black";
                el.style.border = this.labelStyle.borderWidth + "px solid " + dStyle;
            }
            if (this.labelStyle.padding) el.style.padding = this.labelStyle.padding;
        }

    };
    _ju.extend(_jp.Overlays.Label, _jp.Overlays.Custom, {
        cleanup: function (force) {
            if (force) {
                this.div = null;
                this.label = null;
                this.labelText = null;
                this.cssClass = null;
                this.labelStyle = null;
            }
        },
        getLabel: function () {
            return this.label;
        },
        /*
         * Function: setLabel
         * sets the label's, um, label.  you would think i'd call this function
         * 'setText', but you can pass either a Function or a String to this, so
         * it makes more sense as 'setLabel'. This uses innerHTML on the label div, so keep
         * that in mind if you need escaped HTML.
         */
        setLabel: function (l) {
            this.label = l;
            this.labelText = null;
            this.clearCachedDimensions();
            this.update();
            this.component.repaint();
        },
        getDimensions: function () {
            this.update();
            return AbstractDOMOverlay.prototype.getDimensions.apply(this, arguments);
        },
        update: function () {
            if (typeof this.label == "function") {
                var lt = this.label(this);
                this.getElement().innerHTML = lt.replace(/\r\n/g, "<br/>");
            }
            else {
                if (this.labelText == null) {
                    this.labelText = this.label;
                    this.getElement().innerHTML = this.labelText.replace(/\r\n/g, "<br/>");
                }
            }
        },
        updateFrom:function(d) {
            if(d.label != null){
                this.setLabel(d.label);
            }
        }
    });

    // ********************************* END OF OVERLAY DEFINITIONS ***********************************************************************

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base class for library adapters.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    "use strict";
    var root = this,
        _jp = root.jsPlumb;

    var _getEventManager = function(instance) {
        var e = instance._mottle;
        if (!e) {
            e = instance._mottle = new root.Mottle();
        }
        return e;
    };

    _jp.extend(root.jsPlumbInstance.prototype, {
        getEventManager:function() {
            return _getEventManager(this);
        },
        on : function(el, event, callback) {
            // TODO: here we would like to map the tap event if we know its
            // an internal bind to a click. we have to know its internal because only
            // then can we be sure that the UP event wont be consumed (tap is a synthesized
            // event from a mousedown followed by a mouseup).
            //event = { "click":"tap", "dblclick":"dbltap"}[event] || event;
            this.getEventManager().on.apply(this, arguments);
            return this;
        },
        off : function(el, event, callback) {
            this.getEventManager().off.apply(this, arguments);
            return this;
        }
    });


}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the code for working with Groups.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    "use strict";

    var root = this,
        _ju = root.jsPlumbUtil,
        _jpi = root.jsPlumbInstance;

    var GROUP_COLLAPSED_CLASS = "jtk-group-collapsed";
    var GROUP_EXPANDED_CLASS = "jtk-group-expanded";
    var GROUP_CONTAINER_SELECTOR = "[jtk-group-content]";
    var ELEMENT_DRAGGABLE_EVENT = "elementDraggable";
    var STOP = "stop";
    var REVERT = "revert";
    var GROUP_MANAGER = "_groupManager";
    var GROUP = "_jsPlumbGroup";
    var GROUP_DRAG_SCOPE = "_jsPlumbGroupDrag";
    var EVT_CHILD_ADDED = "group:addMember";
    var EVT_CHILD_REMOVED = "group:removeMember";
    var EVT_GROUP_ADDED = "group:add";
    var EVT_GROUP_REMOVED = "group:remove";
    var EVT_EXPAND = "group:expand";
    var EVT_COLLAPSE = "group:collapse";

    var GroupManager = function(_jsPlumb) {
        var _managedGroups = {}, _connectionSourceMap = {}, _connectionTargetMap = {}, self = this;

        _jsPlumb.bind("connection", function(p) {
            if (p.source[GROUP] != null && p.target[GROUP] != null && p.source[GROUP] === p.target[GROUP]) {
                _connectionSourceMap[p.connection.id] = p.source[GROUP];
                _connectionTargetMap[p.connection.id] = p.source[GROUP];
            }
            else {
                if (p.source[GROUP] != null) {
                    _ju.suggest(p.source[GROUP].connections.source, p.connection);
                    _connectionSourceMap[p.connection.id] = p.source[GROUP];
                }
                if (p.target[GROUP] != null) {
                    _ju.suggest(p.target[GROUP].connections.target, p.connection);
                    _connectionTargetMap[p.connection.id] = p.target[GROUP];
                }
            }
        });

        function _cleanupDetachedConnection(conn) {
            delete conn.proxies;
            var group = _connectionSourceMap[conn.id], f;
            if (group != null) {
                f = function(c) { return c.id === conn.id; };
                _ju.removeWithFunction(group.connections.source, f);
                _ju.removeWithFunction(group.connections.target, f);
                delete _connectionSourceMap[conn.id];
            }

            group = _connectionTargetMap[conn.id];
            if (group != null) {
                f = function(c) { return c.id === conn.id; };
                _ju.removeWithFunction(group.connections.source, f);
                _ju.removeWithFunction(group.connections.target, f);
                delete _connectionTargetMap[conn.id];
            }
        }

        _jsPlumb.bind("internal.connectionDetached", function(p) {
            _cleanupDetachedConnection(p.connection);
        });

        _jsPlumb.bind("connectionMoved", function(p) {
            var connMap = p.index === 0 ? _connectionSourceMap : _connectionTargetMap;
            var group = connMap[p.connection.id];
            if (group) {
                var list = group.connections[p.index === 0 ? "source" : "target"];
                var idx = list.indexOf(p.connection);
                if (idx != -1) {
                    list.splice(idx, 1);
                }
            }
        });

        this.addGroup = function(group) {
            _jsPlumb.addClass(group.getEl(), GROUP_EXPANDED_CLASS);
            _managedGroups[group.id] = group;
            group.manager = this;
            _updateConnectionsForGroup(group);
            _jsPlumb.fire(EVT_GROUP_ADDED, { group:group });
        };

        this.addToGroup = function(group, el, doNotFireEvent) {
            group = this.getGroup(group);
            if (group) {
                //group.add(el, doNotFireEvent);
                var groupEl = group.getEl();

                if (el._isJsPlumbGroup) return;
                var currentGroup = el._jsPlumbGroup;
                // if already a member of this group, do nothing
                if (currentGroup !== group) {
                    var elpos = _jsPlumb.getOffset(el, true);
                    var cpos = group.collapsed ? _jsPlumb.getOffset(groupEl, true) : _jsPlumb.getOffset(group.getDragArea(), true);

                    // otherwise, transfer to this group.
                    if (currentGroup != null) {
                        currentGroup.remove(el, doNotFireEvent);
                        self.updateConnectionsForGroup(currentGroup);
                    }
                    group.add(el, doNotFireEvent);

                    var handleDroppedConnections = function (list, index) {
                        var oidx = index == 0 ? 1 : 0;
                        list.each(function (c) {
                            c.setVisible(false);
                            if (c.endpoints[oidx].element._jsPlumbGroup === group) {
                                c.endpoints[oidx].setVisible(false);
                                self.expandConnection(c, oidx, group);
                            }
                            else {
                                c.endpoints[index].setVisible(false);
                                self.collapseConnection(c, index, group);
                            }
                        });
                    };

                    if (group.collapsed) {
                        handleDroppedConnections(_jsPlumb.select({source: el}), 0);
                        handleDroppedConnections(_jsPlumb.select({target: el}), 1);
                    }

                    var elId = _jsPlumb.getId(el);
                    _jsPlumb.dragManager.setParent(el, elId, groupEl, _jsPlumb.getId(groupEl), elpos);

                    var newPosition = { left: elpos.left - cpos.left, top: elpos.top - cpos.top };

                    _jsPlumb.setPosition(el, newPosition);

                    _jsPlumb.dragManager.revalidateParent(el, elId, elpos);

                    self.updateConnectionsForGroup(group);

                    _jsPlumb.revalidate(elId);

                    setTimeout(function () {
                        _jsPlumb.fire(EVT_CHILD_ADDED, {group: group, el: el});
                    }, 0);
                }
            }
        };

        this.removeFromGroup = function(group, el, doNotFireEvent) {
            group = this.getGroup(group);
            if (group) {
                group.remove(el, null, doNotFireEvent);
            }
        };

        this.getGroup = function(groupId) {
            var group = groupId;
            if (_ju.isString(groupId)) {
                group = _managedGroups[groupId];
                if (group == null) throw new TypeError("No such group [" + groupId + "]");
            }
            return group;
        };

        this.getGroups = function() {
            var o = [];
            for (var g in _managedGroups) {
                o.push(_managedGroups[g]);
            }
            return o;
        };

        this.removeGroup = function(group, deleteMembers, manipulateDOM, doNotFireEvent) {
            group = this.getGroup(group);
            this.expandGroup(group, true); // this reinstates any original connections and removes all proxies, but does not fire an event.
            group[deleteMembers ? "removeAll" : "orphanAll"](manipulateDOM, doNotFireEvent);
            _jsPlumb.remove(group.getEl());
            delete _managedGroups[group.id];
            delete _jsPlumb._groups[group.id];
            _jsPlumb.fire(EVT_GROUP_REMOVED, { group:group });
        };

        this.removeAllGroups = function(deleteMembers, manipulateDOM, doNotFireEvent) {
            for (var g in _managedGroups) {
                this.removeGroup(_managedGroups[g], deleteMembers, manipulateDOM, doNotFireEvent);
            }
        };

        function _setVisible(group, state) {
            var m = group.getMembers();
            for (var i = 0; i < m.length; i++) {
                _jsPlumb[state ? "show" : "hide"](m[i], true);
            }
        }

        var _collapseConnection = this.collapseConnection = function(c, index, group) {

            var proxyEp, groupEl = group.getEl(), groupElId = _jsPlumb.getId(groupEl),
                originalElementId = c.endpoints[index].elementId;

            var otherEl = c.endpoints[index === 0 ? 1 : 0].element;
            if (otherEl[GROUP] && (!otherEl[GROUP].shouldProxy() && otherEl[GROUP].collapsed)) {
                return;
            }

            c.proxies = c.proxies || [];
            if(c.proxies[index]) {
                proxyEp = c.proxies[index].ep;
            }else {
                proxyEp = _jsPlumb.addEndpoint(groupEl, {
                    endpoint:group.getEndpoint(c, index),
                    anchor:group.getAnchor(c, index),
                    parameters:{
                        isProxyEndpoint:true
                    }
                });
                //proxyEp._forceDeleteOnDetach = true;
            }
            // for this index, stash proxy info: the new EP, the original EP.
            c.proxies[index] = { ep:proxyEp, originalEp: c.endpoints[index] };

            // and advise the anchor manager
            if (index === 0) {
                // TODO why are there two differently named methods? Why is there not one method that says "some end of this
                // connection changed (you give the index), and here's the new element and element id."
                _jsPlumb.anchorManager.sourceChanged(originalElementId, groupElId, c, groupEl);
            }
            else {
                _jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId, originalElementId, groupElId, c);
                c.target = groupEl;
                c.targetId = groupElId;
            }


            // detach the original EP from the connection.
            c.proxies[index].originalEp.detachFromConnection(c, null, true);

            // set the proxy as the new ep
            proxyEp.connections = [ c ];
            c.endpoints[index] = proxyEp;

            c.setVisible(true);
        };

        this.collapseGroup = function(group) {
            group = this.getGroup(group);
            if (group == null || group.collapsed) return;
            var groupEl = group.getEl();

            // todo remove old proxy endpoints first, just in case?
            //group.proxies.length = 0;

            // hide all connections
            _setVisible(group, false);

            if (group.shouldProxy()) {
                // collapses all connections in a group.
                var _collapseSet = function (conns, index) {
                    for (var i = 0; i < conns.length; i++) {
                        var c = conns[i];
                        _collapseConnection(c, index, group);
                    }
                };

                // setup proxies for sources and targets
                _collapseSet(group.connections.source, 0);
                _collapseSet(group.connections.target, 1);
            }

            group.collapsed = true;
            _jsPlumb.removeClass(groupEl, GROUP_EXPANDED_CLASS);
            _jsPlumb.addClass(groupEl, GROUP_COLLAPSED_CLASS);
            _jsPlumb.revalidate(groupEl);
            _jsPlumb.fire(EVT_COLLAPSE, { group:group  });
        };

        var _expandConnection = this.expandConnection = function(c, index, group) {

            // if no proxies or none for this end of the connection, abort.
            if (c.proxies == null || c.proxies[index] == null) return;

            var groupElId = _jsPlumb.getId(group.getEl()),
                originalElement = c.proxies[index].originalEp.element,
                originalElementId = c.proxies[index].originalEp.elementId;

            c.endpoints[index] = c.proxies[index].originalEp;
            // and advise the anchor manager
            if (index === 0) {
                // TODO why are there two differently named methods? Why is there not one method that says "some end of this
                // connection changed (you give the index), and here's the new element and element id."
                _jsPlumb.anchorManager.sourceChanged(groupElId, originalElementId, c, originalElement);
            }
            else {
                _jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId, groupElId, originalElementId, c);
                c.target = originalElement;
                c.targetId = originalElementId;
            }

            // detach the proxy EP from the connection.
            c.proxies[index].ep.detachFromConnection(c, null, true);


            c.proxies[index].originalEp.addConnection(c);

            // cleanup
            delete c.proxies[index];
        };

        this.expandGroup = function(group, doNotFireEvent) {

            group = this.getGroup(group);

            if (group == null || !group.collapsed) return;
            var groupEl = group.getEl();

            _setVisible(group, true);

            if (group.shouldProxy()) {
                // collapses all connections in a group.
                var _expandSet = function (conns, index) {
                    for (var i = 0; i < conns.length; i++) {
                        var c = conns[i];
                        _expandConnection(c, index, group);
                    }
                };

                // setup proxies for sources and targets
                _expandSet(group.connections.source, 0);
                _expandSet(group.connections.target, 1);
            }

            group.collapsed = false;
            _jsPlumb.addClass(groupEl, GROUP_EXPANDED_CLASS);
            _jsPlumb.removeClass(groupEl, GROUP_COLLAPSED_CLASS);
            _jsPlumb.revalidate(groupEl);
            this.repaintGroup(group);
            if (!doNotFireEvent) {
                _jsPlumb.fire(EVT_EXPAND, { group: group});
            }
        };

        this.repaintGroup = function(group) {
            group = this.getGroup(group);
            var m = group.getMembers();
            for (var i = 0; i < m.length; i++) {
                _jsPlumb.revalidate(m[i]);
            }
        };

        // TODO refactor this with the code that responds to `connection` events.
        function _updateConnectionsForGroup(group) {
            var members = group.getMembers();
            var c1 = _jsPlumb.getConnections({source:members}, true);
            var c2 = _jsPlumb.getConnections({target:members}, true);
            var processed = {};
            group.connections.source.length = 0;
            group.connections.target.length = 0;
            var oneSet = function(c) {
                for (var i = 0; i < c.length; i++) {
                    if (processed[c[i].id]) continue;
                    processed[c[i].id] = true;
                    if (c[i].source._jsPlumbGroup === group) {
                        if (c[i].target._jsPlumbGroup !== group) {
                            group.connections.source.push(c[i]);
                        }
                        _connectionSourceMap[c[i].id] = group;
                    }
                    else if (c[i].target._jsPlumbGroup === group) {
                        group.connections.target.push(c[i]);
                        _connectionTargetMap[c[i].id] = group;
                    }
                }
            };
            oneSet(c1); oneSet(c2);
        }

        this.updateConnectionsForGroup = _updateConnectionsForGroup;
        this.refreshAllGroups = function() {
            for (var g in _managedGroups) {
                _updateConnectionsForGroup(_managedGroups[g]);
                _jsPlumb.dragManager.updateOffsets(_jsPlumb.getId(_managedGroups[g].getEl()));
            }
        };
    };

    /**
     *
     * @param {jsPlumbInstance} _jsPlumb Associated jsPlumb instance.
     * @param {Object} params
     * @param {Element} params.el The DOM element representing the Group.
     * @param {String} [params.id] Optional ID for the Group. A UUID will be assigned as the Group's ID if you do not provide one.
     * @param {Boolean} [params.constrain=false] If true, child elements will not be able to be dragged outside of the Group container.
     * @param {Boolean} [params.revert=true] By default, child elements revert to the container if dragged outside. You can change this by setting `revert:false`. This behaviour is also overridden if you set `orphan` or `prune`.
     * @param {Boolean} [params.orphan=false] If true, child elements dropped outside of the Group container will be removed from the Group (but not from the DOM).
     * @param {Boolean} [params.prune=false] If true, child elements dropped outside of the Group container will be removed from the Group and also from the DOM.
     * @param {Boolean} [params.dropOverride=false] If true, a child element that has been dropped onto some other Group will not be subject to the controls imposed by `prune`, `revert` or `orphan`.
     * @constructor
     */
    var Group = function(_jsPlumb, params) {
        var self = this;
        var el = params.el;
        this.getEl = function() { return el; };
        this.id = params.id || _ju.uuid();
        el._isJsPlumbGroup = true;

        var getDragArea = this.getDragArea = function() {
            var da = _jsPlumb.getSelector(el, GROUP_CONTAINER_SELECTOR);
            return da && da.length > 0 ? da[0] : el;
        };

        var ghost = params.ghost === true;
        var constrain = ghost || (params.constrain === true);
        var revert = params.revert !== false;
        var orphan = params.orphan === true;
        var prune = params.prune === true;
        var dropOverride = params.dropOverride === true;
        var proxied = params.proxied !== false;
        var elements = [];
        this.connections = { source:[], target:[], internal:[] };

        // this function, and getEndpoint below, are stubs for a future setup in which we can choose endpoint
        // and anchor based upon the connection and the index (source/target) of the endpoint to be proxied.
        this.getAnchor = function(conn, endpointIndex) {
            return params.anchor || "Continuous";
        };

        this.getEndpoint = function(conn, endpointIndex) {
            return params.endpoint || [ "Dot", { radius:10 }];
        };

        this.collapsed = false;
        if (params.draggable !== false) {
            var opts = {
                stop:function(params) {
                    _jsPlumb.fire("groupDragStop", jsPlumb.extend(params, {group:self}));
                },
                scope:GROUP_DRAG_SCOPE
            };
            if (params.dragOptions) {
                root.jsPlumb.extend(opts, params.dragOptions);
            }
            _jsPlumb.draggable(params.el, opts);
        }
        if (params.droppable !== false) {
            _jsPlumb.droppable(params.el, {
                drop:function(p) {
                    var el = p.drag.el;
                    if (el._isJsPlumbGroup) return;
                    var currentGroup = el._jsPlumbGroup;
                    if (currentGroup !== self) {
                        if (currentGroup != null) {
                            if (currentGroup.overrideDrop(el, self)) {
                                return;
                            }
                        }
                        _jsPlumb.getGroupManager().addToGroup(self, el, false);
                    }

                }
            });
        }
        var _each = function(_el, fn) {
            var els = _el.nodeType == null ?  _el : [ _el ];
            for (var i = 0; i < els.length; i++) {
                fn(els[i]);
            }
        };

        this.overrideDrop = function(_el, targetGroup) {
            return dropOverride && (revert || prune || orphan);
        };

        this.add = function(_el, doNotFireEvent) {
            var dragArea = getDragArea();
            _each(_el, function(__el) {

                if (__el._jsPlumbGroup != null) {
                    if (__el._jsPlumbGroup === self) {
                        return;
                    } else {
                        __el._jsPlumbGroup.remove(__el, true, doNotFireEvent, false);
                    }
                }

                __el._jsPlumbGroup = self;
                elements.push(__el);
                // test if draggable and add handlers if so.
                if (_jsPlumb.isAlreadyDraggable(__el)) {
                    _bindDragHandlers(__el);
                }

                if (__el.parentNode != dragArea) {
                    dragArea.appendChild(__el);
                }

                if (!doNotFireEvent) {
                    _jsPlumb.fire(EVT_CHILD_ADDED, {group: self, el: __el});
                }
            });

            _jsPlumb.getGroupManager().updateConnectionsForGroup(self);
        };

        this.remove = function(el, manipulateDOM, doNotFireEvent, doNotUpdateConnections) {

            _each(el, function(__el) {
                delete __el._jsPlumbGroup;
                _ju.removeWithFunction(elements, function(e) {
                    return e === __el;
                });

                if (manipulateDOM) {
                    try { self.getDragArea().removeChild(__el); }
                    catch (e) {
                        jsPlumbUtil.log("Could not remove element from Group " + e);
                    }
                }
                _unbindDragHandlers(__el);
                if (!doNotFireEvent) {
                    _jsPlumb.fire(EVT_CHILD_REMOVED, {group: self, el: __el});
                }
            });
            if (!doNotUpdateConnections) {
                _jsPlumb.getGroupManager().updateConnectionsForGroup(self);
            }
        };
        this.removeAll = function(manipulateDOM, doNotFireEvent) {
            for (var i = 0, l = elements.length; i < l; i++) {
                self.remove(elements[0], manipulateDOM, doNotFireEvent, true);
            }
            elements.length = 0;
            _jsPlumb.getGroupManager().updateConnectionsForGroup(self);
        };
        this.orphanAll = function() {
            for (var i = 0; i < elements.length; i++) {
                _orphan(elements[i]);
            }
            elements.length = 0;
        };
        this.getMembers = function() { return elements; };

        el[GROUP] = this;

        _jsPlumb.bind(ELEMENT_DRAGGABLE_EVENT, function(dragParams) {
            // if its for the current group,
            if (dragParams.el._jsPlumbGroup == this) {
                _bindDragHandlers(dragParams.el);
            }
        }.bind(this));

        function _findParent(_el) {
            return _el.offsetParent;
        }

        function _isInsideParent(_el, pos) {
            var p = _findParent(_el),
                s = _jsPlumb.getSize(p),
                ss = _jsPlumb.getSize(_el),
                leftEdge = pos[0],
                rightEdge = leftEdge + ss[0],
                topEdge = pos[1],
                bottomEdge = topEdge + ss[1];

            return rightEdge > 0 && leftEdge < s[0] && bottomEdge > 0 && topEdge < s[1];
        }

        //
        // orphaning an element means taking it out of the group and adding it to the main jsplumb container.
        //
        function _orphan(_el) {
            var id = _jsPlumb.getId(_el);
            var pos = _jsPlumb.getOffset(_el);
            _el.parentNode.removeChild(_el);
            _jsPlumb.getContainer().appendChild(_el);
            _jsPlumb.setPosition(_el, pos);
            delete _el._jsPlumbGroup;
            _unbindDragHandlers(_el);
            _jsPlumb.dragManager.clearParent(_el, id);
        }

        //
        // remove an element from the group, then either prune it from the jsplumb instance, or just orphan it.
        //
        function _pruneOrOrphan(p) {
            if (!_isInsideParent(p.el, p.pos)) {
                var group = p.el._jsPlumbGroup;
                if (prune) {
                    _jsPlumb.remove(p.el);
                } else {
                    _orphan(p.el);
                }

                group.remove(p.el);
            }
        }

        //
        // redraws the element
        //
        function _revalidate(_el) {
            var id = _jsPlumb.getId(_el);
            _jsPlumb.revalidate(_el);
            _jsPlumb.dragManager.revalidateParent(_el, id);
        }

        //
        // unbind the group specific drag/revert handlers.
        //
        function _unbindDragHandlers(_el) {
            if (!_el._katavorioDrag) return;
            if (prune || orphan) {
                _el._katavorioDrag.off(STOP, _pruneOrOrphan);
            }
            if (!prune && !orphan && revert) {
                _el._katavorioDrag.off(REVERT, _revalidate);
                _el._katavorioDrag.setRevert(null);
            }
        }

        function _bindDragHandlers(_el) {
            if (!_el._katavorioDrag) return;
            if (prune || orphan) {
                _el._katavorioDrag.on(STOP, _pruneOrOrphan);
            }

            if (constrain) {
                _el._katavorioDrag.setConstrain(true);
            }

            if (ghost) {
                _el._katavorioDrag.setUseGhostProxy(true);
            }

            if (!prune && !orphan && revert) {
                _el._katavorioDrag.on(REVERT, _revalidate);
                _el._katavorioDrag.setRevert(function(__el, pos) {
                    return !_isInsideParent(__el, pos);
                });
            }
        }

        this.shouldProxy = function() {
            return proxied;
        };

        _jsPlumb.getGroupManager().addGroup(this);
    };

    /**
     * Adds a group to the jsPlumb instance.
     * @method addGroup
     * @param {Object} params
     * @return {Group} The newly created Group.
     */
    _jpi.prototype.addGroup = function(params) {
        var j = this;
        j._groups = j._groups || {};
        if (j._groups[params.id] != null) {
            throw new TypeError("cannot create Group [" + params.id + "]; a Group with that ID exists");
        }
        if (params.el[GROUP] != null) {
            throw new TypeError("cannot create Group [" + params.id + "]; the given element is already a Group");
        }
        var group = new Group(j, params);
        j._groups[group.id] = group;
        return group;
    };

    /**
     * Add an element to a group.
     * @method addToGroup
     * @param {String} group Group, or ID of the group, to add the element to.
     * @param {Element} el Element to add to the group.
     */
    _jpi.prototype.addToGroup = function(group, el, doNotFireEvent) {

        var _one = function(_el) {
            var id = this.getId(_el);
            this.manage(id, _el);
            this.getGroupManager().addToGroup(group, _el, doNotFireEvent);
        }.bind(this);

        if (Array.isArray(el)) {
            for (var i = 0; i < el.length; i++) {
                _one(el[i]);
            }
        } else {
            _one(el);
        }
    };

    /**
     * Remove an element from a group.
     * @method removeFromGroup
     * @param {String} group Group, or ID of the group, to remove the element from.
     * @param {Element} el Element to add to the group.
     */
    _jpi.prototype.removeFromGroup = function(group, el, doNotFireEvent) {
        this.getGroupManager().removeFromGroup(group, el, doNotFireEvent);
    };

    /**
     * Remove a group, and optionally remove its members from the jsPlumb instance.
     * @method removeGroup
     * @param {String|Group} group Group to delete, or ID of Group to delete.
     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the group. Otherwise they will
     * just be 'orphaned' (returned to the main container).
     */
    _jpi.prototype.removeGroup = function(group, deleteMembers, manipulateDOM, doNotFireEvent) {
        this.getGroupManager().removeGroup(group, deleteMembers, manipulateDOM, doNotFireEvent);
    };

    /**
     * Remove all groups, and optionally remove their members from the jsPlumb instance.
     * @method removeAllGroup
     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the groups. Otherwise they will
     * just be 'orphaned' (returned to the main container).
     */
    _jpi.prototype.removeAllGroups = function(deleteMembers, manipulateDOM, doNotFireEvent) {
        this.getGroupManager().removeAllGroups(deleteMembers, manipulateDOM, doNotFireEvent);
    };

    /**
     * Get a Group
     * @method getGroup
     * @param {String} groupId ID of the group to get
     * @return {Group} Group with the given ID, null if not found.
     */
    _jpi.prototype.getGroup = function(groupId) {
        return this.getGroupManager().getGroup(groupId);
    };

    /**
     * Gets all the Groups managed by the jsPlumb instance.
     * @returns {Group[]} List of Groups. Empty if none.
     */
    _jpi.prototype.getGroups = function() {
        return this.getGroupManager().getGroups();
    };

    /**
     * Expands a group element. jsPlumb doesn't do "everything" for you here, because what it means to expand a Group
     * will vary from application to application. jsPlumb does these things:
     *
     * - Hides any connections that are internal to the group (connections between members, and connections from member of
     * the group to the group itself)
     * - Proxies all connections for which the source or target is a member of the group.
     * - Hides the proxied connections.
     * - Adds the jtk-group-expanded class to the group's element
     * - Removes the jtk-group-collapsed class from the group's element.
     *
     * @method expandGroup
     * @param {String|Group} group Group to expand, or ID of Group to expand.
     */
    _jpi.prototype.expandGroup = function(group) {
        this.getGroupManager().expandGroup(group);
    };

    /**
     * Collapses a group element. jsPlumb doesn't do "everything" for you here, because what it means to collapse a Group
     * will vary from application to application. jsPlumb does these things:
     *
     * - Shows any connections that are internal to the group (connections between members, and connections from member of
     * the group to the group itself)
     * - Removes proxies for all connections for which the source or target is a member of the group.
     * - Shows the previously proxied connections.
     * - Adds the jtk-group-collapsed class to the group's element
     * - Removes the jtk-group-expanded class from the group's element.
     *
     * @method expandGroup
     * @param {String|Group} group Group to expand, or ID of Group to expand.
     */
    _jpi.prototype.collapseGroup = function(groupId) {
        this.getGroupManager().collapseGroup(groupId);
    };


    _jpi.prototype.repaintGroup = function(group) {
        this.getGroupManager().repaintGroup(group);
    };

    /**
     * Collapses or expands a group element depending on its current state. See notes in the collapseGroup and expandGroup method.
     *
     * @method toggleGroup
     * @param {String|Group} group Group to expand/collapse, or ID of Group to expand/collapse.
     */
    _jpi.prototype.toggleGroup = function(group) {
        group = this.getGroupManager().getGroup(group);
        if (group != null) {
            this.getGroupManager()[group.collapsed ? "expandGroup" : "collapseGroup"](group);
        }
    };

    //
    // lazy init a group manager for the given jsplumb instance.
    //
    _jpi.prototype.getGroupManager = function() {
        var mgr = this[GROUP_MANAGER];
        if (mgr == null) {
            mgr = this[GROUP_MANAGER] = new GroupManager(this);
        }
        return mgr;
    };

    _jpi.prototype.removeGroupManager = function() {
        delete this[GROUP_MANAGER];
    };

    /**
     * Gets the Group that the given element belongs to, null if none.
     * @method getGroupFor
     * @param {String|Element} el Element, or element ID.
     * @returns {Group} A Group, if found, or null.
     */
    _jpi.prototype.getGroupFor = function(el) {
        el = this.getElement(el);
        if (el) {
            return el[GROUP];
        }
    };

}).call(typeof window !== 'undefined' ? window : this);


/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'flowchart' connectors, consisting of vertical and horizontal line segments.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var Flowchart = function (params) {
        this.type = "Flowchart";
        params = params || {};
        params.stub = params.stub == null ? 30 : params.stub;
        var segments,
            _super = _jp.Connectors.AbstractConnector.apply(this, arguments),
            midpoint = params.midpoint == null ? 0.5 : params.midpoint,
            alwaysRespectStubs = params.alwaysRespectStubs === true,
            lastx = null, lasty = null, lastOrientation,
            cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0,

            // TODO now common between this and AbstractBezierEditor; refactor into superclass?
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,

            sgn = function (n) {
                return n < 0 ? -1 : n === 0 ? 0 : 1;
            },
            /**
             * helper method to add a segment.
             */
            addSegment = function (segments, x, y, paintInfo) {
                if (lastx == x && lasty == y) return;
                var lx = lastx == null ? paintInfo.sx : lastx,
                    ly = lasty == null ? paintInfo.sy : lasty,
                    o = lx == x ? "v" : "h",
                    sgnx = sgn(x - lx),
                    sgny = sgn(y - ly);

                lastx = x;
                lasty = y;
                segments.push([lx, ly, x, y, o, sgnx, sgny]);
            },
            segLength = function (s) {
                return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));
            },
            _cloneArray = function (a) {
                var _a = [];
                _a.push.apply(_a, a);
                return _a;
            },
            writeSegments = function (conn, segments, paintInfo) {
                var current = null, next;
                for (var i = 0; i < segments.length - 1; i++) {

                    current = current || _cloneArray(segments[i]);
                    next = _cloneArray(segments[i + 1]);
                    if (cornerRadius > 0 && current[4] != next[4]) {
                        var radiusToUse = Math.min(cornerRadius, segLength(current), segLength(next));
                        // right angle. adjust current segment's end point, and next segment's start point.
                        current[2] -= current[5] * radiusToUse;
                        current[3] -= current[6] * radiusToUse;
                        next[0] += next[5] * radiusToUse;
                        next[1] += next[6] * radiusToUse;
                        var ac = (current[6] == next[5] && next[5] == 1) ||
                                ((current[6] == next[5] && next[5] === 0) && current[5] != next[6]) ||
                                (current[6] == next[5] && next[5] == -1),
                            sgny = next[1] > current[3] ? 1 : -1,
                            sgnx = next[0] > current[2] ? 1 : -1,
                            sgnEqual = sgny == sgnx,
                            cx = (sgnEqual && ac || (!sgnEqual && !ac)) ? next[0] : current[2],
                            cy = (sgnEqual && ac || (!sgnEqual && !ac)) ? current[3] : next[1];

                        _super.addSegment(conn, "Straight", {
                            x1: current[0], y1: current[1], x2: current[2], y2: current[3]
                        });

                        _super.addSegment(conn, "Arc", {
                            r: radiusToUse,
                            x1: current[2],
                            y1: current[3],
                            x2: next[0],
                            y2: next[1],
                            cx: cx,
                            cy: cy,
                            ac: ac
                        });
                    }
                    else {
                        // dx + dy are used to adjust for line width.
                        var dx = (current[2] == current[0]) ? 0 : (current[2] > current[0]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2),
                            dy = (current[3] == current[1]) ? 0 : (current[3] > current[1]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2);
                        _super.addSegment(conn, "Straight", {
                            x1: current[0] - dx, y1: current[1] - dy, x2: current[2] + dx, y2: current[3] + dy
                        });
                    }
                    current = next;
                }
                if (next != null) {
                    // last segment
                    _super.addSegment(conn, "Straight", {
                        x1: next[0], y1: next[1], x2: next[2], y2: next[3]
                    });
                }
            };

        this._compute = function (paintInfo, params) {

            segments = [];
            lastx = null;
            lasty = null;
            lastOrientation = null;

            var commonStubCalculator = function () {
                return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
            },
                stubCalculators = {
                    perpendicular: commonStubCalculator,
                    orthogonal: commonStubCalculator,
                    opposite: function (axis) {
                        var pi = paintInfo,
                            idx = axis == "x" ? 0 : 1,
                            areInProximity = {
                                "x": function () {
                                    return ( (pi.so[idx] == 1 && (
                                        ( (pi.startStubX > pi.endStubX) && (pi.tx > pi.startStubX) ) ||
                                        ( (pi.sx > pi.endStubX) && (pi.tx > pi.sx))))) ||

                                        ( (pi.so[idx] == -1 && (
                                            ( (pi.startStubX < pi.endStubX) && (pi.tx < pi.startStubX) ) ||
                                            ( (pi.sx < pi.endStubX) && (pi.tx < pi.sx)))));
                                },
                                "y": function () {
                                    return ( (pi.so[idx] == 1 && (
                                        ( (pi.startStubY > pi.endStubY) && (pi.ty > pi.startStubY) ) ||
                                        ( (pi.sy > pi.endStubY) && (pi.ty > pi.sy))))) ||

                                        ( (pi.so[idx] == -1 && (
                                            ( (pi.startStubY < pi.endStubY) && (pi.ty < pi.startStubY) ) ||
                                            ( (pi.sy < pi.endStubY) && (pi.ty < pi.sy)))));
                                }
                            };

                        if (!alwaysRespectStubs && areInProximity[axis]()) {
                            return {
                                "x": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
                                "y": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
                            }[axis];
                        }
                        else {
                            return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
                        }
                    }
                };

            // calculate Stubs.
            var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),
                idx = paintInfo.sourceAxis == "x" ? 0 : 1,
                oidx = paintInfo.sourceAxis == "x" ? 1 : 0,
                ss = stubs[idx],
                oss = stubs[oidx],
                es = stubs[idx + 2],
                oes = stubs[oidx + 2];

            // add the start stub segment. use stubs for loopback as it will look better, with the loop spaced
            // away from the element.
            addSegment(segments, stubs[0], stubs[1], paintInfo);

            // if its a loopback and we should treat it differently.
            if (false &&params.sourcePos[0] == params.targetPos[0] && params.sourcePos[1] == params.targetPos[1]) {

                // we use loopbackRadius here, as statemachine connectors do.
                // so we go radius to the left from stubs[0], then upwards by 2*radius, to the right by 2*radius,
                // down by 2*radius, left by radius.
                addSegment(segments, stubs[0] - loopbackRadius, stubs[1], paintInfo);
                addSegment(segments, stubs[0] - loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
                addSegment(segments, stubs[0] + loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
                addSegment(segments, stubs[0] + loopbackRadius, stubs[1], paintInfo);
                addSegment(segments, stubs[0], stubs[1], paintInfo);

            }
            else {


                var midx = paintInfo.startStubX + ((paintInfo.endStubX - paintInfo.startStubX) * midpoint),
                    midy = paintInfo.startStubY + ((paintInfo.endStubY - paintInfo.startStubY) * midpoint);

                var orientations = { x: [ 0, 1 ], y: [ 1, 0 ] },
                    lineCalculators = {
                        perpendicular: function (axis) {
                            var pi = paintInfo,
                                sis = {
                                    x: [
                                        [ [ 1, 2, 3, 4 ], null, [ 2, 1, 4, 3 ] ],
                                        null,
                                        [ [ 4, 3, 2, 1 ], null, [ 3, 4, 1, 2 ] ]
                                    ],
                                    y: [
                                        [ [ 3, 2, 1, 4 ], null, [ 2, 3, 4, 1 ] ],
                                        null,
                                        [ [ 4, 1, 2, 3 ], null, [ 1, 4, 3, 2 ] ]
                                    ]
                                },
                                stubs = {
                                    x: [ [ pi.startStubX, pi.endStubX ], null, [ pi.endStubX, pi.startStubX ] ],
                                    y: [ [ pi.startStubY, pi.endStubY ], null, [ pi.endStubY, pi.startStubY ] ]
                                },
                                midLines = {
                                    x: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ] ],
                                    y: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ] ]
                                },
                                linesToEnd = {
                                    x: [ [ pi.endStubX, pi.startStubY ] ],
                                    y: [ [ pi.startStubX, pi.endStubY ] ]
                                },
                                startToEnd = {
                                    x: [ [ pi.startStubX, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ],
                                    y: [ [ pi.endStubX, pi.startStubY ], [ pi.endStubX, pi.endStubY ] ]
                                },
                                startToMidToEnd = {
                                    x: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ], [ pi.endStubX, pi.endStubY ] ],
                                    y: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ]
                                },
                                otherStubs = {
                                    x: [ pi.startStubY, pi.endStubY ],
                                    y: [ pi.startStubX, pi.endStubX ]
                                },
                                soIdx = orientations[axis][0], toIdx = orientations[axis][1],
                                _so = pi.so[soIdx] + 1,
                                _to = pi.to[toIdx] + 1,
                                otherFlipped = (pi.to[toIdx] == -1 && (otherStubs[axis][1] < otherStubs[axis][0])) || (pi.to[toIdx] == 1 && (otherStubs[axis][1] > otherStubs[axis][0])),
                                stub1 = stubs[axis][_so][0],
                                stub2 = stubs[axis][_so][1],
                                segmentIndexes = sis[axis][_so][_to];

                            if (pi.segment == segmentIndexes[3] || (pi.segment == segmentIndexes[2] && otherFlipped)) {
                                return midLines[axis];
                            }
                            else if (pi.segment == segmentIndexes[2] && stub2 < stub1) {
                                return linesToEnd[axis];
                            }
                            else if ((pi.segment == segmentIndexes[2] && stub2 >= stub1) || (pi.segment == segmentIndexes[1] && !otherFlipped)) {
                                return startToMidToEnd[axis];
                            }
                            else if (pi.segment == segmentIndexes[0] || (pi.segment == segmentIndexes[1] && otherFlipped)) {
                                return startToEnd[axis];
                            }
                        },
                        orthogonal: function (axis, startStub, otherStartStub, endStub, otherEndStub) {
                            var pi = paintInfo,
                                extent = {
                                    "x": pi.so[0] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
                                    "y": pi.so[1] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
                                }[axis];

                            return {
                                "x": [
                                    [ extent, otherStartStub ],
                                    [ extent, otherEndStub ],
                                    [ endStub, otherEndStub ]
                                ],
                                "y": [
                                    [ otherStartStub, extent ],
                                    [ otherEndStub, extent ],
                                    [ otherEndStub, endStub ]
                                ]
                            }[axis];
                        },
                        opposite: function (axis, ss, oss, es) {
                            var pi = paintInfo,
                                otherAxis = {"x": "y", "y": "x"}[axis],
                                dim = {"x": "height", "y": "width"}[axis],
                                comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];

                            if (params.sourceEndpoint.elementId == params.targetEndpoint.elementId) {
                                var _val = oss + ((1 - params.sourceEndpoint.anchor[otherAxis]) * params.sourceInfo[dim]) + _super.maxStub;
                                return {
                                    "x": [
                                        [ ss, _val ],
                                        [ es, _val ]
                                    ],
                                    "y": [
                                        [ _val, ss ],
                                        [ _val, es ]
                                    ]
                                }[axis];

                            }
                            else if (!comparator || (pi.so[idx] == 1 && ss > es) || (pi.so[idx] == -1 && ss < es)) {
                                return {
                                    "x": [
                                        [ ss, midy ],
                                        [ es, midy ]
                                    ],
                                    "y": [
                                        [ midx, ss ],
                                        [ midx, es ]
                                    ]
                                }[axis];
                            }
                            else if ((pi.so[idx] == 1 && ss < es) || (pi.so[idx] == -1 && ss > es)) {
                                return {
                                    "x": [
                                        [ midx, pi.sy ],
                                        [ midx, pi.ty ]
                                    ],
                                    "y": [
                                        [ pi.sx, midy ],
                                        [ pi.tx, midy ]
                                    ]
                                }[axis];
                            }
                        }
                    };

                // compute the rest of the line
                var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);
                if (p) {
                    for (var i = 0; i < p.length; i++) {
                        addSegment(segments, p[i][0], p[i][1], paintInfo);
                    }
                }

                // line to end stub
                addSegment(segments, stubs[2], stubs[3], paintInfo);

            }

            // end stub to end (common)
            addSegment(segments, paintInfo.tx, paintInfo.ty, paintInfo);

            // write out the segments.
            writeSegments(this, segments, paintInfo);
        };

        /*this.getPath = function () {
            var _last = null, _lastAxis = null, s = [], segs = segments;
            for (var i = 0; i < segs.length; i++) {
                var seg = segs[i], axis = seg[4], axisIndex = (axis == "v" ? 3 : 2);
                if (_last != null && _lastAxis === axis) {
                    _last[axisIndex] = seg[axisIndex];
                }
                else {
                    if (seg[0] != seg[2] || seg[1] != seg[3]) {
                        s.push({
                            start: [ seg[0], seg[1] ],
                            end: [ seg[2], seg[3] ]
                        });
                        _last = seg;
                        _lastAxis = seg[4];
                    }
                }
            }
            return s;
        };*/
    };

    _ju.extend(Flowchart, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Flowchart, "Flowchart");
}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the code for the Bezier connector type.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    _jp.Connectors.AbstractBezierConnector = function(params) {
        params = params || {};
        var showLoopback = params.showLoopback !== false,
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,
            _super;

        this.overrideSetEditable = function() { return !isLoopbackCurrently; };

        this._compute = function (paintInfo, p) {

            var sp = p.sourcePos,
                tp = p.targetPos,
                _w = Math.abs(sp[0] - tp[0]),
                _h = Math.abs(sp[1] - tp[1]);

            if (!showLoopback || (p.sourceEndpoint.elementId !== p.targetEndpoint.elementId)) {
                isLoopbackCurrently = false;
                this._computeBezier(paintInfo, p, sp, tp, _w, _h);
            } else {
                isLoopbackCurrently = true;
                // a loopback connector.  draw an arc from one anchor to the other.
                var x1 = p.sourcePos[0], y1 = p.sourcePos[1] - margin,
                    cx = x1, cy = y1 - loopbackRadius,
                // canvas sizing stuff, to ensure the whole painted area is visible.
                    _x = cx - loopbackRadius,
                    _y = cy - loopbackRadius;

                _w = 2 * loopbackRadius;
                _h = 2 * loopbackRadius;

                paintInfo.points[0] = _x;
                paintInfo.points[1] = _y;
                paintInfo.points[2] = _w;
                paintInfo.points[3] = _h;

                // ADD AN ARC SEGMENT.
                _super.addSegment(this, "Arc", {
                    loopback: true,
                    x1: (x1 - _x) + 4,
                    y1: y1 - _y,
                    startAngle: 0,
                    endAngle: 2 * Math.PI,
                    r: loopbackRadius,
                    ac: !clockwise,
                    x2: (x1 - _x) - 4,
                    y2: y1 - _y,
                    cx: cx - _x,
                    cy: cy - _y
                });
            }
        };

        _super = _jp.Connectors.AbstractConnector.apply(this, arguments);
        return _super;
    };
    _ju.extend(_jp.Connectors.AbstractBezierConnector, _jp.Connectors.AbstractConnector);

    var Bezier = function (params) {
        params = params || {};
        this.type = "Bezier";

        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            majorAnchor = params.curviness || 150,
            minorAnchor = 10;

        this.getCurviness = function () {
            return majorAnchor;
        };

        this._findControlPoint = function (point, sourceAnchorPosition, targetAnchorPosition, sourceEndpoint, targetEndpoint, soo, too) {
            // determine if the two anchors are perpendicular to each other in their orientation.  we swap the control
            // points around if so (code could be tightened up)
            var perpendicular = soo[0] != too[0] || soo[1] == too[1],
                p = [];

            if (!perpendicular) {
                if (soo[0] === 0) // X
                    p.push(sourceAnchorPosition[0] < targetAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] - (majorAnchor * soo[0]));

                if (soo[1] === 0) // Y
                    p.push(sourceAnchorPosition[1] < targetAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * too[1]));
            }
            else {
                if (too[0] === 0) // X
                    p.push(targetAnchorPosition[0] < sourceAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                else p.push(point[0] + (majorAnchor * too[0]));

                if (too[1] === 0) // Y
                    p.push(targetAnchorPosition[1] < sourceAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                else p.push(point[1] + (majorAnchor * soo[1]));
            }

            return p;
        };

        this._computeBezier = function (paintInfo, p, sp, tp, _w, _h) {

            var geometry = this.getGeometry(), _CP, _CP2,
                _sx = sp[0] < tp[0] ? _w : 0,
                _sy = sp[1] < tp[1] ? _h : 0,
                _tx = sp[0] < tp[0] ? 0 : _w,
                _ty = sp[1] < tp[1] ? 0 : _h;

            if ((this.hasBeenEdited() || this.isEditing()) && geometry != null && geometry.controlPoints != null && geometry.controlPoints[0] != null && geometry.controlPoints[1] != null) {
                _CP = geometry.controlPoints[0];
                _CP2 = geometry.controlPoints[1];
            }
            else {
                _CP = this._findControlPoint([_sx, _sy], sp, tp, p.sourceEndpoint, p.targetEndpoint, paintInfo.so, paintInfo.to);
                _CP2 = this._findControlPoint([_tx, _ty], tp, sp, p.targetEndpoint, p.sourceEndpoint, paintInfo.to, paintInfo.so);
            }

            _super.setGeometry({controlPoints:[_CP, _CP2]}, true);

            _super.addSegment(this, "Bezier", {
                x1: _sx, y1: _sy, x2: _tx, y2: _ty,
                cp1x: _CP[0], cp1y: _CP[1], cp2x: _CP2[0], cp2y: _CP2[1]
            });
        };


    };

    _ju.extend(Bezier, _jp.Connectors.AbstractBezierConnector);
    _jp.registerConnectorType(Bezier, "Bezier");

}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the state machine connectors, which extend AbstractBezierConnector.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var _segment = function (x1, y1, x2, y2) {
            if (x1 <= x2 && y2 <= y1) return 1;
            else if (x1 <= x2 && y1 <= y2) return 2;
            else if (x2 <= x1 && y2 >= y1) return 3;
            return 4;
        },

    // the control point we will use depends on the faces to which each end of the connection is assigned, specifically whether or not the
    // two faces are parallel or perpendicular.  if they are parallel then the control point lies on the midpoint of the axis in which they
    // are parellel and varies only in the other axis; this variation is proportional to the distance that the anchor points lie from the
    // center of that face.  if the two faces are perpendicular then the control point is at some distance from both the midpoints; the amount and
    // direction are dependent on the orientation of the two elements. 'seg', passed in to this method, tells you which segment the target element
    // lies in with respect to the source: 1 is top right, 2 is bottom right, 3 is bottom left, 4 is top left.
    //
    // sourcePos and targetPos are arrays of info about where on the source and target each anchor is located.  their contents are:
    //
    // 0 - absolute x
    // 1 - absolute y
    // 2 - proportional x in element (0 is left edge, 1 is right edge)
    // 3 - proportional y in element (0 is top edge, 1 is bottom edge)
    //
        _findControlPoint = function (midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {
            // TODO (maybe)
            // - if anchor pos is 0.5, make the control point take into account the relative position of the elements.
            if (distance <= proximityLimit) return [midx, midy];

            if (segment === 1) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
            }
            else if (segment === 2) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + dx, midy + (-1 * dy) ];
            }
            else if (segment === 3) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + (-1 * dx) , midy + (-1 * dy) ];
            }
            else if (segment === 4) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                else return [ midx + dx , midy + (-1 * dy) ];
            }

        };

    var StateMachine = function (params) {
        params = params || {};
        this.type = "StateMachine";

        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            _controlPoint;

        this._computeBezier = function(paintInfo, params, sp, tp, w, h) {
            var _sx = params.sourcePos[0] < params.targetPos[0] ? 0 : w,
                _sy = params.sourcePos[1] < params.targetPos[1] ? 0 : h,
                _tx = params.sourcePos[0] < params.targetPos[0] ? w : 0,
                _ty = params.sourcePos[1] < params.targetPos[1] ? h : 0;

            // now adjust for the margin
            if (params.sourcePos[2] === 0) _sx -= margin;
            if (params.sourcePos[2] === 1) _sx += margin;
            if (params.sourcePos[3] === 0) _sy -= margin;
            if (params.sourcePos[3] === 1) _sy += margin;
            if (params.targetPos[2] === 0) _tx -= margin;
            if (params.targetPos[2] === 1) _tx += margin;
            if (params.targetPos[3] === 0) _ty -= margin;
            if (params.targetPos[3] === 1) _ty += margin;

            //
            // these connectors are quadratic bezier curves, having a single control point. if both anchors
            // are located at 0.5 on their respective faces, the control point is set to the midpoint and you
            // get a straight line.  this is also the case if the two anchors are within 'proximityLimit', since
            // it seems to make good aesthetic sense to do that. outside of that, the control point is positioned
            // at 'curviness' pixels away along the normal to the straight line connecting the two anchors.
            //
            // there may be two improvements to this.  firstly, we might actually support the notion of avoiding nodes
            // in the UI, or at least making a good effort at doing so.  if a connection would pass underneath some node,
            // for example, we might increase the distance the control point is away from the midpoint in a bid to
            // steer it around that node.  this will work within limits, but i think those limits would also be the likely
            // limits for, once again, aesthetic good sense in the layout of a chart using these connectors.
            //
            // the second possible change is actually two possible changes: firstly, it is possible we should gradually
            // decrease the 'curviness' as the distance between the anchors decreases; start tailing it off to 0 at some
            // point (which should be configurable).  secondly, we might slightly increase the 'curviness' for connectors
            // with respect to how far their anchor is from the center of its respective face. this could either look cool,
            // or stupid, and may indeed work only in a way that is so subtle as to have been a waste of time.
            //

            var _midx = (_sx + _tx) / 2,
                _midy = (_sy + _ty) / 2,
                segment = _segment(_sx, _sy, _tx, _ty),
                distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2)),
                cp1x, cp2x, cp1y, cp2y,
                geometry = _super.getGeometry();

            if ((this.hasBeenEdited() || this.isEditing()) && geometry != null) {
                cp1x = geometry.controlPoints[0][0];
                cp1y = geometry.controlPoints[0][1];
                cp2x = geometry.controlPoints[1][0];
                cp2y = geometry.controlPoints[1][1];
            }
            else {
                // calculate the control point.  this code will be where we'll put in a rudimentary element avoidance scheme; it
                // will work by extending the control point to force the curve to be, um, curvier.
                _controlPoint = _findControlPoint(_midx,
                    _midy,
                    segment,
                    params.sourcePos,
                    params.targetPos,
                    curviness, curviness,
                    distance,
                    proximityLimit);

                cp1x = _controlPoint[0];
                cp2x = _controlPoint[0];
                cp1y = _controlPoint[1];
                cp2y = _controlPoint[1];

                _super.setGeometry({controlPoints:[_controlPoint, _controlPoint]}, true);
            }

            _super.addSegment(this, "Bezier", {
                x1: _tx, y1: _ty, x2: _sx, y2: _sy,
                cp1x: cp1x, cp1y: cp1y,
                cp2x: cp2x, cp2y: cp2y
            });
        };
    };

    _ju.extend(StateMachine, _jp.Connectors.AbstractBezierConnector);
    _jp.registerConnectorType(StateMachine, "StateMachine");

}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the 'flowchart' connectors, consisting of vertical and horizontal line segments.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;
    var STRAIGHT = "Straight";

    var Straight = function (params) {
        this.type = STRAIGHT;
        var _super = _jp.Connectors.AbstractConnector.apply(this, arguments);

        this._compute = function (paintInfo, _) {
            _super.addSegment(this, STRAIGHT, {x1: paintInfo.sx, y1: paintInfo.sy, x2: paintInfo.startStubX, y2: paintInfo.startStubY});
            _super.addSegment(this, STRAIGHT, {x1: paintInfo.startStubX, y1: paintInfo.startStubY, x2: paintInfo.endStubX, y2: paintInfo.endStubY});
            _super.addSegment(this, STRAIGHT, {x1: paintInfo.endStubX, y1: paintInfo.endStubY, x2: paintInfo.tx, y2: paintInfo.ty});
        };
    };

    _ju.extend(Straight, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Straight, STRAIGHT);

}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the SVG renderers.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

// ************************** SVG utility methods ********************************************	

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var svgAttributeMap = {
            "stroke-linejoin": "stroke-linejoin",
            "stroke-dashoffset": "stroke-dashoffset",
            "stroke-linecap": "stroke-linecap"
        },
        STROKE_DASHARRAY = "stroke-dasharray",
        DASHSTYLE = "dashstyle",
        LINEAR_GRADIENT = "linearGradient",
        RADIAL_GRADIENT = "radialGradient",
        DEFS = "defs",
        FILL = "fill",
        STOP = "stop",
        STROKE = "stroke",
        STROKE_WIDTH = "stroke-width",
        STYLE = "style",
        NONE = "none",
        JSPLUMB_GRADIENT = "jsplumb_gradient_",
        LINE_WIDTH = "strokeWidth",
        ns = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml"
        },
        _attr = function (node, attributes) {
            for (var i in attributes)
                node.setAttribute(i, "" + attributes[i]);
        },
        _node = function (name, attributes) {
            attributes = attributes || {};
            attributes.version = "1.1";
            attributes.xmlns = ns.xhtml;
            return _jp.createElementNS(ns.svg, name, null, null, attributes);
        },
        _pos = function (d) {
            return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
        },
        _clearGradient = function (parent) {
            var els = parent.querySelectorAll(" defs,linearGradient,radialGradient");
            for (var i = 0; i < els.length; i++)
                els[i].parentNode.removeChild(els[i]);
        },
        _updateGradient = function (parent, node, style, dimensions, uiComponent) {
            var id = JSPLUMB_GRADIENT + uiComponent._jsPlumb.instance.idstamp();
            // first clear out any existing gradient
            _clearGradient(parent);
            // this checks for an 'offset' property in the gradient, and in the absence of it, assumes
            // we want a linear gradient. if it's there, we create a radial gradient.
            // it is possible that a more explicit means of defining the gradient type would be
            // better. relying on 'offset' means that we can never have a radial gradient that uses
            // some default offset, for instance.
            // issue 244 suggested the 'gradientUnits' attribute; without this, straight/flowchart connectors with gradients would
            // not show gradients when the line was perfectly horizontal or vertical.
            var g;
            if (!style.gradient.offset)
                g = _node(LINEAR_GRADIENT, {id: id, gradientUnits: "userSpaceOnUse"});
            else
                g = _node(RADIAL_GRADIENT, { id: id });

            var defs = _node(DEFS);
            parent.appendChild(defs);
            defs.appendChild(g);

            // the svg radial gradient seems to treat stops in the reverse
            // order to how canvas does it.  so we want to keep all the maths the same, but
            // iterate the actual style declarations in reverse order, if the x indexes are not in order.
            for (var i = 0; i < style.gradient.stops.length; i++) {
                var styleToUse = uiComponent.segment == 1 || uiComponent.segment == 2 ? i : style.gradient.stops.length - 1 - i,
                    //stopColor = _ju.convertStyle(style.gradient.stops[styleToUse][1], true),
                    stopColor = style.gradient.stops[styleToUse][1],
                    s = _node(STOP, {"offset": Math.floor(style.gradient.stops[i][0] * 100) + "%", "stop-color": stopColor});

                g.appendChild(s);
            }
            var applyGradientTo = style.stroke ? STROKE : FILL;
            node.setAttribute(applyGradientTo, "url(#" + id + ")");
        },
        _applyStyles = function (parent, node, style, dimensions, uiComponent) {

            node.setAttribute(FILL, style.fill ? style.fill : NONE);
            node.setAttribute(STROKE, style.stroke ? style.stroke : NONE);

            if (style.gradient) {
                _updateGradient(parent, node, style, dimensions, uiComponent);
            }
            else {
                // make sure we clear any existing gradient
                _clearGradient(parent);
                node.setAttribute(STYLE, "");
            }

            if (style.strokeWidth) {
                node.setAttribute(STROKE_WIDTH, style.strokeWidth);
            }

            // in SVG there is a stroke-dasharray attribute we can set, and its syntax looks like
            // the syntax in VML but is actually kind of nasty: values are given in the pixel
            // coordinate space, whereas in VML they are multiples of the width of the stroked
            // line, which makes a lot more sense.  for that reason, jsPlumb is supporting both
            // the native svg 'stroke-dasharray' attribute, and also the 'dashstyle' concept from
            // VML, which will be the preferred method.  the code below this converts a dashstyle
            // attribute given in terms of stroke width into a pixel representation, by using the
            // stroke's lineWidth.
            if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
                var sep = style[DASHSTYLE].indexOf(",") == -1 ? " " : ",",
                    parts = style[DASHSTYLE].split(sep),
                    styleToUse = "";
                parts.forEach(function (p) {
                    styleToUse += (Math.floor(p * style.strokeWidth) + sep);
                });
                node.setAttribute(STROKE_DASHARRAY, styleToUse);
            }
            else if (style[STROKE_DASHARRAY]) {
                node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
            }

            // extra attributes such as join type, dash offset.
            for (var i in svgAttributeMap) {
                if (style[i]) {
                    node.setAttribute(svgAttributeMap[i], style[i]);
                }
            }
        },
        _appendAtIndex = function (svg, path, idx) {
            if (svg.childNodes.length > idx) {
                svg.insertBefore(path, svg.childNodes[idx]);
            }
            else svg.appendChild(path);
        };

    /**
     utility methods for other objects to use.
     */
    _ju.svg = {
        node: _node,
        attr: _attr,
        pos: _pos
    };

    // ************************** / SVG utility methods ********************************************

    /*
     * Base class for SVG components.
     */
    var SvgComponent = function (params) {
        var pointerEventsSpec = params.pointerEventsSpec || "all", renderer = {};

        _jp.jsPlumbUIComponent.apply(this, params.originalArgs);
        this.canvas = null;
        this.path = null;
        this.svg = null;
        this.bgCanvas = null;

        var clazz = params.cssClass + " " + (params.originalArgs[0].cssClass || ""),
            svgParams = {
                "style": "",
                "width": 0,
                "height": 0,
                "pointer-events": pointerEventsSpec,
                "position": "absolute"
            };

        this.svg = _node("svg", svgParams);

        if (params.useDivWrapper) {
            this.canvas = _jp.createElement("div", { position : "absolute" });
            _ju.sizeElement(this.canvas, 0, 0, 1, 1);
            this.canvas.className = clazz;
        }
        else {
            _attr(this.svg, { "class": clazz });
            this.canvas = this.svg;
        }

        params._jsPlumb.appendElement(this.canvas, params.originalArgs[0].parent);
        if (params.useDivWrapper) this.canvas.appendChild(this.svg);

        var displayElements = [ this.canvas ];
        this.getDisplayElements = function () {
            return displayElements;
        };

        this.appendDisplayElement = function (el) {
            displayElements.push(el);
        };

        this.paint = function (style, anchor, extents) {
            if (style != null) {

                var xy = [ this.x, this.y ], wh = [ this.w, this.h ], p;
                if (extents != null) {
                    if (extents.xmin < 0) xy[0] += extents.xmin;
                    if (extents.ymin < 0) xy[1] += extents.ymin;
                    wh[0] = extents.xmax + ((extents.xmin < 0) ? -extents.xmin : 0);
                    wh[1] = extents.ymax + ((extents.ymin < 0) ? -extents.ymin : 0);
                }

                if (params.useDivWrapper) {
                    _ju.sizeElement(this.canvas, xy[0], xy[1], wh[0], wh[1]);
                    xy[0] = 0;
                    xy[1] = 0;
                    p = _pos([ 0, 0 ]);
                }
                else
                    p = _pos([ xy[0], xy[1] ]);

                renderer.paint.apply(this, arguments);

                _attr(this.svg, {
                    "style": p,
                    "width": wh[0] || 0,
                    "height": wh[1] || 0
                });
            }
        };

        return {
            renderer: renderer
        };
    };

    _ju.extend(SvgComponent, _jp.jsPlumbUIComponent, {
        cleanup: function (force) {
            if (force || this.typeId == null) {
                if (this.canvas) this.canvas._jsPlumb = null;
                if (this.svg) this.svg._jsPlumb = null;
                if (this.bgCanvas) this.bgCanvas._jsPlumb = null;

                if (this.canvas && this.canvas.parentNode)
                    this.canvas.parentNode.removeChild(this.canvas);
                if (this.bgCanvas && this.bgCanvas.parentNode)
                    this.canvas.parentNode.removeChild(this.canvas);

                this.svg = null;
                this.canvas = null;
                this.path = null;
                this.group = null;
            }
            else {
                // if not a forced cleanup, just detach from DOM for now.
                if (this.canvas && this.canvas.parentNode) this.canvas.parentNode.removeChild(this.canvas);
                if (this.bgCanvas && this.bgCanvas.parentNode) this.bgCanvas.parentNode.removeChild(this.bgCanvas);
            }
        },
        reattach:function(instance) {
            var c = instance.getContainer();
            if (this.canvas && this.canvas.parentNode == null) c.appendChild(this.canvas);
            if (this.bgCanvas && this.bgCanvas.parentNode == null) c.appendChild(this.bgCanvas);
        },
        setVisible: function (v) {
            if (this.canvas) {
                this.canvas.style.display = v ? "block" : "none";
            }
        }
    });

    /*
     * Base class for SVG connectors.
     */
    _jp.ConnectorRenderers.svg = function (params) {
        var self = this,
            _super = SvgComponent.apply(this, [
                {
                    cssClass: params._jsPlumb.connectorClass + (this.isEditable() ? " " + params._jsPlumb.editableConnectorClass : ""),
                    originalArgs: arguments,
                    pointerEventsSpec: "none",
                    _jsPlumb: params._jsPlumb
                }
            ]);

        var _superSetEditable = this.setEditable;
        this.setEditable = function(e) {
            var result = _superSetEditable.apply(this, [e]);
            _jp[result ? "addClass" : "removeClass"](this.canvas, this._jsPlumb.instance.editableConnectorClass);
        };

        _super.renderer.paint = function (style, anchor, extents) {

            var segments = self.getSegments(), p = "", offset = [0, 0];
            if (extents.xmin < 0) offset[0] = -extents.xmin;
            if (extents.ymin < 0) offset[1] = -extents.ymin;

            if (segments.length > 0) {

                p = self.getPathData();

                var a = {
                        d: p,
                        transform: "translate(" + offset[0] + "," + offset[1] + ")",
                        "pointer-events": params["pointer-events"] || "visibleStroke"
                    },
                    outlineStyle = null,
                    d = [self.x, self.y, self.w, self.h];

                // outline style.  actually means drawing an svg object underneath the main one.
                if (style.outlineStroke) {
                    var outlineWidth = style.outlineWidth || 1,
                        outlineStrokeWidth = style.strokeWidth + (2 * outlineWidth);
                    outlineStyle = _jp.extend({}, style);
                    delete outlineStyle.gradient;
                    outlineStyle.stroke = style.outlineStroke;
                    outlineStyle.strokeWidth = outlineStrokeWidth;

                    if (self.bgPath == null) {
                        self.bgPath = _node("path", a);
                        _jp.addClass(self.bgPath, _jp.connectorOutlineClass);
                        _appendAtIndex(self.svg, self.bgPath, 0);
                    }
                    else {
                        _attr(self.bgPath, a);
                    }

                    _applyStyles(self.svg, self.bgPath, outlineStyle, d, self);
                }

                if (self.path == null) {
                    self.path = _node("path", a);
                    _appendAtIndex(self.svg, self.path, style.outlineStroke ? 1 : 0);
                }
                else {
                    _attr(self.path, a);
                }

                _applyStyles(self.svg, self.path, style, d, self);
            }
        };
    };
    _ju.extend(_jp.ConnectorRenderers.svg, SvgComponent);

// ******************************* svg segment renderer *****************************************************	


// ******************************* /svg segments *****************************************************

    /*
     * Base class for SVG endpoints.
     */
    var SvgEndpoint = _jp.SvgEndpoint = function (params) {
        var _super = SvgComponent.apply(this, [
            {
                cssClass: params._jsPlumb.endpointClass,
                originalArgs: arguments,
                pointerEventsSpec: "all",
                useDivWrapper: true,
                _jsPlumb: params._jsPlumb
            }
        ]);

        _super.renderer.paint = function (style) {
            var s = _jp.extend({}, style);
            if (s.outlineStroke) {
                s.strokeWidth = s.strokeWidth;
                s.stroke = s.outlineStroke;
            }

            if (this.node == null) {
                this.node = this.makeNode(s);
                this.svg.appendChild(this.node);
            }
            else if (this.updateNode != null) {
                this.updateNode(this.node);
            }
            _applyStyles(this.svg, this.node, s, [ this.x, this.y, this.w, this.h ], this);
            _pos(this.node, [ this.x, this.y ]);
        }.bind(this);

    };
    _ju.extend(SvgEndpoint, SvgComponent);

    /*
     * SVG Dot Endpoint
     */
    _jp.Endpoints.svg.Dot = function () {
        _jp.Endpoints.Dot.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("circle", {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Dot, [_jp.Endpoints.Dot, SvgEndpoint]);

    /*
     * SVG Rectangle Endpoint
     */
    _jp.Endpoints.svg.Rectangle = function () {
        _jp.Endpoints.Rectangle.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("rect", {
                "width": this.w,
                "height": this.h
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "width": this.w,
                "height": this.h
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Rectangle, [_jp.Endpoints.Rectangle, SvgEndpoint]);

    /*
     * SVG Image Endpoint is the default image endpoint.
     */
    _jp.Endpoints.svg.Image = _jp.Endpoints.Image;
    /*
     * Blank endpoint in svg renderer is the default Blank endpoint.
     */
    _jp.Endpoints.svg.Blank = _jp.Endpoints.Blank;
    /*
     * Label overlay in svg renderer is the default Label overlay.
     */
    _jp.Overlays.svg.Label = _jp.Overlays.Label;
    /*
     * Custom overlay in svg renderer is the default Custom overlay.
     */
    _jp.Overlays.svg.Custom = _jp.Overlays.Custom;

    var AbstractSvgArrowOverlay = function (superclass, originalArgs) {
        superclass.apply(this, originalArgs);
        _jp.jsPlumbUIComponent.apply(this, originalArgs);
        this.isAppendedAtTopLevel = false;
        var self = this;
        this.path = null;
        this.paint = function (params, containerExtents) {
            // only draws on connections, not endpoints.
            if (params.component.svg && containerExtents) {
                if (this.path == null) {
                    this.path = _node("path", {
                        "pointer-events": "all"
                    });
                    params.component.svg.appendChild(this.path);
                    if (this.elementCreated) {
                        this.elementCreated(this.path, params.component);
                    }

                    this.canvas = params.component.svg; // for the sake of completeness; this behaves the same as other overlays
                }
                var clazz = originalArgs && (originalArgs.length == 1) ? (originalArgs[0].cssClass || "") : "",
                    offset = [0, 0];

                if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
                if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;

                _attr(this.path, {
                    "d": makePath(params.d),
                    "class": clazz,
                    stroke: params.stroke ? params.stroke : null,
                    fill: params.fill ? params.fill : null,
                    transform: "translate(" + offset[0] + "," + offset[1] + ")"
                });
            }
        };
        var makePath = function (d) {
            return (isNaN(d.cxy.x) || isNaN(d.cxy.y)) ? "" : "M" + d.hxy.x + "," + d.hxy.y +
                " L" + d.tail[0].x + "," + d.tail[0].y +
                " L" + d.cxy.x + "," + d.cxy.y +
                " L" + d.tail[1].x + "," + d.tail[1].y +
                " L" + d.hxy.x + "," + d.hxy.y;
        };
        this.transfer = function(target) {
            if (target.canvas && this.path && this.path.parentNode) {
                this.path.parentNode.removeChild(this.path);
                target.canvas.appendChild(this.path);
            }
        };
    };
    _ju.extend(AbstractSvgArrowOverlay, [_jp.jsPlumbUIComponent, _jp.Overlays.AbstractOverlay], {
        cleanup: function (force) {
            if (this.path != null) {
                if (force)
                    this._jsPlumb.instance.removeElement(this.path);
                else
                    if (this.path.parentNode)
                        this.path.parentNode.removeChild(this.path);
            }
        },
        reattach:function(instance) {
            if (this.path && this.canvas && this.path.parentNode == null)
                this.canvas.appendChild(this.path);
        },
        setVisible: function (v) {
            if (this.path != null) (this.path.style.display = (v ? "block" : "none"));
        }
    });

    _jp.Overlays.svg.Arrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Arrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Arrow, [ _jp.Overlays.Arrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.PlainArrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.PlainArrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.PlainArrow, [ _jp.Overlays.PlainArrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.Diamond = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Diamond, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Diamond, [ _jp.Overlays.Diamond, AbstractSvgArrowOverlay ]);

    // a test
    _jp.Overlays.svg.GuideLines = function () {
        var path = null, self = this, p1_1, p1_2;
        _jp.Overlays.GuideLines.apply(this, arguments);
        this.paint = function (params, containerExtents) {
            if (path == null) {
                path = _node("path");
                params.connector.svg.appendChild(path);
                self.attachListeners(path, params.connector);
                self.attachListeners(path, self);

                p1_1 = _node("path");
                params.connector.svg.appendChild(p1_1);
                self.attachListeners(p1_1, params.connector);
                self.attachListeners(p1_1, self);

                p1_2 = _node("path");
                params.connector.svg.appendChild(p1_2);
                self.attachListeners(p1_2, params.connector);
                self.attachListeners(p1_2, self);
            }

            var offset = [0, 0];
            if (containerExtents.xmin < 0) offset[0] = -containerExtents.xmin;
            if (containerExtents.ymin < 0) offset[1] = -containerExtents.ymin;

            _attr(path, {
                "d": makePath(params.head, params.tail),
                stroke: "red",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_1, {
                "d": makePath(params.tailLine[0], params.tailLine[1]),
                stroke: "blue",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_2, {
                "d": makePath(params.headLine[0], params.headLine[1]),
                stroke: "green",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });
        };

        var makePath = function (d1, d2) {
            return "M " + d1.x + "," + d1.y +
                " L" + d2.x + "," + d2.y;
        };
    };
    _ju.extend(_jp.Overlays.svg.GuideLines, _jp.Overlays.GuideLines);
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'vanilla' adapter - having no external dependencies other than bundled libs.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil,
        _jk = root.Katavorio, _jg = root.Biltong;

    var _getDragManager = function (instance, category) {

        category = category || "main";
        var key = "_katavorio_" + category;
        var k = instance[key],
            e = instance.getEventManager();

        if (!k) {
            k = new _jk({
                bind: e.on,
                unbind: e.off,
                getSize: _jp.getSize,
                getPosition: function (el, relativeToRoot) {
                    // if this is a nested draggable then compute the offset against its own offsetParent, otherwise
                    // compute against the Container's origin. see also the getUIPosition method below.
                    var o = instance.getOffset(el, relativeToRoot, el._katavorioDrag ? el.offsetParent : null);
                    return [o.left, o.top];
                },
                setPosition: function (el, xy) {
                    el.style.left = xy[0] + "px";
                    el.style.top = xy[1] + "px";
                },
                addClass: _jp.addClass,
                removeClass: _jp.removeClass,
                intersects: _jg.intersects,
                indexOf: function(l, i) { return l.indexOf(i); },
                scope:instance.getDefaultScope(),
                css: {
                    noSelect: instance.dragSelectClass,
                    droppable: "jtk-droppable",
                    draggable: "jtk-draggable",
                    drag: "jtk-drag",
                    selected: "jtk-drag-selected",
                    active: "jtk-drag-active",
                    hover: "jtk-drag-hover",
                    ghostProxy:"jtk-ghost-proxy"
                }
            });
            k.setZoom(instance.getZoom());
            instance[key] = k;
            instance.bind("zoom", k.setZoom);
        }
        return k;
    };

    var _animProps = function (o, p) {
        var _one = function (pName) {
            if (p[pName] != null) {
                if (_ju.isString(p[pName])) {
                    var m = p[pName].match(/-=/) ? -1 : 1,
                        v = p[pName].substring(2);
                    return o[pName] + (m * v);
                }
                else return p[pName];
            }
            else
                return o[pName];
        };
        return [ _one("left"), _one("top") ];
    };

    _jp.extend(root.jsPlumbInstance.prototype, {

        animationSupported:true,
        getElement: function (el) {
            if (el == null) return null;
            // here we pluck the first entry if el was a list of entries.
            // this is not my favourite thing to do, but previous versions of
            // jsplumb supported jquery selectors, and it is possible a selector
            // will be passed in here.
            el = typeof el === "string" ? el : el.length != null && el.enctype == null ? el[0] : el;
            return typeof el === "string" ? document.getElementById(el) : el;
        },
        removeElement: function (element) {
            _getDragManager(this).elementRemoved(element);
            this.getEventManager().remove(element);
        },
        //
        // this adapter supports a rudimentary animation function. no easing is supported.  only
        // left/top properties are supported. property delta args are expected to be in the form
        //
        // +=x.xxxx
        //
        // or
        //
        // -=x.xxxx
        //
        doAnimate: function (el, properties, options) {
            options = options || {};
            var o = this.getOffset(el),
                ap = _animProps(o, properties),
                ldist = ap[0] - o.left,
                tdist = ap[1] - o.top,
                d = options.duration || 250,
                step = 15, steps = d / step,
                linc = (step / d) * ldist,
                tinc = (step / d) * tdist,
                idx = 0,
                _int = setInterval(function () {
                    _jp.setPosition(el, {
                        left: o.left + (linc * (idx + 1)),
                        top: o.top + (tinc * (idx + 1))
                    });
                    if (options.step != null) options.step(idx, Math.ceil(steps));
                    idx++;
                    if (idx >= steps) {
                        window.clearInterval(_int);
                        if (options.complete != null) options.complete();
                    }
                }, step);
        },
        // DRAG/DROP
        destroyDraggable: function (el, category) {
            _getDragManager(this, category).destroyDraggable(el);
        },
        destroyDroppable: function (el, category) {
            _getDragManager(this, category).destroyDroppable(el);
        },
        initDraggable: function (el, options, category) {
            _getDragManager(this, category).draggable(el, options);
        },
        initDroppable: function (el, options, category) {
            _getDragManager(this, category).droppable(el, options);
        },
        isAlreadyDraggable: function (el) {
            return el._katavorioDrag != null;
        },
        isDragSupported: function (el, options) {
            return true;
        },
        isDropSupported: function (el, options) {
            return true;
        },
        isElementDraggable: function (el) {
            el = _jp.getElement(el);
            return el._katavorioDrag && el._katavorioDrag.isEnabled();
        },
        getDragObject: function (eventArgs) {
            return eventArgs[0].drag.getDragElement();
        },
        getDragScope: function (el) {
            return el._katavorioDrag && el._katavorioDrag.scopes.join(" ") || "";
        },
        getDropEvent: function (args) {
            return args[0].e;
        },
        getUIPosition: function (eventArgs, zoom) {
            // here the position reported to us by Katavorio is relative to the element's offsetParent. For top
            // level nodes that is fine, but if we have a nested draggable then its offsetParent is actually
            // not going to be the jsplumb container; it's going to be some child of that element. In that case
            // we want to adjust the UI position to account for the offsetParent's position relative to the Container
            // origin.
            var el = eventArgs[0].el;
            if (el.offsetParent == null) {
                return null;
            }
            var finalPos = eventArgs[0].finalPos || eventArgs[0].pos;
            var p = { left:finalPos[0], top:finalPos[1] };
            if (el._katavorioDrag && el.offsetParent !== this.getContainer()) {
                var oc = this.getOffset(el.offsetParent);
                p.left += oc.left;
                p.top += oc.top;
            }
            return p;
        },
        setDragFilter: function (el, filter, _exclude) {
            if (el._katavorioDrag) {
                el._katavorioDrag.setFilter(filter, _exclude);
            }
        },
        setElementDraggable: function (el, draggable) {
            el = _jp.getElement(el);
            if (el._katavorioDrag)
                el._katavorioDrag.setEnabled(draggable);
        },
        setDragScope: function (el, scope) {
            if (el._katavorioDrag)
                el._katavorioDrag.k.setDragScope(el, scope);
        },
        setDropScope:function(el, scope) {
            if (el._katavorioDrop && el._katavorioDrop.length > 0) {
                el._katavorioDrop[0].k.setDropScope(el, scope);
            }
        },
        addToPosse:function(el, spec) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) {
                _el = [ _jp.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.addToPosse.apply(dm, _el);
            });
        },
        setPosse:function(el, spec) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) {
                _el = [ _jp.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.setPosse.apply(dm, _el);
            });
        },
        removeFromPosse:function(el, posseId) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) {
                _el = [ _jp.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.removeFromPosse.apply(dm, _el);
            });
        },
        removeFromAllPosses:function(el) {
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) { dm.removeFromAllPosses(_jp.getElement(_el)); });
        },
        setPosseState:function(el, posseId, state) {
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) { dm.setPosseState(_jp.getElement(_el), posseId, state); });
        },
        dragEvents: {
            'start': 'start', 'stop': 'stop', 'drag': 'drag', 'step': 'step',
            'over': 'over', 'out': 'out', 'drop': 'drop', 'complete': 'complete',
            'beforeStart':'beforeStart'
        },
        animEvents: {
            'step': "step", 'complete': 'complete'
        },
        stopDrag: function (el) {
            if (el._katavorioDrag)
                el._katavorioDrag.abort();
        },
        addToDragSelection: function (spec) {
            _getDragManager(this).select(spec);
        },
        removeFromDragSelection: function (spec) {
            _getDragManager(this).deselect(spec);
        },
        clearDragSelection: function () {
            _getDragManager(this).deselectAll();
        },
        trigger: function (el, event, originalEvent, payload) {
            this.getEventManager().trigger(el, event, originalEvent, payload);
        },
        doReset:function() {
            // look for katavorio instances and reset each one if found.
            for (var key in this) {
                if (key.indexOf("_katavorio_") === 0) {
                    this[key].reset();
                }
            }
        }
    });

    var ready = function (f) {
        var _do = function () {
            if (/complete|loaded|interactive/.test(document.readyState) && typeof(document.body) != "undefined" && document.body != null)
                f();
            else
                setTimeout(_do, 9);
        };

        _do();
    };
    ready(_jp.init);

}).call(typeof window !== 'undefined' ? window : this);

;(function() {

    "use strict";

    var root = this;
    var Farahey = root.Farahey = {};
    if (typeof exports !== 'undefined') {
        exports.Farahey = Farahey;
    }

    var findInsertionPoint = function(sortedArr, val, comparator) {
            var low = 0, high = sortedArr.length;
            var mid = -1, c = 0;
            while(low < high)   {
                mid = parseInt((low + high)/2);
                c = comparator(sortedArr[mid], val);
                if(c < 0)   {
                    low = mid + 1;
                }else if(c > 0) {
                    high = mid;
                }else {
                    return mid;
                }
            }
            return low;
        },
        geomSupport = root.Biltong,
        insertSorted = function(array, value, comparator) {
            var ip = findInsertionPoint(array, value, comparator);
            array.splice(ip, 0, value);
        },
        EntryComparator = function(origin, getSize) {
            var _origin = origin,
                _cache = {},
                _get = function(entry) {
                    if (!_cache[entry[1]]) {
                        var s = getSize(entry[2]);
                        _cache[entry[1]] = {
                            l:entry[0][0],
                            t:entry[0][1],
                            w:s[0],
                            h:s[1],
                            center:[entry[0][0] + (s[0] / 2), entry[0][1] + (s[1] / 2) ]
                        };
                    }
                    return _cache[entry[1]];
                };

            this.setOrigin = function(o) {
                _origin = o;
                _cache = {};
            };
            this.compare = function(e1, e2) {
                var d1 = geomSupport.lineLength(_origin, _get(e1).center),
                    d2 = geomSupport.lineLength(_origin, _get(e2).center);

                return d1 < d2 ? -1 : d1 == d2 ? 0 : 1;
            };
        };

    var _isOnEdge = function(r, axis, dim, v) { return (r[axis] <= v && v <= r[axis] + r[dim]); },
        _xAdj = [ function(r1, r2) { return r1.x + r1.w - r2.x; }, function(r1, r2) { return r1.x - (r2.x + r2.w); } ],
        _yAdj = [ function(r1, r2) { return r1.y + r1.h - r2.y; }, function(r1, r2) { return r1.y - (r2.y + r2.h); } ],
        _adj = [ null, [ _xAdj[0], _yAdj[1] ], [ _xAdj[0], _yAdj[0] ], [ _xAdj[1], _yAdj[0] ], [ _xAdj[1], _yAdj[1] ] ],
        _genAdj = function(r1, r2, m, b, s) {
            if (isNaN(m)) m = 0;
            var y = r2.y + r2.h,
                x = (m == Infinity || m == -Infinity) ? r2.x + (r2.w / 2) :  (y - b) / m,
                theta = Math.atan(m),
                rise, hyp, run;

            if (_isOnEdge(r2, "x", "w", x)) {
                rise = _adj[s][1](r1, r2);
                hyp = rise / Math.sin(theta);
                run = hyp * Math.cos(theta);
                return { left:run, top:rise };
            }
            else {
                run = _adj[s][0](r1, r2);
                hyp = run / Math.cos(theta);
                rise = hyp * Math.sin(theta);
                return { left:run, top:rise };
            }
        },
    /*
     * Calculates how far to move r2 from r1 so that it no longer overlaps.
     * if origin is supplied, then it means we want r2 to move along a vector joining r2's center to that point.
     * otherwise we want it to move along a vector joining the two rectangle centers.
     */
        _calculateSpacingAdjustment = Farahey.calculateSpacingAdjustment = function(r1, r2) {
            var c1 = r1.center || [ r1.x + (r1.w / 2), r1.y + (r1.h / 2) ],
                c2 = r2.center || [ r2.x + (r2.w / 2), r2.y + (r2.h / 2) ],
                m = geomSupport.gradient(c1, c2),
                s = geomSupport.quadrant(c1, c2),
                b = (m == Infinity || m == -Infinity || isNaN(m)) ? 0 : c1[1] - (m * c1[0]);

            return _genAdj(r1, r2, m, b, s);
        },
    // calculate a padded rectangle for the given element with offset & size, and desired padding.
        _paddedRectangle = Farahey.paddedRectangle = function(o, s, p) {
            return { x:o[0] - p[0], y: o[1] - p[1], w:s[0] + (2 * p[0]), h:s[1] + (2 * p[1]) };
        },
        _magnetize = function(positionArray, positions, sizes, padding,
                              constrain, origin, filter,
                              updateOnStep, stepInterval, stepCallback, iterations,
                              exclude, excludeFocus)
        {
            origin = origin || [0,0];
            stepCallback = stepCallback || function() { };
            iterations = iterations || 2;

            var focus = _paddedRectangle(origin, [1,1], padding),
                iteration = 1, uncleanRun = true, adjustBy, constrainedAdjustment,
                _movedElements = {},
                _move = function(id, o, x, y) {
                    _movedElements[id] = true;
                    o[0] += x;
                    o[1] += y;
                },
                step = function() {
                    for (var i = 0; i < positionArray.length; i++) {

                        if (exclude(positionArray[i][1], positionArray[i][2])) {
                            continue;
                        }

                        var o1 = positions[positionArray[i][1]],
                            oid = positionArray[i][1],
                            a1 = positionArray[i][2], // angle to node from magnet origin
                            s1 = sizes[positionArray[i][1]],
                        // create a rectangle for first element: this encompasses the element and padding on each
                        //side
                            r1 = _paddedRectangle(o1, s1, padding);

                        if (!excludeFocus && filter(positionArray[i][1], positionArray[i][2]) && geomSupport.intersects(focus, r1)) {
                            adjustBy = _calculateSpacingAdjustment(focus, r1);
                            constrainedAdjustment = constrain(positionArray[i][1], o1, adjustBy);
                            _move(oid, o1, constrainedAdjustment.left, constrainedAdjustment.top);
                        }

                        // now move others to account for this one, if necessary.
                        // reset rectangle for node
                        r1 = _paddedRectangle(o1, s1, padding);
                        for (var j = 0; j < positionArray.length; j++) {
                            if (i != j) {

                                if (exclude(positionArray[j][1], positionArray[j][2])) {
                                    continue;
                                }

                                if (filter(positionArray[j][1], positionArray[j][2])) {
                                    var o2 = positions[positionArray[j][1]],
                                        s2 = sizes[positionArray[j][1]],
                                    // create a rectangle for the second element, again by putting padding of the desired
                                    // amount around the bounds of the element.
                                        r2 = _paddedRectangle(o2, s2, padding);

                                    // if the two rectangles intersect then figure out how much to move the second one by.
                                    if (geomSupport.intersects(r1, r2)) {
                                        // TODO (?), instead of moving neither, the other node should move.
                                        uncleanRun = true;
                                        adjustBy = _calculateSpacingAdjustment(r1, r2);
                                        constrainedAdjustment = constrain(positionArray[j][1], o2, adjustBy);
                                        _move(positionArray[j][1], o2, constrainedAdjustment.left, constrainedAdjustment.top);
                                    }
                                }
                            }
                        }
                    }

                    if (updateOnStep)
                        stepCallback();

                    if (uncleanRun && iteration < iterations) {
                        uncleanRun = false;
                        iteration++;
                        if (updateOnStep) {
                            window.setTimeout(step, stepInterval);
                        }
                        else
                            step();
                    }
                };

            step();
            return _movedElements;
        };

    var _convertElements = function(l) {
        if (l == null) return null;
        else if (Object.prototype.toString.call(l) === "[object Array]") {
            var a = [];
            a.push.apply(a, l);
            return a;
        }
        else {
            var o = [];
            for (var i in l) o.push(l[i]);
        }
        return o;
    };

    /**
     * Applies repulsive magnetism to a set of elements relative to a given point, with a specified
     * amount of padding around the point.
     * @class FaraheyInstance
     * @constructor
     * @param {Object} params Constructor parameters.
     * @param {Selector|Element} [params.container] Element that contains the elements to magnetize. Only required if you intend to use the `executeAtEvent` method.
     * @param {Function} [params.getContainerPosition] Function that returns the position of the container (as an object of the form `{left:.., top:..}`) when requested. Only required if you intend to use the `executeAtEvent` method.
     * @param {Function} params.getPosition A function that takes an element and returns its position. It does not matter to which element this position is computed as long as you remain consistent with this method, `setPosition` and the `origin` property.
     * @param {Function} params.setPosition A function that takes an element and position, and sets it. See note about offset parent above.
     * @param {Function} params.getSize A function that takes an element and returns its size, in pixels.
     * @param {Number[]} [params.padding] Optional padding for x and y directions. Defaults to 20 pixels in each direction.
     * @param {Function} [params.constrain] Optional function that takes an id and a proposed amount of movement in each axis, and returns the allowed amount of movement in each axis. You can use this to constrain your elements to a grid, for instance, or a path, etc.
     * @param {Number[]} [params.origin] The origin of magnetization, in pixels. Defaults to 0,0. You can also supply this to the `execute` call.
     * @param {Selector|String[]|Element[]} params.elements List, or object hash, of elements on which to operate.
     * @param {Boolean} [params.executeNow=false] Whether or not to execute the routine immediately.
     * @param {Function} [params.filter] Optional function that takes an element id and returns whether or not that element can be moved.
     * @param {Boolean} [params.orderByDistanceFromOrigin=false] Whether or not to sort elements first by distance from origin. Can have better results but takes more time.
     */
    var FaraheyInstance = function(params) {
        var getPosition = params.getPosition,
            getSize = params.getSize,
            getId = params.getId,
            setPosition = params.setPosition,
            padding = params.padding ||  [20, 20],
        // expects a { left:.., top:... } object. returns how far it can actually go.
            constrain = params.constrain || function(id, current, delta) { return delta; },
            positionArray = [],
            positions = {},
            sizes = {},
            elements = _convertElements(params.elements || []),
            origin = params.origin || [0,0],
            executeNow = params.executeNow,
        //minx, miny, maxx, maxy,
            getOrigin = this.getOrigin = function() { return origin; },
            filter = params.filter || function(_) { return true; },
            exclude = params.exclude || function(_) { return false;},
            orderByDistanceFromOrigin = params.orderByDistanceFromOrigin,
            comparator = new EntryComparator(origin, getSize),
            updateOnStep = params.updateOnStep,
            stepInterval = params.stepInterval || 350,
            originDebugMarker,
            debug = params.debug,
            createOriginDebugger = function() {
                var d = document.createElement("div");
                d.style.position = "absolute";
                d.style.width = "10px";
                d.style.height = "10px";
                d.style.backgroundColor = "red";
                document.body.appendChild(d);
                originDebugMarker = d;
            },
            _addToPositionArray = function(p) {
                if (!orderByDistanceFromOrigin || positionArray.length == 0)
                    positionArray.push(p);
                else {
                    insertSorted(positionArray, p, comparator.compare);
                }
            },
            _computeExtents = function(els) {
                var minx, miny, maxx, maxy;
                minx = miny = Infinity;
                maxx = maxy = -Infinity;
                for (var i = 0; i < els.length; i++) {
                    var p = getPosition(els[i]),
                        s = getSize(els[i]),
                        id = getId(els[i]);

                    positions[id] = [p.left, p.top];
                    _addToPositionArray([ [p.left, p.top], id, els[i]]);
                    sizes[id] = s;
                    minx = Math.min(minx, p.left);
                    miny = Math.min(miny, p.top);
                    maxx = Math.max(maxx, p.left + s[0]);
                    maxy = Math.max(maxy, p.top + s[1]);
                }

                return [ minx, maxx, miny, maxy ];

            },
            _updatePositions = function() {
                comparator.setOrigin(origin);
                positionArray = []; positions = {}; sizes = {};
                return _computeExtents(elements);
            },
            _run = function(options) {
                if (elements.length > 1) {
                    options = options || {};
                    var f = options.filter || filter;
                    var p = options.padding || padding;
                    var i = options.iterations;
                    var e = options.exclude || exclude;
                    var ef = options.excludeFocus;
                    var _movedElements = _magnetize(positionArray, positions, sizes, p, constrain, origin, f, updateOnStep, stepInterval, _positionElements, i, e, ef);
                    _positionElements(_movedElements);
                }
            },
            _positionElements = function(_movedElements) {
                for (var i = 0; i < elements.length; i++) {
                    var id = getId(elements[i]);
                    if (_movedElements[id])
                        setPosition(elements[i], { left:positions[id][0], top:positions[id][1] });
                }
            },
            setOrigin = function(o) {
                if (o != null) {
                    origin = o;
                    comparator.setOrigin(o);
                }
            };

        /**
         * Runs the magnetize routine.
         * @method execute
         * @param {Number[]} [o] Optional origin to use. You may have set this in the constructor and do not wish to supply it, or you may be happy with the default of [0,0].
         * @param {Function} [options] Options to override defaults.
         * @param {Function} [options.filter] Optional function to indicate whether a given element may be moved or not. Returning boolean false indicates it may not.
         * @param {Number[]} [options.padding] Optional [x,y] padding values for elements.
         * @param {Number} [options.iterations] Optional max number of iterations to run. The greater this number, the more comprehensive the magnetisation,
         * but the slower it runs. The default is 2.
         * @param {Function} [options.exclude] Optional function to return whether or not a given element should be completely excluded from the magnetisation: it neither
         * moves, nor has any bearing on the movement of other elements.
         * @param {Boolean} [options.excludeFocus=false] If true, do not pad any elements around the focus point.
         */
        this.execute = function(o, options) {
            setOrigin(o);
            _updatePositions();
            _run(options);
        };

        /**
         * Computes the center of all the nodes and then uses that as the magnetization origin when it runs the routine.
         * @method executeAtCenter
         * @param {Function} [options] Options to override defaults.
         * @param {Function} [options.filter] Optional function to indicate whether a given element may be moved or not. Returning boolean false indicates it may not.
         * @param {Number[]} [options.padding] Optional [x,y] padding values for elements.
         * @param {Number} [options.iterations] Optional max number of iterations to run. The greater this number, the more comprehensive the magnetisation,
         * but the slower it runs. The default is 2.
         * @param {Function} [options.exclude] Optional function to return whether or not a given element should be completely excluded from the magnetisation: it neither
         * moves, nor has any bearing on the movement of other elements.
         * @param {Boolean} [options.excludeFocus=false] If true, do not pad any elements around the focus point.
         */
        this.executeAtCenter = function(options) {
            var extents = _updatePositions();
            setOrigin([
                    (extents[0] + extents[1]) / 2,
                    (extents[2] + extents[3]) / 2
            ]);
            _run(options);
        };

        /**
         * Runs the magnetize routine using the location of the given event as the origin. To use this
         * method you need to have provided a `container`,  and a `getContainerPosition` function to the
         * constructor.
         * @method executeAtEvent
         * @param {Event} e Event to get origin location from.
         * @param {Function} [options] Options to override defaults.
         * @param {Function} [options.filter] Optional function to indicate whether a given element may be moved or not. Returning boolean false indicates it may not.
         * @param {Number[]} [options.padding] Optional [x,y] padding values for elements.
         * @param {Number} [options.iterations] Optional max number of iterations to run. The greater this number, the more comprehensive the magnetisation,
         * but the slower it runs. The default is 2.
         * @param {Function} [options.exclude] Optional function to return whether or not a given element should be completely excluded from the magnetisation: it neither
         * moves, nor has any bearing on the movement of other elements.
         * @param {Boolean} [options.excludeFocus=false] If true, do not pad any elements around the focus point.
         */
        this.executeAtEvent = function(e, options) {
            var c = params.container,
                o = params.getContainerPosition(c),
                x = e.pageX - o.left + c.scrollLeft,
                y = e.pageY - o.top + c.scrollTop;

            if (debug) {
                originDebugMarker.style.left = e.pageX + "px";
                originDebugMarker.style.top = e.pageY + "px";
            }

            this.execute([x,y], options);
        };

        /**
         * Sets the current set of elements on which to operate.
         * @method setElements
         * @param {Object[]|Object} _els List, or object hash, of elements, in whatever format the Magnetizer is setup to use. If you supply an object hash then a list is generated from the hash's values (the keys are ignored).
         */
        this.setElements = function(_els) {
            elements = _convertElements(_els);
            return this;
        };

        /**
         * Adds the given element to the set of elements on which to operate.
         * @method addElement
         * @param el {Object} Element to add.
         * @param {Boolean} [doNotTestForDuplicates=false] If true, we skip the check for duplicates. This makes
         * for a much faster call when there are lots of elements, just use it with care.
         */
        this.addElement = function(el, doNotTestForDuplicates) {
            if (el != null && (doNotTestForDuplicates || elements.indexOf(el) === -1)) {
                elements.push(el);
            }
            return this;
        };

        /**
         * Adds the given elements to the set of elements on which to operate.
         * @method addElements
         * @param els {Object[]} Elements to add.
         * @param {Boolean} [doNotTestForDuplicates=false] If true, we skip the check for duplicates. This makes
         * for a much faster call when there are lots of elements, just use it with care.
         */
        this.addElements = function(els, doNotTestForDuplicates) {
            if (doNotTestForDuplicates) {
                Array.prototype.push.apply(elements, els);
            }
            else {
                for (var i = 0; i < els.length; i++) {
                    this.addElement(els[i]);
                }
            }
            return this;
        };

        /**
         * Gets the list of elements currently being managed.
         * @method getElements
         */
        this.getElements = function() {
            return elements;
        };

        /**
         * Removes the given element from the set of elements on which to operate.
         * @method removeElement
         * @param el {Object} Element to remove.
         */
        this.removeElement = function(el) {
            var idx = -1;
            for (var i = 0; i < elements.length; i++) {
                if (elements[i] == el) {
                    idx = i; break;
                }
            }
            if (idx != -1) elements.splice(idx, 1);
            return this;
        };

        /**
         * Sets the padding to insert between magnetized elements.
         * @method setPadding
         * @param {Number[]} p Array of padding for each axis.
         */
        this.setPadding = function(p) {
            padding = p;
        };

        /**
         * Sets the function used to constrain the movement of some element that the magnetizer wishes to relocate.
         * The function is given an element ID and an array of [x,y] values, where each value indicates the proposed amount
         * of movement in the given axis. The function is expected to return an array of [x,y] that indicates the allowed
         * amount of movement in each axis.
         * @method setConstrain
         * @param {Function} c
         */
        this.setConstrain = function(c) {
            constrain = c;
        };

        /**
         * Sets the function used to determine whether or not a given element should be considered during the magnetization process.
         * @method setFilter
         * @param {Function} f Filter function to use. Takes an element ID and returns whether or not that element can be moved.
         */
        this.setFilter = function(f) {
            filter = f;
        };

        /**
         * Reset the Farahey instance. Use this to avoid memory leaks.
         * @method reset
         */
        this.reset = function() {
            elements.length = 0;
        };

        if (debug)
            createOriginDebugger();

        if (executeNow) this.execute();
        return this;

    };

    /**
     * Gets a new FaraheyInstance
     * @method
     * @param {Object} params Method parameters.
     * @param {Selector|Element} [params.container] Element that contains the elements to magnetize. Only required if you intend to use the `executeAtEvent` method.
     * @param {Function} [params.getContainerPosition] Function that returns the position of the container (as an object of the form `{left:.., top:..}`) when requested. Only required if you intend to use the `executeAtEvent` method.
     * @param {Function} params.getPosition A function that takes an element and returns its position. It does not matter to which element this position is computed as long as you remain consistent with this method, `setPosition` and the `origin` property.
     * @param {Function} params.setPosition A function that takes an element and position, and sets it. See note about offset parent above.
     * @param {Function} params.getSize A function that takes an element and returns its size, in pixels.
     * @param {Number[]} [params.padding] Optional padding for x and y directions. Defaults to 20 pixels in each direction.
     * @param {Function} [params.constrain] Optional function that takes an id and a proposed amount of movement in each axis, and returns the allowed amount of movement in each axis. You can use this to constrain your elements to a grid, for instance, or a path, etc.
     * @param {Number[]} [params.origin] The origin of magnetization, in pixels. Defaults to 0,0. You can also supply this to the `execute` call.
     * @param {Selector|String[]|Element[]} params.elements List, or object hash, of elements on which to operate.
     * @param {Boolean} [params.executeNow=false] Whether or not to execute the routine immediately.
     * @param {Function} [params.filter] Optional function that takes an element id and returns whether or not that element can be moved.
     * @param {Boolean} [params.orderByDistanceFromOrigin=false] Whether or not to sort elements first by distance from origin. Can have better results but takes more time.
     */
    Farahey.getInstance = function(params) {
        return new FaraheyInstance(params);
    };

}).call(typeof window !== 'undefined' ? window : this);


;(function() {

    var root = this;

    Array.prototype.peek = function() { return this.length > 0 ? this[this.length - 1] : null; };
    var ieVersion = typeof navigator !== "undefined" ? /MSIE\s([\d.]+)/.test(navigator.userAgent) ? (new Number(RegExp.$1)) : -1 : -1;
    var oldIE = ieVersion > -1 && ieVersion < 9;

    var CustomTag = function(_rotors, tagName, handlers) {
        var combineAttributes = function(ast, fromParseTree) {
            var out = [];
            for (var i = 0; i < ast.length; i++) {
                var newAstEntry = _extend({}, ast[i]);
                out.push(newAstEntry);
                _extend(newAstEntry.atts, fromParseTree.atts, function(k, v) {
                    _bindOneAtt(k, v, newAstEntry, null, _rotors);
                });
            }
            return out;
        }.bind(this);

        this.template = handlers.template;
        this.getFunctionBody = function(parseTree) {
            return _rotors.compile(combineAttributes(_rotors.parse(handlers.template, null, {originalCustomTag:parseTree.tag,context:parseTree.context}), parseTree), false, true, true);
        }.bind(this);
        this.getFunctionEnd = function() {
            return ";_els.pop();";
        };
        this.rendered = handlers.rendered || function() { };
        this.updated = handlers.updated || function() { };
    };

    var
        /**
         * Iterate through a list of strings and perform on operation on each item that is not empty.
         * @static
         * @param strings
         * @param fn
         * @private
         */
        _eachNotEmpty = function(strings, fn) {
            for (var i = 0; i < strings.length; i++) {
                var t = strings[i];
                if (t == null || t.length == 0) continue;
                else {
                    fn(i, t);
                }
            }
        },
        _extend = function(o1, o2, cb) {
            for (var o in o2) {
                o1[o] = o2[o];
                if (cb) cb(o, o1[o]);
            }
            return o1;
        },
        /**
         * Extract a value from, or set a value into, an Object.
         * @param {Object} inObj Object to extract value from or insert value into
         * @param {String} path Path to the value to extract/insert, in dotted notation. This syntax also supports array indices,
         * such as `foo.bar[3]`.
         * @param {Object} [value] If provided, this method sets the value. Otherwise it extracts the current value.
         * @static
         * @return {Object} Value for the given path, null if not found.
         */
        _data = function(inObj, path, value) {
            if (inObj == null) return null;
            if (path === "$data" || path == null) return inObj;
            // if path is actually an object spec,
            var objectSpec = path.match(/^\{(.*)\}$/);
            if (objectSpec) {
                var out = {}, parts = objectSpec[1].split(",");
                for (var i = 0; i < parts.length; i++) {
                    var pp = parts[i].split(":"), v = _data(inObj, pp[1]);
                    out[_trim(pp[0])] = v || pp[1].replace(/'/g, "");
                }
                return out;
            }
            // replace any quoted accessors with dotted syntax
            path = path.replace(/\['([^']*)'\]/g, ".$1");
            var q = inObj, t = q, o = null;
            path.replace(/([^\.])+/g, function(term, lc, pos, str) {
                if (o != null) return;
                var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
                    last = pos + term.length >= str.length,
                    _getArray = function() {
                        return t[array[1]] || (function() {  t[array[1]] = []; return t[array[1]]; })();
                    };

                if (last) {
                    if (array) {
                        var _a = _getArray(), idx = array[3];
                        if (value == null)
                            o = _a[idx];
                        else
                            _a[idx] = value;
                    }
                    else {
                        if (value == null)
                            o = t[term];
                        else
                            t[term] = value;
                    }
                }
                else {
                    // set to current t[term], creating t[term] if necessary.
                    if (array) {
                        var a = _getArray();
                        t = a[array[3]] || (function() { a[array[3]] = {}; return a[array[3]]; })();
                    }
                    else
                        t = t[term] || (function() { t[term] = {}; return t[term]; })();
                }
            });

            return o;
        },

    // template resolver for when running in a browser
        InBrowserTemplateResolver = function(tid) {
            var d = root.document.getElementById(tid);
            return (d != null) ? d.innerHTML : null;
        },
        _isArray = function(a) { return Object.prototype.toString.call(a) === "[object Array]";},
        _isObject = function(a) { return Object.prototype.toString.call(a) === "[object Object]"; },
        _flatten = function(a) {
            var o = [];
            for (var i = 0; i < a.length; i++) {
                if (_isArray(a[i]))
                    o.push.apply(o, _flatten(a[i]));
                else
                    o[o.length] = a[i];
            }
            return o;
        },
        _map = function(l, fn) {
            var o = [];
            for (var i = 0, j = l.length; i < j; i++)
                o.push(fn(l[i]));
            return _flatten(o);
        },
        _filter = function(l, fn) {
            var o = [];
            for (var i = 0, j = l.length; i < j; i++)
                if (fn(l[i])) o.push(l[i]);
            return o;
        },
        _trim = function(s) {
            if (s == null) return s;
            var str = s.replace(/^\s\s*/, ''),
                ws = /\s/,
                i = str.length;
            while (ws.test(str.charAt(--i)));
            return str.slice(0, i + 1);
        },
    //
    // add an attribute binding, optionally with a predicate that must be true.
    //
        _addBinding = function(bindingId, match, entry, predicate, _rotors) {
            var u = _uuid(), b = { w: match, e: [], u: u };
            _rotors.bindings[u] = b;
            var fnBody = function() {
                return predicate != null ?
                    "try {  if(" + predicate + ") { out = out.replace(this.e[k][0], eval(this.e[k][1])); } else out=''; } catch(__) { out='';}"
                    :
                    "try { out = out.replace(this.e[k][0], eval(this.e[k][1])); } catch(__) { out=out.replace(this.e[k][0], '');}";
            };
            var prefix = function() {
                return predicate != null ?
                    "var out='';try { with($data) { if (" + predicate + ") out = this.w; else return null; }}catch(_){return null;}"
                    :
                    "var out = this.w;"
            };
            b.reapply = new Function("$data", prefix() + "for (var k = 0; k < this.e.length; k++) { with($data) { " + fnBody() + " }} return out;");
            entry.bindings[bindingId] = b;
            match.replace(/\$\{([^\}]*)\}/g, function (term, content, _loc, _whole) {
                b.e.push([term, content]);
            });
            return u;
        },
        _bindOneAtt = function(id, value, output, predicate, _rotors) {
            output.atts[id] = value;
            _addBinding(id, value, output, predicate, _rotors);
        },
        _parseAtts = function(el, _rotors) {
            var p = _rotors.parseAttributes(el),
                o = { el: _trim(p[0]), atts: {}, bindings: {} };

            function _maybeBindAttribute(_p, predicate) {
// if not an inline if, parse a normal attribute.
                var m = _p.match(/([^=]+)=['"](.*)['"]/);
                if (m == null && predicate == null) {
                    o.atts[_p] = "";
                }
                else if (m == null)
                    _bindOneAtt(_p, "", o, predicate, _rotors);
                else {
                    _bindOneAtt(m[1], m[2], o, predicate, _rotors);
                }
                return m;
            }

            for (var i = 1; i < p.length; i++) {
                var _p = _trim(p[i]);
                if (_p != null && _p.length > 0) {

                    // test if this is an inline IF statement. if so, its content should be run back through the attribute
                    // parser to get its constituent parts.
                    var isInlineIf = _p.match(_rotors.inlineIfRe);
                    if (isInlineIf) {
                        var parts = isInlineIf[2].split(_rotors.attributesRe);
                        // add each part one by one using the code below but with the predicate attached.
                        for (var j = 0; j < parts.length; j++) {
                            var __p = _trim(parts[j]);
                            if (__p != null && __p.length > 0) {
                                _maybeBindAttribute(__p, isInlineIf[1]); // bind the attribute with the given predicate.
                            }
                        }
                    }
                    else {
                        _maybeBindAttribute(_p);
                    }
                }
            }
            return o;
        },

        counter = 0,
        o_uuid = function() { return "" + (++counter);},

        _uuid = function(fullLength) {
            var str = fullLength ? 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx' : 'xxxxxxxx-xxxx-4xxx';
            return (str.replace(/[xy]/g, function(c) {
                var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
                return v.toString(16);
            }));
        },
        _isLoopPresent = function(stack) {
            if (stack == null || stack.length == 0) return false;
            else {
                for (var i = stack.length - 1; i > -1; i--) {
                    if (stack[i].type === "each") return true;
                }
            }
            return false;
        },
        _bind = function(fromObj, id) {
            var b = this.bindings[id];
            if (b == null) return "";
            else {
                return b.reapply(fromObj);
            }
        },
        AbstractEntry = function(params, _rotors) {
            this.uuid = _uuid();
            this.children = [];
            this.instance = _rotors;
            _rotors.entries[this.uuid] = this;
        },
        ElementEntry = function(data, _rotors) {
            AbstractEntry.apply(this, arguments);
            var ta = _parseAtts(data, _rotors);
            // r-toggle attribute is set and a toggle manager is present, ask if this element should be included.
            if (ta.atts["r-toggle"] != null && _rotors.toggleManager != null) {
                this.discard = (_rotors.toggleManager(ta.atts["r-toggle"]) === false);
            }

            var p = ta.el.split(":");
            this.tag = ta.el;
            if (p.length == 2) this.namespace = p[0];
            this.atts = ta.atts;
            this.bindings = ta.bindings;
            this.type = "element";
            this.compile = function(_rotors, isCustomScope) {

                var custom = _rotors.customTags[this.tag] || _rotors.globalTags[this.tag];
                if (custom) {
                    var fb = custom.getFunctionBody(this);
                    var renderCb = _rotors.customTags[this.tag] ? "_rotors.customTags['" + this.tag + "'].rendered(_le, _rotors);" : "_rotors.globalTags['" + this.tag + "'].rendered(_le, _rotors);";
                    for (var c = 0 ; c < this.children.length; c++) {
                        if (this.children[c].precompile) fb += this.children[c].precompile(_rotors);
                        fb += this.children[c].compile(_rotors);
                        if (this.children[c].postcompile) fb += this.children[c].postcompile(_rotors);
                    }
                    fb += "_le=_els.pop();" +  renderCb   + "_rotors.pet(_eid,'" + this.uuid +"');";
                    return fb;
                }

                var fp = "/* element entry " + this.uuid + " */;";
                // custom elements may set `remove` to true, meaning they behave as an element but their element should not appear in the output.
                if (this.remove !== true) {

                    fp += _rotors.getExecutionContent(this.tag, this.uuid, false, this.namespace);

                    for (var a in this.atts) {
                        if (this.atts.hasOwnProperty(a)) {
                            var attExpr;
                            if (this.bindings[a] != null) {
                                // data bound.
                                attExpr = "_rotors.bind(data[0], '" + this.bindings[a].u + "');";
                            }
                            else {
                                // a static attribute value.
                                attExpr = "'" + this.atts[a] + "'";
                            }
                            fp += "__a=" + attExpr + ";if(__a!=null) {_rotors.setAttribute(e,'" + a + "',__a || '');}";
                        }
                    }
                }

                for (var i = 0 ; i < this.children.length; i++) {
                    if (this.children[i].precompile) fp += this.children[i].precompile(_rotors);
                    fp += this.children[i].compile(_rotors);
                    if (this.children[i].postcompile) fp += this.children[i].postcompile(_rotors);
                }

                // see note above.
                if (this.remove !== true && !isCustomScope) {
                    fp += "_le=_els.pop();";
                    fp += "_rotors.pet(_eid, '" + this.uuid + "');";
                }

                return fp;
            };

            var _applyStyles = function(el, styles) {
                _rotors.each(styles.split(";"),  function(s) {
                    var ss = s.indexOf(":"),
                        prop = s.substring(0, ss);

                    el.style[prop] = s.substring(ss + 1);
                })
            };

            this.update = function(el, data) {
                for (var a in this.atts) {
                    // don't overwrite the class attribute ever. other parts of the UI - outside of Rotors - might
                    // be using it. If you need to style elements based on attributes written by the templates you
                    // can do so without needing to use `class`.
                    if (this.atts.hasOwnProperty(a) && a !== "class") {
                        var attExpr;
                        if (this.bindings[a] != null) {
                            attExpr = this.bindings[a].reapply(data);
                        }
                        else {
                            // a static attribute value.
                            attExpr = "'" + this.atts[a] + "'";
                        }

                        if (attExpr != null) {
                            // special handling for `style` property. write values to the element's `style` instead;
                            // writing to the style attribute blats everything that is already there. One example of
                            // something that breaks is absolute positioning setup by a drag manager.
                            if (a === "style" && el.style != null)
                                _applyStyles(el, attExpr);
                            else
                                el.setAttribute(a, attExpr);
                        }
                    }
                }

                if (this.originalCustomTag) {
                    var tag = _rotors.customTags[this.originalCustomTag] || _rotors.globalTags[this.originalCustomTag];
                    if (tag) {
                        tag.updated(el, data);
                    }
                }
            };
        },
        CommentEntry = function(c) {
            this.uuid = _uuid();
            this.comment = c;
            this.compile = function() { return ""; };
        },
        TextEntry = function(params, _rotors) {
            AbstractEntry.apply(this, arguments);
            this.value = params.value;
            this.type = "text";
            this.bindings = {};
            var _getBoundValue = function() {
                return "_rotors.bind(data[0], '" + this.bindings["__element"].u + "', typeof $key !== 'undefined' ? $key : null, typeof $value !== 'undefined' ? $value : null)";
            }.bind(this);
            this.compile = function(_rotors) {
                return _rotors.getExecutionContent(_getBoundValue(), this.uuid, true) + ";_rotors.pet(_eid, '" + this.uuid +"');";
            };
            this.update = function(el, data) {
                el.nodeValue = this.bindings["__element"].reapply(data);
            };
        },
    //
    // a fake document fragment, for those times that Rotors is getting isomorphic.
    //
        Fakement = function() {
            this.childNodes = [];
            this.appendChild = function(n) {
                this.childNodes.push(n);
            };

            this.toString = function() {
                var o = "";
                for (var i = 0; i < this.childNodes.length; i++) {
                    o += this.childNodes[i].toString();
                }
                return o;
            };
        },
        FakeElement = function(tag) {
            Fakement.apply(this);
            this.tag = tag;
            var atts = {};
            this.setAttribute = function(name, value) { atts[name] = value; };
            this.getAttribute = function(name) { return atts[name]; };
            this.setAttributeNS = function(ns, name, value) { atts[ns + ":" + name] = value; };

            this.toString = function() {
                var o = "<" + this.tag, a = "";
                for (var _a in atts) {
                    a += (" " + _a + "=\"" + atts[_a] + "\"");
                }
                o = o + a + ">";

                for (var i = 0; i < this.childNodes.length; i++) {
                    o += this.childNodes[i].toString();
                }

                return o +"</" + this.tag + ">";
            };
        },
        FakeTextNode = function(value) {
            this.nodeValue = value;
            this.toString = function() { return this.nodeValue; };
        },
        _getDefaultTemplateResolver = function(_rotors) {
            return _rotors.isBrowser ? InBrowserTemplateResolver : null;
        },
        _wrapCache = function(_rotors, resolver, forceReload) {
            return function(id) {
                var t = forceReload ? null : _rotors.cache[id];
                if (t == null) {
                    t = resolver(id);
                }
                if (t == null) {
                    t = _rotors.defaultTemplate;
                }
                if (t != null) {
                    _rotors.cache[id] = t;
                }
                return t;
            };
        };

    var RotorsInstance = function(params) {
        params = params || {};
        this.cache = {};
        this.templateCache = {};
        this.customTags ={};
        if (params.defaultTemplate != null) {
            this.setDefaultTemplate(params.defaultTemplate);
        }
        this.templateResolver = params.templateResolver ? params.templateResolver :
                                params.templates ? function(id) {
                                    return params.templates[id];
                                } : _getDefaultTemplateResolver(this);

        this.toggleManager = null;
    };
    var _e = function(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) a[i] = b[i];
        }
    };
    _e(RotorsInstance.prototype, {
        bindings:{},
        entries:{},
        executions:{},
        bind:_bind,
        defaultTemplate:"<div></div>",
        defaultCompiledTemplate:null,
        setDefaultTemplate:function(str) {
            if (str != null) {
                this.defaultTemplate = str;
                this.defaultCompiledTemplate = this.compile(this.parse(str));
            }
            else {
                this.clearDefaultTemplate();
            }
        },
        clearDefaultTemplate:function() {
            this.defaultTemplate = null;
            this.defaultCompiledTemplate = null;
        },
        /**
         * Clears the template cache for this instance of Rotors.
         * @method clearCache
         */
        clearCache:function() { this.cache = {}; this.templateCache = {}; },
        namespaceHandlers : {
            "svg":function(tag) {
                return "e = document.createElementNS('http://www.w3.org/2000/svg', '" + tag.split(":")[1] + "');" +
                    "e.setAttribute('version', '1.1');" +
                    "e.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');";
            }
        },
        namespaces:{
            "xlink":"http://www.w3.org/1999/xlink"
        },
        each:function(l, fn, loopUuid, ctx) {
            var i;
            if (_isArray(l)) {
                for (i = 0; i < l.length; i++) {
                    fn(l[i], loopUuid, i, ctx);
                }
            }
            else {
                for (i in l) {
                    if (l.hasOwnProperty(i)) {
                        fn({"$key":i, "$value":l[i]}, loopUuid, i, ctx);
                    }
                }
            }
        },
        openRe : new RegExp("<([^\/>]*?)>$|<([^\/].*[^\/])>$"),
        closeRe : new RegExp("^<\/([^>]+)>"),
        openCloseRe : new RegExp("<(.*)(\/>$)"),
        tokenizerRe:/(<[^\^>]+\/>)|(<!--[\s\S]*?-->)|(<[\/a-zA-Z0-9\-:]+(?:\s*[a-zA-Z\-]+=\"[^\"]*\"|\s*[a-zA-Z\-]+='[^']+'|\s*[a-zA-Z\-]|\s*\{\{.*\}\})*>)/,
        commentRe: /<!--[\s\S]*?-->/,
        attributesRe:/([a-zA-Z0-9\-_:]+="[^"]*")|(\{\{if [^(?:\}\})]+\}\}.*\{\{\/if\}\})/,
        inlineIfRe:/\{\{if ([^\}]+)\}\}(.*)\{\{\/if\}\}/,
        singleExpressionRe : /^[\s]*\$\{([^\}]*)\}[\s]*$/,          // match an expression such as ${foo} or ${x/2}
        parseAttributes : function(d) {
            return d == null ? d : this.filterEmpty(d.replace("/>", ">").split(/^<|>$/)[1].split(this.attributesRe));
        },
        map:_map,
        flatten:_flatten,
        filter:_filter,
        data:_data,
        uuid:_uuid,
        filterEmpty:function(l) {
            return _filter(l, function(i) { return i != null && _trim(i).length > 0; });
        },
        // exposed for override when testing.
        isBrowser:(function() { return typeof navigator !== "undefined"; })(),
        // exposed for override when testing.
        isOldIE : function() { return oldIE; },
        // create fragment
        cf:function() {
            return this.isBrowser ? this.isOldIE() ? root.document.createElement("div") : root.document.createDocumentFragment() : new Fakement();
        },
        // create text node
        ctn:function(value) {
            return this.isBrowser ? root.document.createTextNode(value) : new FakeTextNode(value);
        },
        // create element
        ce:function(tag) {
            return this.isBrowser ? root.document.createElement(tag) : new FakeElement(tag);
        },
        customElements:{
            "r-each":{
                parse:function(entry, match, templateResolver, _rotors) {
                    entry.context = entry.atts["in"];
                    entry.type = "each";
                },
                compile:function(_rotors) {
                    var _getChildContent = function() {
                        var out = "function(item, _rotorsLoopId, _rotorsLoopIndex, _rotorsLoopContext) { ";
                        out += "data.unshift(item);$value=item;$key=_rotorsLoopIndex;";
                        for (var i = 0; i < this.children.length; i++) {
                            out += this.children[i].compile(_rotors);
                        }
                        out += "data.splice(0,1);";
                        out += "}";
                        return out;
                    }.bind(this);
                    var l1 =";_rotors.te(null, _eid, '" + this.uuid + "');";
                    var l2 = this.context ? ";data.unshift(_rotors.data(data[0], \"" + this.context + "\"));" : "";
                    var l3 = "_rotors.each(data[0], " + _getChildContent() + ",'"  + this.uuid + "', '" + this.context.replace(/'/g, "\\'") + "');";
                    var l4 = this.context ? ";data.splice(0, 1);" : "";
                    var l5 = ";_rotors.pet(_eid, '" + this.uuid + "');";
                    return l1 + l2 + l3 + l4 + l5;
                }
            },
            "r-if":{
                parse:function(entry, match, templateResolver, _rotors) {
                    entry.test = entry.atts["test"];
                },
                compile:function(_rotors) {
                    var c = "", _else = "", i;
                    var happyFlow = this.happyFlowChildren || this.children;
                    for (i = 0; i < happyFlow.length; i++) {
                        c += happyFlow[i].compile(_rotors) + ";";
                    }
                    if (this.happyFlowChildren != null) {
                        // if happy flow was set, then `children` is unhappy flow.
                        _else = "else {";
                        for (i = 0; i < this.children.length; i++) {
                            _else += this.children[i].compile(_rotors) + ";";
                        }
                        _else += "}";
                    }
                    return ";with (data[0]) { if(" + this.test + ") { " + c + " }" + _else + "}";
                }
            },
            "r-else":{
                remove:true,
                parse:function(entry, match, templateResolver, _rotors, stack) {
                    var ifStatement = stack.peek();
                    if (ifStatement == null || ifStatement.tag !== "r-if") return;
                    else {
                        ifStatement.happyFlowChildren = ifStatement.children;
                        ifStatement.children = [];
                    }
                },
                compile:function(_rotors) { }
            },
            "r-for":{
                parse:function(entry, match, templateResolver, _rotors, stack) {
                    entry.loop = entry.atts["loop"];
                },
                compile:function(_rotors) {
                    var out = "";
                    out += "var __limit; with(data[0]){__limit=(" + this.loop + ");}";
                    out += "for(var $index=0;$index<__limit;$index++){data[0].$index=$index;";
                    for (var i = 0; i < this.children.length; i++) {
                        out += this.children[i].compile(_rotors) + ";";
                    }
                    out += "}delete data[0].$index;";
                    return out;

                }
            },
            "r-tmpl":{
                remove:true,
                parse:function(entry, match, templateResolver, _rotors, stack, parseStack) {
                    entry.type = "template";
                    entry.context = entry.atts["context"];

                    if (!entry.atts["lookup"]) {
                        entry.templateId = entry.atts["id"];

                        var insideLoop = _isLoopPresent(stack);

                        if (parseStack.indexOf(entry.templateId) !== -1) {
                            if (!insideLoop) {
                                throw new TypeError("recursive template call [" + entry.templateId + "]");
                            } else {
                                entry.compile = function (_rotors) {
                                    return ";eval(_rotors.templateCache['" + entry.templateId + "'].functionBody);";
                                };
                            }
                        }
                        else {
                            // insert the nested ast. this means resolving the template, creating an ast, and inserting all
                            // the entries. also, push the template id on the parse stack, to avoid recursing on the same
                            // template

                            var _nested = templateResolver(entry.templateId);
                            parseStack.push(entry.templateId);
                            var nestedAst = _rotors.parse(_nested, templateResolver, null, parseStack);

                            // if not in the template cache, compile it and add it.
                            if (_rotors.templateCache[entry.templateId] == null) {
                                _rotors.templateCache[entry.templateId] = _rotors.compile(nestedAst);
                            }

                            // write context in to nested ast roots
                            for (var i = 0; i < nestedAst.length; i++) {
                                nestedAst[i].context = entry.context;
                            }
                            _rotors.debug("nested ast", nestedAst);
                            entry.children = nestedAst;

                            parseStack.pop();
                        }
                    }
                    else {
                        entry.lookup = entry.atts["lookup"];
                        entry.default = entry.atts["default"] || "";
                        entry.compile = function (_rotors) {
                            return ";with(data[0]){var tlid=eval(\"" + entry.lookup.replace(/[\$\{\}]/g, "") + "\");}" +
                                "if (_rotors.templateCache[tlid] == null){var ___t = _rotors.templateResolver(tlid) || _rotors.templateResolver(\"" + entry.default  + "\");_rotors.templateCache[tlid]=_rotors.compile(_rotors.parse(___t));} eval(_rotors.templateCache[tlid].functionBody);";
                        };
                    }
                },
                precompile:function(_rotors) {
                    return this.context ? ";data.unshift(_rotors.data(data[0], \"" + this.context + "\"));" : "";
                },
                postcompile:function(_rotors) {
                    return this.context ? ";data.splice(0, 1);" : "";
                }
            },
            "r-html":{
                parse:function(entry, match, templateResolver, _rotors) { },
                compile:function(_rotors) {
                    return ";var __hp=_rotors.parse(data[0].value),__hc=_rotors.compile(__hp,true);var __f=__hc(data[0], _rotors);_els.peek().appendChild(__f.childNodes[0]);";
                }
            }
        },
        globalTags : {},
        registerTag:function(tagName, handlers, isGlobal) {
            this[isGlobal ? "globalTags" : "customTags"][tagName] = new CustomTag(this, tagName, handlers);
        },
        setAttribute:function(el, a, v) {
            var p = a.split(":");
            if (p.length === 1 || this.namespaces[p[0]] == null)  {
                el.setAttribute(p[0], v);
            } else {
                el.setAttributeNS(this.namespaces[p[0]], p[1], v);
            }
        },
        setToggleManager:function(tm) {
            this.toggleManager = tm;
        },
        debugEnabled:false,
        debug:function() {
            if (this.debugEnabled) console.log.apply(console, arguments);
        },
        maybeDebug:function() {
            if (this.debugEnabled && arguments[0])
                console.log.apply(console, arguments);
        },
        parse:function(str, templateResolver, extraProperties, parseStack) {
            parseStack = parseStack || [];
            templateResolver = _wrapCache(this, templateResolver || this.templateResolver, null);
            var stack = [],
                results = [],
                _rotors = this,
                _test = function(token, re) {
                    var m = token.match(re);
                    return (m == null) ? false : m;
                },
                _peek = function() {
                    return stack.length > 0 ? stack[stack.length - 1] : null;
                },
                _isBalanced = function(endTag) {
                    var p = _peek();
                    return p != null && p.tag == endTag;
                },
                _push = function(el, doNotSetCurrent) {
                    if (stack.length > 0) _peek().children.push(el);
                    if (!doNotSetCurrent)
                        stack.push(el); // push to stack, unless told not to
                    else if (stack.length == 0)
                        results.push(el); // if not pushing to stack and the stack is empty, must push to results or we'll lose this one.
                },
                _pushChild = function(el) {
                    _push(el, true);
                },
                _pop = function() {
                    var r = stack.pop();
                    if (stack.length === 0 && !r.discard){
                        results.push(r);
                    } else {
                        if (r.discard) {
                            // remove the entry (and therefore all its children) from the children of its parent.
                            var parent = stack.peek();
                            if (parent) parent.children.pop();
                        } 
                    }
                    return r;
                },
                _openElementHandler = function(t, m, templateResolver, _rotors, parseStack) {
                    var ee = new ElementEntry(t, _rotors), custom = _rotors.customElements[ee.tag];
                    if (custom) {
                        custom.parse(ee, m, templateResolver, _rotors, stack, parseStack);
                        if (custom.compile) ee.compile = custom.compile;
                        ee.precompile = custom.precompile;
                        ee.postcompile = custom.postcompile;
                        ee.custom = true;
                        ee.remove = custom.remove;
                        _rotors.debug("  element is a custom element");
                        _rotors.maybeDebug(ee.remove, "  element's root should not appear in output");
                    }
                    return ee;
                },
                tagHandlers = [
                    {
                        re:_rotors.commentRe,
                        handler:function(t, m, templateResolver, _rotors) {
                            _rotors.debug("comment", t, m);
                            _push(new CommentEntry(t), true);
                        }
                    },
                    {
                        re:_rotors.openRe,
                        handler:function(t, m, templateResolver, _rotors, parseStack) {
                            _rotors.debug("open element", t, m);
                            var ee = _openElementHandler(t, m, templateResolver, _rotors, parseStack);
                            _push(ee, ee.remove);
                        }
                    },
                    {
                        re:_rotors.closeRe,
                        handler:function(t, m, templateResolver, _rotors) {
                            _rotors.debug("close element", t, m);
                            var custom = _rotors.customElements[m[1]];
                            if (custom != null && custom.remove) return;
                            if (!_isBalanced(m[1])) {
                                throw new TypeError("Unbalanced closing tag '" + m[1] + "'; opening tag was '" + _pop().tag + "'");
                            }

                            else _pop();
                        }
                    },
                    {
                        re:_rotors.openCloseRe,
                        handler:function(t, m, templateResolver, _rotors, parseStack) {
                            _rotors.debug("open and close element", t, m);
                            var ee = _openElementHandler(t, m, templateResolver, _rotors, parseStack);
                            _push(ee, true);
                        }
                    },
                    {
                        re:/.*/,
                        handler:function(t, m, templateResolver, _rotors) {
                            _rotors.debug("text node", t);
                            var te = new TextEntry({ value: t }, _rotors);
                            _pushChild(te);
                            _addBinding("__element", t, te, null, _rotors);
                        }
                    }
                ];

            _eachNotEmpty(_trim(str).split(this.tokenizerRe), function(index, item) {
                var trimmed = _trim(item);
                for (var j = 0; j < tagHandlers.length; j++) {
                    //item = _trim(item);
                    var m = _test(trimmed, tagHandlers[j].re);
                    if (m) {
                        tagHandlers[j].handler(item, m, templateResolver, this, parseStack);
                        break;
                    }
                }
            }.bind(this));

            //if (results.length == 0)
            //  what to do? malformed, seemingly.

            if (results.length > 0 && extraProperties) {
                for (var prop in extraProperties)
                    results[0][prop] = extraProperties[prop];
            }

            return results;
        },
        /**
         * Generates a template Function from the given AST. The function returns a DocumentFragment when running in a browser,
         * and a Fakement - a DocumentFragment-like object - when not.  The AST you pass in to this method is returned from
         * a call to `Rotors.parse(string)`.
         */
        compile:function(ast, precompileOnly, functionBodyOnly, isCustomScope) {
            // create data stack, fragment (which in browser is a DocumentFragment and on the server a Fakement, a stack
            // for the current parent element, and a execution id, which is a globally unique id that will be in scope for
            // every function executed in this template, and can subsequently be used to retrieve all of the elements associated
            // with a particular execution of this template function,

            var fp = "data=[data||{}];var frag=_rotors.cf(),_els=[],e,_le,__a,$value,$key,_eid = _rotors.nec();_els.push(frag);",
                fs = "return frag;",
                items = [];

            for (var i = 0; i < ast.length; i++) {
                var content = "";
                if (ast[i].precompile) content += ast[i].precompile(this);
                content += ast[i].compile(this, isCustomScope);
                if (ast[i].postcompile) content += ast[i].postcompile(this);
                items.push(content);
            }

            var fb = items.join("");
            this.debug("function body :", fb);
            if (functionBodyOnly)
                return fb;

            var f = new Function("data,_rotors", fp + fb + fs), _r = this;
            if (!precompileOnly) {
                var cf = function (data) {
                    return f.apply(this, [data, _r]);
                };
                cf.functionBody = fb;
                return cf;
            }
            else {
                return f;
            }
        },
        // newExecutionContext
        nec:function() {
            var _eid = this.uuid();
            this.executions[_eid]={ current:[ {children:[]} ] };
            return _eid;
        },
        //traceExecution
        te:function(el, eid, entryId, loopIndex) {
            var __ec={el:el, children:[], id:entryId, index:loopIndex};
            this.executions[eid].current[0].children.push(__ec);
            var key = entryId + (loopIndex != null ? "-" + loopIndex : "");
            this.executions[eid][key]=__ec;
            this.executions[eid].current.unshift(__ec);
        },
        //popExecutionTrace
        pet:function(eid, current) {
            this.executions[eid].current = this.executions[eid].current.splice(1);
        },
        getExecutionContent:function(content, uuid, isTextNode, namespace, _rotors) {
            var p = namespace != null ? this.namespaceHandlers[namespace](content) : (isTextNode ? "e=_rotors.ctn(" + content + ");" : "e=_rotors.ce('" + content + "');");
            return p + "_els.peek().appendChild(e);" +
                (isTextNode ? "" : "_els.push(e);") +
                "e._rotors=_rotors.entries['" + uuid + "'];" +
                "e._rotorsEid=_eid;" +
                "if(typeof _rotorsLoopId !== 'undefined') {e._rotorsLoopId=_rotorsLoopId;e._rotorsLoopIndex=_rotorsLoopIndex;e._rotorsLoopContext=_rotorsLoopContext;}" +
                "_rotors.te(e, _eid, '" + uuid + "', typeof _rotorsLoopIndex != 'undefined' ? _rotorsLoopIndex : null);";
        },
        updaters:{},
        /**
         * Register a callback for when the given element is updated. A uuid is written onto the element and the update
         * entries check for its existence in their reapply methods.
         * @param el
         * @param fn
         */
        onUpdate:function(el, fn) {
            if (el._rotors == null) return;
            var _rotors = el._rotors.instance;
            el._RotorsUpdate = el._RotorsUpdate || _uuid();
            _rotors.updaters[el._RotorsUpdate] = _rotors.updaters[el._RotorsUpdate] || [];
            _rotors.updaters[el._RotorsUpdate].push(fn);
        },
        /**
         * Updates an element with the given data. If the element was not rendered by Rotors, the method exits silently.
         * This method will traverse down into child elements and apply the data given using the same context rules
         * specified in your template.  Alternatively, if you just want to update a single element (say one LI from a UL,
         * for example), then you can supply just that one element, and of course a data object that is appropriate for what
         * context that element expects.
         * @param {Element} el DOM node to update.
         * @param {Object} data Data to update the DOM node with.
         */
        update:function(el, data) {
            var elsToUpdate = [];
            // Get the execution id, that is the ID of the particular invocation of the template function that
            // resulted in this element being created.  If it does not exist - or if, for some reason, the binding data is
            // not on this element, return.
            var eid = el._rotorsEid, executionContext, rootEntry, _rotors;
            if (eid == null || el._rotors == null) return;
            // otherwise, retrieve the context and get the entry for this specific element.
            else {
                _rotors = el._rotors.instance;
                executionContext = _rotors.executions[eid];
                var idx = el._rotorsLoopIndex, key = el._rotors.uuid + (idx != null ? "-" + idx : "");
                rootEntry = executionContext[key];
            }

            var _one = function(el, d, entry) {
                if (el != null) {
                    // update the element itself
                    el._rotors.update(el, d);
                    if (el._RotorsUpdate && _rotors.updaters[el._RotorsUpdate]) {
                        elsToUpdate.push([el, _rotors.updaters[el._RotorsUpdate], d]);
                    }
                }

                // iterate the children
                for (var i = 0; i < entry.children.length; i++) {
                    var childEntry = _rotors.entries[entry.children[i].id],
                        isLoop = _rotors.entries[entry.id].type === "each";

                    var childData = (isLoop && entry.children[i].el != null && entry.children[i].el._rotorsLoopIndex != null) ?
                        d[entry.children[i].el._rotorsLoopIndex] :
                        _rotors.data(d, childEntry.context);

                    _one(entry.children[i].el, childData, entry.children[i]);
                }
            };

            _one(el, data, rootEntry);

            for (var i = 0; i < elsToUpdate.length; i++) {
                var entry = elsToUpdate[i];
                for (var j = 0; j < entry[1].length; j++) {
                    try {
                        entry[1][j](entry[0], entry[2]);
                    }
                    catch (e) {
                    }
                }
            }
        },
        updateExternal:function(el, data) {
            data = data || {};
            var a, path, att;
            var _one = function(_el) {
                if (_el.nodeType === Node.ELEMENT_NODE) {
                    for (var i = 0, j = _el.attributes.length; i < j; i++) {
                        a = _el.attributes[i];
                        if (a.name === "rotors") {
                            path = a.value;
                            _el.innerHTML = _data(data, path);
                        }
                        else if (a.name.indexOf("rotors-") === 0) {
                            path = a.value;
                            att = a.name.substring(7);
                            _el.setAttribute(att, _data(data, path));
                        }
                    }
                    for (i = 0; i < _el.childNodes.length; i++) {
                        _one(_el.childNodes[i]);
                    }
                }
            };

            _one(el);
//            // first get all `rotors-path` elements (these are elements whose inner html can be replaced with a value)
//            var textNodeReplacements = el.querySelectorAll("[rotors-path]");
//            for (var i = 0; i < )
        },
        /**
         * Cleans up any references to the given element in this instance's caches.
         * @param el
         */
        remove : function(el) {
            if (el._RotorsUpdate && this.updaters[el._RotorsUpdate]) {
                delete this.updaters[el._RotorsUpdate];
            }

            if (el._rotorsEid && this.executions[el._rotorsEid])
                delete this.executions[el._rotorsEid];
        },
        /**
         * Renders a template with the given id with the given data. Optionally, you can supply a template resolver
         * to this method. If you do not provide one, Rotors will use the default mechanism for looking up templates,
         * which is, in a browser, to get a DOM node with the given ID and return its innerHTML, and on the server the
         * behaviour is as-yet undefined.
         * @param {String} id ID of the template to compile.
         * @param {Object} [data] Data for the compilation. Optional, but it's pretty certain you'll want to provide this most of the time...
         * @param {Function} [templateResolver] Optional function that takes an ID and returns the content of a template.
         * @returns {DocumentFragment|Fakement|Element} A DocumentFragment when running in a modern browser, or a Fakement - which behaves a lot like a DocumentFragment - when running on the server, or an element when running in IE8 or below. For this reason, if you want to use Rotors with IE8, you must ensure that your templates have a single root node.
         */
        template:function(id, data, templateResolver, forceReload) {
            var r;
            var cachedTemplate = !forceReload ? this.templateCache[id] : null;
            if (cachedTemplate != null) {
                r = cachedTemplate(data);
                return this.isOldIE() ? r.childNodes[0] : r;
            }
            else {
                templateResolver = _wrapCache(this, templateResolver || this.templateResolver, forceReload);
                var content = templateResolver(id);
                if (content != null) {
                    var p = this.parse(content, templateResolver, null, [id]),
                        c = this.compile(p);

                    this.templateCache[id] = c;

                    r = c(data);
                    return this.isOldIE() ? r.childNodes[0] : r;
                }
                else {
                    return this.cf();
                }
            }
        },
        /**
         * Precompile the given content into a template function, for later import by some Rotors instance.
         * @param {String} content Template content.
         * @param {Function} [templateResolver] Optional resolver to use for templates referenced by this one.
         * @returns {Function} A template function. This function expects two arguments: some data, and a Rotors instance to execute against.
         */
        precompileTemplate:function(content, templateResolver) {
            var p = this.parse(content, templateResolver || this.templateResolver);
            return this.compile(p, true);
        },
        /**
         * Precompile the given map of [id->content] pairs into a set of template functions, for later import by some Rotors instance.
         * @param {Object} data id->content pairs for templates to precompile.
         * @param {Function} [templateResolver] Optional resolver to use for templates referenced by this one.
         * @returns {Object} A map of id->functions, one for each precompiled template.
         */
        precompileTemplates:function(data, templateResolver) {
            // create a template resolver that first looks in the data given to this method and then hands
            // off to the underlying resolver if content not found.
            var tr = function(tId) {
                    var t = data[tId];
                    return t || (templateResolver || this.templateResolver)(tId);
                },
                out = {};
            for (var id in data) {
                out[id] = this.precompileTemplate(data[id], tr);
            }
            return out;
        },
        /**
         * Import the given template function and store it against the given id.
         * @method importTemplate
         * @param {String} id ID to store for later retrieval of the template
         * @param {Function} fn A template function that was created by the `precompileTemplate` or `precompileTemplates` method of an instance of Rotors.
         */
        importTemplate:function(id, fn) {
            var r = this;
            fn = typeof fn === "string" ? Function("data", "_rotors", fn) : fn;
            this.templateCache[id] = function(d) {
                return fn.apply(r, [d, r]);
            };
        },
        /**
         * Import the given map of [id->template] pairs and store them in the cache.
         * @method importTemplates
         * @param {Object} data A map of [id->function] pairs, each of which will be passed as the arguments to a call to `importTemplate`.
         */
        importTemplates:function(data) {
            for (var id in data) {
                this.importTemplate(id, data[id]);
            }
        },

        importBindings:function(bindings) {
            this.bindings = this.bindings || {};
            for (var b in bindings) {
                var _b = bindings[b];
                this.bindings[b] = {
                    e: _b.e,
                    u: _b.u,
                    w: _b.w,
                    reapply: Function("$data", _b.reapply)
                };
            }
        }
    });

    /* ---------------------------- browser vs server expose --------------------------------------------------------- */

    var newInstance = function (params) {
        return new RotorsInstance(params);
    };

    var exportBindings = function(rotors) {
        var o = {};
        for (var b in rotors.bindings) {
            var _b = rotors.bindings[b];
            o[b] = {
                e:_b.e,
                u:_b.u,
                w:_b.w,
                reapply:String(_b.reapply).replace(/^function\s*\S+\s*\([^)]*\)\s*\{|\}$/g, "")
            };
        }
        return o;
    };

    /**
     * Scans the given input for templates in the form
     * <script type="rotors" id="someId">...</script>
     * and output an array containing a map of template Ids -> template functions as the first argument, plus the
     * input text stripped of templates as the second argument. **NOTE** the `type` attribute must be specified
     * before the `id` attribute in the HTML.
     * @method precompile
     * @param {String} html HTML to preprocess.
     * @param {String} [type='rotors'] Optional `type` of scripts used as templates. Defaults to "rotors".
     * @returns {Object[]} an array containing a map of template Ids -> template functions as the first argument, plus the
     * input text stripped of templates as the second argument.
     */
    var precompile = function(html, type) {
        type = type || "rotors";
        var rotors = root.Rotors.newInstance();
        var filteredInput, foundTemplates = {};
        var regex = new RegExp("\<script type=['\"]" + type + "['\"] id=['\"]([^'\"]+)['\"]>((.*\n)*?)\<\/script\>", "g");
        filteredInput = html.replace(regex, function(_, templateId, templateBody) {
            foundTemplates[templateId] = templateBody ;
            return "";
        });
        var output = [ {}, null, filteredInput ];

        for (var t in foundTemplates) {
            output[0][t] = String(rotors.precompileTemplate(foundTemplates[t], function(id) { return foundTemplates[id]})).replace(/^function\s*\S+\s*\([^)]*\)\s*\{|\}$/g, "") ;
        }

        output[1] = exportBindings(rotors);

        return output;
    };

    /**
     * Gets a new instance of Rotors.
     * @method newInstance
     * @static
     * @param {Object} [params] Optional set of constructor parameters for the new instance.
     * @returns {RotorsInstance}
     */
    var Rotors = root.Rotors = {
        newInstance: newInstance,
        precompile:precompile,
        data:_data,
        version:"0.3.15"
    };

    if (typeof exports !== "undefined") {
        exports.Rotors = Rotors;
        exports.RotorsInstance = RotorsInstance;
    }

}).call(typeof window !== 'undefined' ? window : this);
/*
 * anim
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 * Utility functions that run only in browsers, and are not included in a headless environment build.
 *
 */
;
(function () {

    var root = this;
    root.jsPlumbToolkitUtil = root.jsPlumbToolkitUtil || { };
    var exports = root.jsPlumbToolkitUtil;

    var __bind = function (fn, me) {
        return function () {
            return fn.apply(me, arguments);
        };
    };

    var requestAnimationFrame = exports.requestAnimationFrame = __bind(root.requestAnimationFrame ||
        root.webkitRequestAnimationFrame ||
        root.mozRequestAnimationFrame ||
        root.oRequestAnimationFrame ||
        root.msRequestAnimationFrame ||
        function (callback, element) {
            root.setTimeout(callback, 10);
        }, root);


    /**
     * Execute an ajax call.
     * @method jsPlumbToolkitUtil.ajax
     * @param {Object} params
     * @param {String} [params.type="get"] HTTP operation.
     * @param {String} [params.dataType] Expected datatype of response.
     * @param {String} params.url URL to connect to.
     * @param {Function} params.success Function to call on success, with received data. Success is deemed to be any status code in the 2XX range.
     * @param {Function} [params.error] Optional function to call on error. Will be given the response text and the status code as arguments.
     * @param {Object} [params.data] Optional data payload.
     * @param {Object} [params.headers] Optional map of HTTP header values.
     */
    exports.ajax = function (params) {
        var req = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
        var verb = params.type || "GET";
        if (req) {
            var responder = params.dataType === "json" ? function (d) {
                return JSON.parse(d);
            } : function (d) {
                return d;
            };
            req.open(verb, params.url, true);
            var headers = params.headers || {};
            for (var h in headers) {
                req.setRequestHeader(h, headers[h]);
            }
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (("" + req.status)[0] === "2")
                        params.success(responder(req.responseText));
                    else
                        params.error && params.error(req.responseText, req.status);
                }
            };
            req.send(params.data ? JSON.stringify(params.data) : null);
        }
        else
            params.error && params.error("ajax not supported");
    };

    /**
     * Generates a debounce helper for the given function, with the given timeout. The given function will be called only
     * when a period of length `timeout` has elapsed since the last call to the debounce function. Use this for stuff like
     * relayout of your UI when the window is resized, or firing an ajax call after a series of checkboxes have been
     * selected or deselected.
     * @method jsPlumbToolkitUtil.debounce
     * @param {Function} fn Function to fire
     * @param {Number} [timeout=150] Timeout, in milliseconds. Default is 150.
     * @returns {Function} a function with debouncing built in.
     */
    exports.debounce = function(fn, timeout) {
        timeout = timeout || 150;
        var _t = null;
        return function() {
            window.clearTimeout(_t);
            _t = window.setTimeout(fn, timeout);
        };
    };

    exports.xml = {
        /**
         * Sets a node's text value.
         * @method jsPlumbToolkitUtil.xml.setNodeText
         * @param {Element} node Element to set text on.
         * @param {String} text Text to set.
         */
        setNodeText: function (node, text) {
            node.text = text;  // IE
            try {
                node.textContent = text;
            }
            catch (e) {
            }
        },
        /**
         * Gets text from the given node.
         * @method jsPlumbToolkitUtil.xml.getNodeText
         * @param {Element} node XML element.
         */
        getNodeText: function (node) {
            return node != null ? node.text || node.textContent : "";
        },
        /**
         * Gets the first instance of the child with the given tag name, null if none found.
         * @method jsPlumbToolkitUtil.xml.getChild
         * @param {Element} parent Element to retrieve child from.
         * @param {String} name Child tag name to retrieve.
         */
        getChild: function (parent, name) {
            var c = null;
            for (var i = 0; i < parent.childNodes.length; i++) {
                if (parent.childNodes[i].nodeType == 1 && parent.childNodes[i].nodeName == name) {
                    c = parent.childNodes[i];
                    break;
                }
            }
            return c;
        },
        /**
         * Gets children of the given node (only direct children), returning an array of nodes (an empty array if none found).
         * @method jsPlumbToolkitUtil.xml.getChildren
         * @param {Element} parent Element to retrieve children from.
         * @param {String} name Child tag names to retrieve.
         */
        getChildren: function (parent, name) {
            var c = [];
            for (var i = 0; i < parent.childNodes.length; i++) {
                if (parent.childNodes[i].nodeType == 1 && parent.childNodes[i].nodeName == name) {
                    c.push(parent.childNodes[i]);
                }
            }
            return c;
        },
        /**
         * Serializes the given XML node to a string, throwing an Error if something goes bad.
         * @method jsPlumbToolkitUtil.xml.xmlToString
         * @param {Element} xmlNode XML element to serialize.
         * @return {String} Serialized XML element.
         */
        xmlToString: function (xmlNode) {
            try {
                // Gecko-based browsers, Safari, Opera.
                return (new XMLSerializer()).serializeToString(xmlNode).replace(/\s*xmlns=\"http\:\/\/www.w3.org\/1999\/xhtml\"/g, "");
            }
            catch (e) {
                try {
                    // Internet Explorer.
                    return xmlNode.xml;
                }
                catch (ee) {
                    throw new Error("Cannot serialize XML " + ee);
                }
            }
            return false;
        },
        /**
         * Creates an XML element.
         * @method jsPlumbToolkitUtil.xml.createElement
         * @param {String} name Tag name of the element to create.
         * @param {Object} [attributes] Optional map of attribute names and values.
         * @param {String} [text] Optional text for the element.
         * @return {Element} An XML element.
         */
        createElement: function (name, attributes, text) {
            var n;
            //http://www.devguru.com/technologies/xmldom/quickref/document_createnode.html
            try {
                n = new ActiveXObject("Microsoft.XMLDOM").createNode(1, name, "");
            }
            catch (e) {
                n = document.createElement(name);
            }

            if (text) jsPlumbToolkitUtil.xml.setNodeText(n, text);
            if (attributes) {
                for (var i in attributes)
                    n.setAttribute(i, attributes[i]);
            }

            return n;
        }
    };

}).call(typeof window !== 'undefined' ? window : this);

/**
 * Util
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
/**
 *
 * jsPlumbToolkit utility functions, used both in browser and on server.
 *
 * Dependencies
 *
 * jsPlumbUtil (does this depend on browser at all? it shouldnt.)
 */

;
(function () {

    "use strict";

    var root = this;
    root.jsPlumbToolkitUtil = root.jsPlumbToolkitUtil || { };
    var UTIL = root.jsPlumbToolkitUtil;
    var JUTIL = root.jsPlumbUtil;

    UTIL.fastTrim = function (s) {
        var str = s.replace(/^\s\s*/, ''),
            ws = /\s/,
            i = str.length;
        while (ws.test(str.charAt(--i)));
        return str.slice(0, i + 1);
    };

    UTIL.uuid = function () {
        return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        }));
    };

    UTIL.each = function(obj, fn) {
        obj = obj.length == null || typeof obj === "string" ? [ obj ] : obj;
        for (var i = 0; i < obj.length; i++) {
            fn(obj[i]);
        }
    };

    // take the given model and expand out any parameters.
    UTIL.populate = function (model, values) {
        // for a string, see if it has parameter matches, and if so, try to make the substitutions.
        var getValue = function (fromString) {
                var matches = fromString.match(/(\${.*?})/g);
                if (matches != null) {
                    for (var i = 0; i < matches.length; i++) {
                        var val = values[matches[i].substring(2, matches[i].length - 1)];
                        if (val) {
                            fromString = fromString.replace(matches[i], val);
                        }
                    }
                }
                return fromString;
            },
        // process one entry.
            _one = function (d) {
                if (d != null) {
                    if (JUTIL.isString(d)) {
                        return getValue(d);
                    }
                    else if (JUTIL.isArray(d)) {
                        var r = [];
                        for (var i = 0; i < d.length; i++)
                            r.push(_one(d[i]));
                        return r;
                    }
                    else if (JUTIL.isObject(d)) {
                        var r = {};
                        for (var i in d) {
                            r[i] = _one(d[i]);
                        }
                        return r;
                    }
                    else {
                        return d;
                    }
                }
            };

        return _one(model);
    };

    UTIL.mergeWithParents = function (type, map, parentAttribute) {

        parentAttribute = parentAttribute || "parent";
        var _def = function (id) {
            return id ? map[id] : null;
        };
        var _parent = function (def) {
            return def ? _def(def[parentAttribute]) : null;
        };

        var _one = function (parent, def) {
            if (parent == null) return def;
            else {
                var d = JUTIL.merge(parent, def);
                return _one(_parent(parent), d);
            }
        };

        var _getDef = function (t) {
            if (t == null) return {};
            if (typeof t == "string") return _def(t);
            else if (t.length) {
                var done = false, i = 0, _dd;
                while (!done && i < t.length) {
                    _dd = _getDef(t[i]);
                    if (_dd) {
                        done = true;
                    }
                    else
                        i++;
                }
                return _dd;
            }
        };

        var d = _getDef(type);
        if (d)
            return _one(_parent(d), d);
        else
            return {};
    };

    if (typeof exports !== "undefined") {
        exports.jsPlumbToolkitUtil = UTIL;
    }

}).call(typeof window !== 'undefined' ? window : this);

/*
 * anim
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 * This file contains code for working with animations.
 *
 * Namespace: jsPlumbToolkit
 *
 * Dependencies:
 *
 * jsPlumbToolkit
 * jsPlumbUtil
 */
;(function() {

    var root = this,
        _jp = root.jsPlumb,
        _ju = root.jsPlumbUtil;

    var events = {
        nodeTraverseStart:"startNodeTraversal",
        nodeTraverseEnd:"endNodeTraversal",
        start:"startOverlayAnimation",
        end:"endOverlayAnimation"
    };

    var classes = {
        nodeTraversing:"jtk-animate-node-traversing",
        edgeTraversing:"jtk-animate-edge-traversing",
        nodeTraversable:"jtk-animate-node-traversable",
        edgeTraversable:"jtk-animate-edge-traversable"
    };

    /**
     * Traces the given overlay along the Connection.
     * @param {String|Object} overlaySpec This is in the format accepted by the Community edition of jsPlumb.
     * @param {Object} [options] for animation.
     * @param {Boolean} [options.forwards=true] Whether to traverse from source-> target, or target->source.
     * @param {Number} [options.dwell=250] How long, in milliseconds, to dwell on each node as the overlay traverses the path.
     * @param {Number} [options.speed=100] How many pixels per second to travel. *Note*: this is in seconds, not milliseconds.
     * @param {Number} [options.rate=30] Frame rate, in milliseconds.
     * @returns {boolean}
     */
    _jp.Connection.prototype.animateOverlay = function(overlaySpec, options) {

        var self = this;
        var handle = new _ju.EventGenerator();

        var length = self.getConnector().getLength();

        options = options || {};
        var id = _ju.uuid();

        var forwards = options.forwards !== false,
            rate = options.rate || 30, // ms
            dwell = options.dwell || 250,
            speed = options.speed || 100, // pixels per second.
        // how long will the animation last? it's the length divided by the
        // pixels per second. here note we convert from seconds to milliseconds.
        // the 'speed' member is given in seconds.
            duration = length / speed * 1000,
        // recompute frame count
            frames = duration / rate,
        // recompute distance per frame
            perFrame = (1 / frames) * (forwards ? 1 : -1),
            isFinal = options.isFinal !== false,
            startLocation = forwards ? 0 : 1,
            finished = function() {
                return forwards ? current >= 1 : current <= 0;
            },
            startNode = forwards ? self.source : self.target,
            endNode = forwards ? self.target : self.source,
            current = startLocation, timer, overlay,
            tick = function() {
                current += perFrame;
                if (finished()) stop();
                else {
                    overlay.loc = current;
                    self.repaint();
                }
            },
            spec;

        if (typeof overlaySpec === "string") {
            spec = [ overlaySpec, { location:startLocation, id:id }];
        } else {
            var os = _jp.extend({}, overlaySpec[1]);
            os.location = startLocation;
            os.id = id;

            spec = [ overlaySpec[0], os ];
        }

        var startTraversal = function() {
            handle.fire(events.start, self);
            overlay = self.addOverlay(spec);
            timer = window.setInterval(tick, rate);
        };

        var start = function() {
            handle.fire(events.nodeTraverseStart, {connection:self, element:startNode});
            _jp.addClass(startNode, classes.nodeTraversing);
            self.addClass(classes.edgeTraversing);
            window.setTimeout(function() {
                _jp.removeClass(startNode, classes.nodeTraversing);
                handle.fire(events.nodeTraverseEnd, {connection:self, element:startNode});
                startTraversal();
            }, dwell);
        };

        var stop = function() {
            self.removeOverlay(id);
            window.clearInterval(timer);
            if (isFinal) {
                _jp.addClass(endNode, classes.nodeTraversing);
                window.setTimeout(function() {
                    _jp.removeClass(endNode, classes.nodeTraversing);
                    self.removeClass(classes.edgeTraversing);
                    handle.fire(events.end, self);
                }, dwell);
            }
            else {
                self.removeClass(classes.edgeTraversing);
                handle.fire(events.end, self);
            }

        };

        if (options.previous) {
            options.previous.bind(events.end, start);
        }
        else {
            start();
        }

        return handle;
    };
}).call(typeof window === "undefined" ? this : window);
/*
 * AutoSaver
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 */
;
(function () {

    "use strict";

    var root = this;

    var prefixes = [ "node", "port", "edge", "group" ],
        suffixes = [ "Refreshed", "Added", "Removed", "Updated", "Moved" ],
        p2 = [ "edge" ], s2 = [ "Source", "Target" ];

    var _bind = function(p, s, instance, fn) {
        for (var i = 0; i < p.length; i++) {
            for (var j = 0; j < s.length; j++) {
                instance.bind(p[i] + s[j], fn);
            }
        }
    };

    root.jsPlumbToolkitUtil.AutoSaver = function (instance, url, headers, success, error, onBeforeAutoSave, onAfterAutoSave) {

        function _afterBind(fn) {
            return function() {
                fn && fn.apply(fn, arguments);
                onAfterAutoSave && onAfterAutoSave();
            };
        }

        var _suspended = false;
        var _save = function () {
            if (!_suspended) {

                try { onBeforeAutoSave && onBeforeAutoSave(); }
                catch (e) {}

                instance.save({
                    url: url,
                    success: _afterBind(success),
                    error: _afterBind(error),
                    headers:headers
                });
            }
        };

        instance.bind("dataLoadStart", function() {
            _suspended = true;
        });
        instance.bind("dataLoadEnd", function() {
            _suspended = false;
        });

        _bind(prefixes, suffixes, instance, _save);
        _bind(p2, s2, instance, _save);
    };

    root.jsPlumbToolkitUtil.CatchAllEventHandler = function (instance) {
        var _f = function () {
            instance.fire("dataUpdated");
        };

        _bind(prefixes, suffixes, instance, _f);
        _bind(p2, s2, instance, _f);
    };

}).call(typeof window !== 'undefined' ? window : this);

/*
 * Selection
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */

/**
 * Models a selection of Nodes/Ports end Edges.
 */
;
(function () {

    var root = this;
    var exports = root.jsPlumbToolkitUtil;
    var JUTIL = root.jsPlumbUtil;


    /**
     * @class Selection
     * @constructor
     * @param {Object} params Constructor params
     * @param {jsPlumbToolkitInstance} params.toolkit jsPlumb Toolkit instance to which this Selection belongs.
     * @param {Function} [params.generator] Optional function that can be called to fill the selection. You'd use this
     * when you are rendering individual selections and you need to be able to refresh the whole view based on some
     * change in the data model.
     * @param {Function} [params.onClear] Optional function to call when the selection is cleared.
     */
    exports.Selection = function (params) {

        JUTIL.EventGenerator.apply(this, arguments);

        var toolkit = params.toolkit,
            _nodes = [],
            _groups = [],
            _edges = [],
            maxNodes = Math.Infinity,
            maxEdges = Math.Infinity,
            maxGroups = Math.Infinity,
            capacityPolicy,
            generator = params.generator,
            _objMap = {},
            self = this,
            _onClear = params.onClear || function () { },
            _getList = function (obj) {
                return obj.objectType === "Edge" ? _edges : obj.objectType === "Node" ? _nodes : _groups;
            },
            _pushToList = function(obj) {
                var deselected = [];
                var list = _getList(obj), _max = obj.objectType === "Edge" ? maxEdges : obj.objectType === "Node" ? maxNodes : maxGroups;
                if (list.length >= _max) {
                    if (capacityPolicy === exports.Selection.DISCARD_NEW) {
                        return false;
                    }
                    else {
                        deselected = list.splice(0, 1);
                        _fireListEvent(deselected[0], "Removed");
                        delete _objMap[deselected[0].getFullId()];
                    }
                }
                list.push(obj);
                _fireListEvent(obj, "Added");
                return deselected;
            },
            _fireListEvent = function(obj, suffix) {
                var evt = obj.objectType.toLowerCase() + suffix,
                    payloads = {
                        "Group":{ data:obj.data, group:obj },
                        "Node":{ data:obj.data, node:obj },
                        "Port":{ data:obj.data, node:obj.node, port:obj },
                        "Edge":{ data:obj.data, edge:obj}
                    };
                self.fire(evt, payloads[obj.objectType]);
            };

        this.getModel = toolkit.getModel;
        this.setSuspendGraph = toolkit.setSuspendGraph;
        this.getNodeId = toolkit.getNodeId;
        this.getGroupId = toolkit.getNodeId;
        this.getEdgeId = toolkit.getEdgeId;
        this.getPortId = toolkit.getPortId;
        this.getNodeType = toolkit.getNodeType;
        this.getGroupType = toolkit.getNodeType;
        this.getEdgeType = toolkit.getEdgeType;
        this.getPortType = toolkit.getPortType;
        this.getObjectInfo = toolkit.getObjectInfo;
        this.isDebugEnabled = toolkit.isDebugEnabled;

        var _addOne = function (obj, evtPipe) {
                if (!_objMap[obj.getFullId()]) {
                    var result = _pushToList(obj);
                    if (result === false) {
                        return [ [], [] ];
                    }
                    else {
                        _objMap[obj.getFullId()] = obj;
                        if (evtPipe) evtPipe(obj, true);
                        return [ [obj], result ];
                    }
                }
                return [ [],  [] ];
            },
            _removeOne = function (obj, evtPipe) {
                var wasRemoved = JUTIL.removeWithFunction(_getList(obj), function (n) {
                    return n.id == obj.id;
                });
                if (wasRemoved) {
                    _fireListEvent(obj, "Removed");
                }
                delete _objMap[obj.getFullId()];
                if (evtPipe) evtPipe(obj, false);
                return [ [], [] ];
            },
            _toggle = function (obj, evtPipe) {
                if (_objMap[obj.getFullId()])
                    return _removeOne(obj, evtPipe);
                else
                    return _addOne(obj, evtPipe);
            },
            _makeSenseOf = function (o, fn, evtPipe) {
                var out = [], deselections = [], objects;
                if (o == null) return out;
                var _one = function (_o) {
                    var __o;
                    if (JUTIL.isString(_o)) {
                        __o = toolkit.getNode(_o) || toolkit.getEdge(_o) || toolkit.getGroup(_o);
                        if (__o != null) {
                            objects = fn(__o, evtPipe);
                            out.push.apply(out, objects[0]);
                            deselections.push.apply(deselections, objects[1]);
                        }
                    }
                    else if (_o.eachNode && _o.eachEdge ) {
                        _o.eachNode(function (i, e) {
                            _one(e);
                        });
                        _o.eachEdge(function (i, e) {
                            _one(e);
                        });
                        if (_o.eachGroup) {
                            _o.eachGroup(function (i, e) {
                                _one(e);
                            });
                        }
                    }
                    else if (_o.each) {
                        _o.each(function (i, e) {
                            _one(e.vertex || e);
                        });
                    }
                    else if (_o.length != null) {
                        for (var i = 0; i < _o.length; i++)
                            _one(_o[i], evtPipe);
                    }
                    else {
                        objects = fn(_o, evtPipe);
                        out.push.apply(out, objects[0]);
                        deselections.push.apply(deselections, objects[1]);
                    }
                };

                _one(o);

                return [out, deselections];

            }.bind(this);

        toolkit.bind("nodeRemoved", function (o) {
            _removeOne(o.node);
        });
        toolkit.bind("groupRemoved", function (o) {
            _removeOne(o.group);
        });
        toolkit.bind("portRemoved", function (o) {
            _removeOne(o.port);
        });
        toolkit.bind("edgeRemoved", function (o) {
            _removeOne(o.edge);
        });
        toolkit.bind("edgeTarget", function(o) {
           if (_objMap[o.edge.getFullId()]) {
               self.fire("edgeTarget", o);
           }
        });
        toolkit.bind("edgeSource", function(o) {
            if (_objMap[o.edge.getFullId()]) {
                self.fire("edgeSource", o);
            }
        });

        toolkit.bind("nodeUpdated", function(p) {
            if (_objMap[p.node.getFullId()]) self.fire("nodeUpdated", p);
        });

        toolkit.bind("groupUpdated", function(p) {
            if (_objMap[p.group.getFullId()]) self.fire("groupUpdated", p);
        });

        toolkit.bind("edgeUpdated", function(p) {
            if (_objMap[p.edge.getFullId()]) self.fire("edgeUpdated", p);
        });

        toolkit.bind("portUpdated", function(p) {
            if (_objMap[p.port.getFullId()]) self.fire("portUpdated", p);
        });

        /**
         * Removes the given object from the selection.
         * @method remove
         * @param {Node|Edge|Node[]|Edge[]|Path} obj Object(s) to remove. May take many forms - a Node, Node Id, or Edge, or a list of these,
         * or a Path.
         */
        this.remove = function (obj, evtPipe) {
            return _makeSenseOf(obj, _removeOne, evtPipe);
        };

        /**
         * Appends the given object to the selection.
         * @method append
         * @param {Node|Edge|Node[]|Edge[]|Path} obj Object(s) to add. May take many forms - a Node, Node Id, or Edge, or a list of these,
         * or a Path.
         */
        this.append = function (obj, evtPipe) {
            return _makeSenseOf(obj, _addOne, evtPipe);
        };

        /**
         * Toggles the given object's membership in the current selection. If `obj` is a Path, then the individual
         * members of the Path are toggled independently.
         * @method toggle
         * @param {Node|Edge|Node[]|Edge[]|Path} obj Object(s) to add. May take many forms - a Node, Node Id, or Edge, or a list of these,
         * or a Path.
         */
        this.toggle = function (obj, evtPipe) {
            return _makeSenseOf(obj, _toggle, evtPipe);
        };

        /**
         * Sets the maximum number of nodes the selection can hold. The action taken when appending a node that would
         * take the selection above its limit depends on the current `capacityPolicy`, which can be either
         * Selection.DISCARD_EXISTING (the default) or Selection.DISCARD_NEW.
         * @method setMaxNodes
         * @param {Integer} _maxNodes
         */
        this.setMaxNodes = function(_maxNodes) {
            maxNodes = _maxNodes;
        };

        /**
         * Sets the maximum number of edges the selection can hold. The action taken when appending an edge that would
         * take the selection above its limit depends on the current `capacityPolicy`, which can be either
         * Selection.DISCARD_EXISTING (the default) or Selection.DISCARD_NEW.
         * @method setMaxEdges
         * @param {Integer} _maxEdges
         */
        this.setMaxEdges = function(_maxEdges) {
            maxEdges = _maxEdges;
        };

        /**
         * Sets the action taken when appending an edge or node that would
         * take the selection above its limit for that given type. Depends on the current `capacityPolicy`,
         * which can be either `jsPlumbToolkitUtil.Selection.DISCARD_EXISTING` (the default) or `jsPlumbToolkitUtil.Selection.DISCARD_NEW`.
         * @method setCapacityPolicy
         * @param {String} policy One of `jsPlumbToolkitUtil.Selection.DISCARD_EXISTING` (which removes the 0th entry from the list
         * before insertion of the new value) or `jsPlumbToolkitUtil.Selection.DISCARD_NEW`.
         */
        this.setCapacityPolicy = function(policy) {
            capacityPolicy = policy;
        };

        /**
         * Clears this selection.
         * @method clear
         */
        this.clear = function (doNotFireEvent) {
            _nodes.length = 0;
            _edges.length = 0;
            _groups.length = 0;
            _objMap = {};
            if (!doNotFireEvent) _onClear(this);
        };

        /**
         * Reloads the content of this Selection, if a `generator` was supplied to the constructor. Otherwise
         * does nothing. A data load start event is fired first, followed by a call to the generator to repopulate,
         * and then a data load end event is fired.  So calling this method on a Selection that you are rendering
         * to a Surface will cause the Surface to repaint itself.
         * @method reload
         */
        this.reload = function() {
            if (generator != null) {
                this.clear();
                var i;
                this.fire("dataLoadStart");
                generator(this, toolkit);
                for (i = 0; i < _groups.length; i++) {
                    self.fire("groupAdded", _groups[i]);
                }
                for (i = 0; i < _nodes.length; i++) {
                    self.fire("nodeAdded", _nodes[i]);
                }
                for (i = 0; i < _edges.length; i++) {
                    self.fire("edgeAdded", _edges[i]);
                }

                this.fire("dataLoadEnd");
            }
        };

        /**
         * Iterates the objects of the given type in the selection, calling the supplied callback
         * for each item. The callback's signature should be `function(index, item)`. If you don't supply
         * `type`, the default of "Node" will be used.
         * @method each
         * @param {Function} fn Function to call with each item.
         * @param {String} [type="Node"]
         */
        this.each = function (fn, type) {
            var list = type === "Edge" ? _edges : type === "Group" ? _groups : _nodes;
            for (var i = 0; i < list.length; i++) {
                try {
                    fn(i, list[i]);
                }
                catch (e) {
                    JUTIL.log("Selection iterator function failed", e);
                }
            }
        };

        /**
         * Iterates the Nodes in the selection, calling the supplied callback
         * for each item. The callback's signature should be `function(index, item)`.
         * @method eachNode
         * @param {Function} fn Function to call with each item.
         */
        this.eachNode = this.each;


        /**
         * Iterates the Groups in the selection, calling the supplied callback
         * for each item. The callback's signature should be `function(index, item)`.
         * @method eachGroup
         * @param {Function} fn Function to call with each item.
         */
        this.eachGroup = function(fn) { this.each(fn, "Group"); };

        /**
         * Iterates the Nodes and the Groups in the selection, calling the supplied callback
         * for each item. The callback's signature should be `function(index, item)`.
         * @method eachGroup
         * @param {Function} fn Function to call with each item.
         */
        this.eachNodeOrGroup = function(fn) {
            this.each(fn, "Node");
            this.each(fn, "Group");
        };

        /**
         * Iterates the Edges in the selection, calling the supplied callback
         * for each item. The callback's signature should be `function(index, item)`.
         * @method each
         * @param {Function} fn Function to call with each item.
         */
        this.eachEdge = function (fn) {
            this.each(fn, "Edge");
        };

        /**
         * Get the current number of Nodes in the selection.
         * @method getNodeCount
         * @return {Number}
         */
        this.getNodeCount = function () {
            return _nodes.length;
        };

        /**
         * Gets the node at the given index.
         * @method getNodeAt
         * @param idx Index of the Node to retrieve. Will return null if index out of range.
         * @returns {Node} A Node, or null.
         */
        this.getNodeAt = function(idx) {
            return _nodes[idx];
        };

        /**
         * Gets all the Nodes in the Selection.
         * @method getNodes
         * @returns {Node[]}
         */
        this.getNodes = function() {
            return _nodes;
        };

        /**
         * Gets the Node with the given ID
         * @method getNode
         * @param {String} id ID of the Node to retrieve
         */
        this.getNode = toolkit.getNode;

        /**
         * Gets the Group at the given index.
         * @method getGroupAt
         * @param idx Index of the Gorup to retrieve. Will return null if index out of range.
         * @returns {Group} A Group, or null.
         */
        this.getGroupAt = function(idx) {
            return _groups[idx];
        };

        /**
         * Gets all the Groups in the Selection.
         * @method getGroups
         * @returns {Group[]}
         */
        this.getGroups = function() {
            return _groups;
        };

        /**
         * Gets the Group with the given ID
         * @method getGroup
         * @param {String} id ID of the Group to retrieve
         */
        this.getGroup = toolkit.getGroup;

        /**
         * Get the current number of Groups in the selection.
         * @method getGroupCount
         * @return {Number}
         */
        this.getGroupCount = function() {
            return _groups.length;
        };

        this.getAll = function() {
            var o = [];
            Array.prototype.push.apply(o, _nodes);
            Array.prototype.push.apply(o, _edges);
            Array.prototype.push.apply(o, _groups);
            return o;
        };

        /**
         * Gets all Edges for the given Node or Group.
         * @method getAllEdgesFor
         * @param {Node} node The Node to get Edges for.
         * @returns {Edge[]}
         */
        this.getAllEdgesFor = function(node) {
            // need to get all edges and then filter to see if they're in the current selection.
            var e = node.getAllEdges(), _ = [];
            for (var i = 0; i < e.length; i++) {
                if (_objMap[e[i].getId()] != null)
                    _.push(e[i]);
            }
            return _;
        };

        /**
         * Get the current number of Edges in the selection.
         * @method getEdgeCount
         * @return {Number}
         */
        this.getEdgeCount = function () {
            return _edges.length;
        };

        /**
         * Gets the Node/Port at the given index.
         * @method get
         * @param {Integer} idx Index of the Node/Port to retrieve.
         * @return {Object} Node/Port at the given index, null if nothing found at that index.
         */
        this.get = this.getNodeAt = function (idx) {
            return _nodes[idx];
        };

        /**
         * Gets the Edge at the given index.
         * @method getEdge
         * @param {Integer} idx Index of the Edge to retrieve.
         * @return {Object} Edge at the given index, null if nothing found at that index.
         */
        this.getEdge = this.getEdgeAt = function (idx) {
            return _edges[idx];
        };

        this.setCapacityPolicy(exports.Selection.DISCARD_EXISTING);
    };

    exports.Selection.DISCARD_EXISTING = "discardExisting";
    exports.Selection.DISCARD_NEW = "discardNew";


}).call(typeof window !== 'undefined' ? window : this);

/*
 * Graph
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 * This is a Javascript implementation of a Graph, containing either directed or undirected edges, from nodes that have a one to N
 * ports, with Djikstra and FloydWarshall shortest path algorithms.  Also offers several 'centrality' measurement functions.
 *
 */
;
(function () {

    "use strict";

    var root = this;
    var exports = root.jsPlumbGraph = {};

    exports.version = "0.1";
    exports.name = "jsPlumbGraph";

    var Base = function (data, graph) {
            var atts = {};
            this.setAttribute = function (key, value) {
                atts[key] = value;
            };
            this.getAttribute = function (key) {
                return atts[key];
            };
            var type = graph.getType(data || {});
            this.getType = function () {
                return type;
            };
            this.setType = function (t) {
                type = t;
            };
            this.graph = graph;
        },
        uuid = function () {
            return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            }));
        },
        _getId = function (data, idFunction, graph) {
            if (data == null) return uuid();
            else if (typeof data === 'string')
                return data;
            else {
                var idf = idFunction || graph.getIdFunction();
                return idf(data) || uuid();
            }
        },
        _getType = function (data) {
            return typeof data === 'string' ? { id: data } : data;
        },
        /**
         * This is a Node in the Graph. Each Node can have one or more Edges to any other Node; this Edge may be
         * directed.  A Node may also have zero or more Ports, which themselves may have one or more Edges to other Nodes
         * or to Ports on other Nodes.
         *
         * Every Node has an associated *indegree centrality* and *outdegree centrality*. These are measurements of the number
         * of links to and from the Node. Whenever an Edge is added or removed the indegree and outdegree centrality
         * values for the Node are recomputed. For further reading we suggest [Wikipedia](http://en.wikipedia.org/wiki/Centrality#Degree_centrality).
         *
         * You can instantiate a Node with any type of backing data you wish.  If you supply a String,
         * that value is assumed to be the Node's ID. If you supply a JSON object, an ID is extracted from that object,
         * either with the supplied `idFunction`, or, if that is null, by assuming that the ID exists in the JSON as the
         * `id` member.
         * @class Node
         * @constructor
         * @param {Object|String} [data] Optional data backing the node. This object can be of any type you like, but if you supply a String, that value will be assumed to be the Node's ID.
         * @param {Function} [idFunction] Optional function that can take a Node's data and return its ID. By default this looks for an `id` member in the backing data.
         * @param {Graph} graph Graph the Vertex belongs to.
         */
        Vertex = exports.Vertex = exports.Node = function (data, idFunction, graph) {
            Base.apply(this, [ data, graph ]);
            this.objectType = "Node";

            /**
             * The Node's id. A String.
             * @property id
             * @type {String}
             */
            this.id = _getId(data, idFunction, graph);

            /**
             * Data associated with the Node.
             * @property data
             * @type {Object}
             */
            this.data = _getType(data);

            /**
             * Gets the Node's id, which, for Nodes, is just the `id` property. This method is overridden by Ports.
             * @method getFullId
             * @return {String} Node's id.
             */
            this.getFullId = function () {
                return this.id;
            };

            var edges = [],
                indegreeCentrality = 0,
                outdegreeCentrality = 0,
                nestedGraphs = [],
                ports = [],
                graphs = [],
                portMap = {};

            /**
             * Gets all Edges where this Node is either the source or the target of the Edge.
             * Note that this does *not* retrieve Edges on any Ports associated with this Node - for that, @see #getAllEdges.
             * @method getEdges
             * @param {Object} params Method parameters.
             * @param {Function} [params.filter] Optional Edge filter.
             * @return {Edge[]} List of edges.
             */
            this.getEdges = function (params) {
                if (params == null || params.filter == null) return edges;
                else {
                    var out = [];
                    for (var i = 0; i < edges.length; i++)
                        if (params.filter(edges[i])) out.push(edges[i]);
                    return out;
                }
            };

            /**
             * Gets all Edges where this Node is the source.
             * @method getSourceEdges
             * @returns {Edge[]}
             */
            this.getSourceEdges = function() {
                return this.getEdges({
                    filter:function(e) {
                        return e.source == this;
                    }.bind(this)
                });
            };

            /**
             * Gets all Edges where this Node is the target.
             * @method getTargetEdges
             * @returns {Edge[]}
             */
            this.getTargetEdges = function() {
                return this.getEdges({
                    filter:function(e) {
                        return e.target == this;
                    }.bind(this)
                });
            };

            /**
             * Adds an Edge to the Node.
             * @method addEdge
             * @param {Edge} edge The Edge to add.
             */
            this.addEdge = function (edge) {
                edges.push(edge);
                if (edge.source === this || !edge.isDirected()) {
                    outdegreeCentrality++;
                }
                if (edge.target === this || !edge.isDirected()) {
                    indegreeCentrality++;
                }
            };

            /**
             * Deletes an Edge from the Node.
             * @method deleteEdge
             * @param {Edge} edge The Edge to delete.
             */
            this.deleteEdge = function (edge) {
                var idx = -1;
                for (var i = 0; i < edges.length; i++) {
                    if (edges[i].getId() === edge.getId()) {
                        idx = i;
                        break;
                    }
                }
                if (idx > -1) {
                    edges.splice(idx, 1);
                    if (edge.source === this || !edge.isDirected()) {
                        outdegreeCentrality--;
                    }
                    if (edge.target === this || !edge.isDirected()) {
                        indegreeCentrality--;
                    }
                    return true;
                }
                return false;
            };

            /**
             * @method getAllEdges
             * @desc Gets all of the Edges connected to this Node, both on the Node itself and on all of its Ports.
             * @param {Object} [params] Method parameters.
             * @param {Function} [params.filter] Optional Edge filter.
             * @return {Edge[]} List of Edges.
             */
            this.getAllEdges = function (params) {
                var e = this.getEdges(params).slice(0);
                for (var i = 0; i < ports.length; i++) {
                    e.push.apply(e, ports[i].getEdges(params));
                }
                return e;
            };

            /**
             * Adds a sub-graph to this node. If you provide an existing Graph instance that does not have
             * an id, one will be assigned.
             * @method addGraph
             * @param {Graph|String} g Either a Graph instance, or the id you wish to assign to a new Graph.
             * @return {Graph} The Graph that was added.
             */
            this.addGraph = function (g) {
                g = typeof g == "string" ? new exports.Graph({id: g}) : g;
                graphs.push(g);
                if (!g.id)
                    g.id = "" + graphs.length;

                return g;
            };

            /**
             * Retrieves a sub-graph by id.
             * @method getGraph
             * @return {Graph} Sub-graph with the given id, null if not found.
             */
            this.getGraph = function (id) {
                for (var i = 0; i < graphs.length; i++) {
                    if (graphs[i].id === id)
                        return graphs[i];
                }
            };

            /**
             * Gets this Node's "indegree" centrality; a measure of how many other Nodes are connected to this Node as the target of some Edge.
             * @method getIndegreeCentrality
             * @return {Float} Indegree centrality for the Node.
             */
            this.getIndegreeCentrality = function () {
                var pc = 0;
                for (var i = 0; i < ports.length; i++)
                    pc += ports[i].getIndegreeCentrality();
                return indegreeCentrality + pc;
            };

            /**
             * Gets this Node's "outdegree" centrality; a measure of how many other Nodes this Node is connected to as the source of some Edge.
             * @method getOutdegreeCentrality
             * @return {Float} Outdegree centrality for the Node.
             */
            this.getOutdegreeCentrality = function () {
                var pc = 0;
                for (var i = 0; i < ports.length; i++)
                    pc += ports[i].getOutdegreeCentrality();
                return outdegreeCentrality + pc;
            };

            /**
             * Gets all Ports associated with this Node.
             * @method getPorts
             * @return {Port[]} List of Ports, empty list if none registered.
             */
            this.getPorts = function () {
                return ports;
            };

            /**
             * Adds a Port to the Node.
             * @method addPort
             * @param {Object} [data] Optional data backing the Port. This object can be of any type you like.
             * @param {Function} [idFunction] Optional function that can take a Port's data and return its ID. By default this looks for an `id` member in the backing data.
             * @return {Port} The newly created Port.
             */
            this.addPort = function (data, idFunction) {
                var id = _getId(data, idFunction, graph), p = this.getPort(id);
                if (p == null) {
                    p = new Port(data, idFunction, this);
                    ports.push(p);
                    portMap[p.id] = p;
                }
                return p;
            };

            /**
             * Sets the underlying data for the Port with the given id.  If the Port does not yet exist, it is created.
             * @method setPort
             * @param {String} id Id of the Port for which to set data.
             * @param {Object} data Data to set for the Port.
             */
            this.setPort = function (id, data) {
                var p = this.getPort(id);
                if (!p) {
                    p = this.addPort({id: id});
                }
                p.data = data;
                p.setType(this.graph.getType(data));
                return p;
            };

            /**
             * Gets the Port with the given id, null if nothing found.
             * @method getPort
             * @param {String} id Port id.
             * @return {Port} Port with the given id, or null if not found.
             */
            this.getPort = function (portId) {
                return portMap[portId];
            };

            var _portId = function (port) {
                return port.constructor == exports.Port ? port.id : port;
            };

            /**
             * Removes the given Port.
             * @method removePort
             * @param {Port|String} Either a Port, or a Port id.
             */
            this.removePort = function (port) {
                if (port) {
                    var id = _portId(port), idx = -1,
                        exists = false;

                    for (var i = 0; i < ports.length; i++) {
                        if (ports[i].id === id) {
                            idx = i;
                            break;
                        }
                    }
                    if (idx != -1) {
                        var p = ports[idx];
                        graph.deleteVertex(p);
                        ports.splice(idx, 1);
                        exists = true;
                    }

                    delete portMap[id];
                }
                return exists;
            };

            var defaultInternalCost = 0;
            var internalEdges = { };

            /**
             * Sets the default cost of travelling from one Port to another inside some Node. When a Node is created, this value is set to 1.
             * @method setDefaultInternalCost
             * @param {Number} cost Default internal cost.
             */
            this.setDefaultInternalCost = function (c) {
                defaultInternalCost = c;
            };

            /**
             * Gets an "internal" Edge from one Port to another.
             * @method getInternalEdge
             * @param {Port|String} source Source Port.
             * @param {Port|String} target Target Port.
             * @return {Object} An object containing `\{ source:..., target:..., cost:..., directed:... \}`.
             */
            this.getInternalEdge = function (source, target) {
                var spid = _portId(source), tpid = _portId(target),
                    out = { source: portMap[spid], target: portMap[tpid], cost: Infinity };

                if (out.source && out.target) {
                    var ie = internalEdges[spid + "-" + tpid] || { cost: defaultInternalCost, directed: false };
                    for (var i in ie)
                        out[i] = ie[i];
                }
                return out;
            };

            /**
             * Sets the cost and directedness of some internal Edge.
             * @method setInternalEdge
             * @param {Port|String} source Source Port.
             * @param {Port|String} target Target Port.
             * @param {Number} cost Cost to set. If you leave this as null, the default will be used.
             * @param {Boolean} [directed] Whether or not the internal Edge is directed.
             */
            this.setInternalEdge = function (source, target, cost, directed) {
                var spid = _portId(source), tpid = _portId(target);
                internalEdges[spid + "-" + tpid] = {
                    cost: cost || defaultInternalCost,
                    directed: directed
                };
                return this.getInternalEdge(source, target);
            };

            /**
             * Returns a string representation of the Node.
             * @method inspect
             * @return {String} Node dumped to a string.
             */
            this.inspect = function () {
                var i = "{ id:" + this.id + ", edges:[\n";
                for (var j = 0; j < edges.length; j++) {
                    i += edges[j].inspect() + "\n";
                }
                i += "]}";
                return i;
            };
        },
        /**
         * A Port resides on a Node, and may be the source/target of one or more connections. A convenient way to think
         * of Ports is as the columns in a database table: they belong to a table, but it is the columns themselves that
         * have relationships with other columns.
         * @class Port
         * @extends Node
         * @constructor
         */
        Port = exports.Port = function (data, idFunction, node) {
            Vertex.apply(this, [ data, idFunction, node.graph ]);
            this.objectType = "Port";

            /**
             * @property id The Port's id. This must be unique on a Node, but not necessarily unique with a given Graph.
             * @type {String}
             * @see getFullId
             */

            /**
             * Gets the Node this Port belongs to.
             * @method getNode
             * @return {Node} The Node this Port belongs to.
             */
            this.getNode = function () {
                return node;
            };

            /**
             * Overrides the `getFullId` of Node to return a value in dotted notation of the form `nodeId.portId`.
             * @method getFullId
             * @return {String} The Port's "full" id, ie. the Port's id prepended by the parent Node's id, eg `"BooksTable.idColumn"```.
             */
            this.getFullId = function () {
                return node.id + this.graph.getPortSeparator() + this.id;
            };

            /**
             * @method isChildOf
             * @param {Node} node Node to test if this is a child.
             * @return {Boolean} True if this Port is a child of the given Node, false otherwise.
             */
            this.isChildOf = function (_node) {
                return node == _node;
            };

            this.getPorts = this.addPort = this.deletePort = this.getPort = null;
        },

        /**
         * This is an Edge in the graph.  There can be one or zero of these for every pair of Nodes/Ports in the Graph.  Each Edge has an associated "cost", and may be either bidirectional
         * or unidirectional.
         * @class Edge
         * @constructor
         * @param {Object} params Edge parameters.
         * @param {Object} [params.data] Optional backing data for the edge.
         * @param {Node|Port} params.source Edge's source.
         * @param {Node|Port} params.target Edge's target.
         * @param {Number} [params.cost=1] Edge's cost. Defaults to 1.
         * @param {Boolean} [params.directed] Whether or not the Edge is directed. Default is true.
         */
        Edge = exports.Edge = function (params) {
            Base.call(this, params.data, params.graph);
            /**
             * Source of the Edge.
             * @property source
             * @type {Node|Port}
             */
            this.source = params.source;
            /**
             * Target of the Edge.
             * @property target
             * @type {Node|Port}
             */
            this.target = params.target;

            this.objectType = "Edge";
            var _cost = params.cost || 1,
                _directed = !(params.directed === false),
                _id = params.id,
                _connectionId = null;

            /**
             * Data for the Edge.
             * @property data
             * @type {Object}
             */
            this.data = params.data || {};

            /**
             * Gets the cost for this edge. Defaults to 1.
             * @method getCost
             * @return {Number} Edge cost.
             */
            this.getCost = function () {
                return _cost;
            };

            /**
             * Sets the cost for this edge.
             * @method  setCost
             * @param {Number} c Edge cost.
             */
            this.setCost = function (c) {
                _cost = c;
            };

            /**
             * Gets the id for this Edge.
             * @method getId
             * @return {Number} Edge id.
             */
            this.getId = this.getFullId = function () {
                return _id === null ? this.source.id + "_" + this.target.id : _id;
            };
            this.setId = function (id) {
                _id = id;
            };

            /**
             * Gets whether or not the Edge is directed.
             * @method isDirected
             * @return {Boolean} True if the Edge is directed (unidirectional), false otherwise.
             */
            this.isDirected = function () {
                return _directed;
            };

            /**
             * Sets whether or not the Edge is directed.
             * @method setDirected
             */
            this.setDirected = function(directed) {
                _directed = directed;
            };

            /**
             * Returns a string representation of the Edge.
             * @method inspect
             * @return {String} Edge dumped to a string.
             */
            this.inspect = function () {
                if (_id != null)
                    return "{ id:" + _id + ", connectionId:" + _connectionId + ", cost:" + _cost + ", directed:" + _directed + ", source:" + this.source.id + ", target:" + this.target.id + "}";
            };
        },
        /**
         * Models a group of Nodes.
         *
         * @class Group
         * @constructor
         */
        Group = exports.Group = function (data, idFunction, graph) {
            Vertex.apply(this, arguments);

            this.objectType = "Group";
            var vertices = [], _vertexMap = {};
            /**
             * The Group's id. A String.
             * @property id
             * @type {String}
             */

            // ^^ placeholder for API docs. overrides Node's docs.

            /**
             * Gets the Groups's id, which, for Groups, is just the `id` property.
             * @method getFullId
             * @return {String} Node's id.
             */

            this.addVertex = this.addNode = function(v) {
                if (_vertexMap[v.id] != null) {
                    return false;
                } else {
                    vertices.push(v);
                    _vertexMap[v.id] = v;
                    v.group = this;
                    return true;
                }
            };
            this.getVertexCount = this.getNodeCount = function() { return vertices.length; };
            this.getVertices = this.getNodes = function() { return vertices; };
            this.deleteVertex = this.deleteNode = function(v) {
                v = typeof v === "string" ? _vertexMap[v] : v;
                if (v) {
                    var idx = vertices.indexOf(v);
                    if (idx != -1) {
                        vertices.splice(idx, 1);
                        delete _vertexMap[v.id];
                    }
                    delete v.group;
                }
            };
            this.cleanup = function(removeMembers) {
                var i;
                var edges = this.getAllDirectEdges(), edgeCount = edges.length;
                for (i = 0; i < edgeCount; i++) {
                    graph.deleteEdge(edges[0]);
                }

                var l = vertices.length;
                for (i = 0; i < l; i++) {
                    if (removeMembers) {
                        graph.deleteVertex(vertices[0]); // always idx 0 because graph calls this object back; the list
                        // gets smaller as we go.
                    }
                    else {
                        delete vertices[0].group
                    }
                }
                vertices.length = 0;
            };

            this.getAllDirectEdges = function(params) {
                var e = [], i;
                e.push.apply(e, this.getEdges(params).slice(0));
                var ports = this.getPorts();
                for (i = 0; i < ports.length; i++) {
                    e.push.apply(e, ports[i].getEdges(params));
                }
                return e;
            };

            /**
             * Gets all the edges from the Group, any Ports the Group has, and any Edges from any Nodes contained in
             * the Group.
             * @method getAllEdges
             * @param params
             * @returns {Array}
             */
            this.getAllEdges = function(params) {
                var e = [], eMap = {};
                for (var i = 0; i < vertices.length; i++) {
                    Array.prototype.push.apply(e, vertices[i].getAllEdges(params).filter(function(ve) {
                        var eid = ve.getId(), ok = eMap[eid] == null;
                        eMap[eid] = true;
                        return ok;
                    }));
                }

                // now edges on this object itself
                e.push.apply(e, this.getAllDirectEdges(params));

                return e;
            }
        },
        /**
         * A cluster of connected Nodes/Groups. Currently a basic implementation; we can in future expand the API of
         * this object to provide more information about the cluster such as edge count, interdependency etc.
         *
         * Clusters are not created directly. The internal API creates these in response to a `getClusters` call
         * on a Graph.
         *
         * @class Cluster
         * @constructor
         * @param {Node|Group} seed The first Node/Group in the Cluster.
         */
        Cluster = exports.Cluster = function(seed) {
            this.vertices = [ seed ];
            this.addVertex = function(v) {
                this.vertices.push(v);
            };
        },
        /**
         * A Graph.  Contains a list of Vertex objects, each of which has 0..N Ports, and a list of Edge objects. Every instance
         * of the jsPlumb Toolkit is backed by an instance of this class.
         *
         * A good discussion on Graphs can be found on Wikipedia: http://en.wikipedia.org/wiki/Graph_(mathematics).
         *
         * You will not typically need to construct a Graph directly (at least not when using the Toolkit; there is nothing
         * stopping you from using this class directly for other purposes).
         *
         * @class Graph
         * @constructor
         * @param {Object} [params] Constructor parameters. Optional. The Graph class has sensible defaults.
         * @param {Boolean} [params.defaultDirected=true] Whether edges are directed by default.
         * @param {Function} [params.idFunction] Function to use to extract an appropriate ID from the JSON for a give node. Defaults to returning the 'id' property of the JSON.
         * @param {Boolean} [params.enableSubgraphs=false] If true, Nodes are Graphs themselves, and can have child Nodes. If you enable this then you cannot use slashes (/) in your Node ids, as they will be treated as components of a path to a Node in a nested Graph.
         * @param {Number} [params.defaultCost=1] Default cost for Edges.
         * @param {String} [params.portSeparator="."] The character(s) used to separate ports from nodes in port ids.
         */
        Graph = exports.Graph = function (params) {
            params = params || {};
            this.vertices = [];
            this.edges = [];
            this.groups = [];
            this.id = params.id;
            var _vertexMap = {},
                _vertexCount = 0,
                _edgeMap = {},
                _edgeCount = 0,
                _groupMap = {},
                _groupCount = 0,
                defaultDirected = !(params.defaultDirected === false),
                defaultCost = params.defaultCost || 1,
                _defaultIdFunction = params.idFunction || function (d) {
                    return d.id;
                },
                typeFunction = params.typeFunction || function (d) {
                    return d.type || "default";
                },
                enableSubgraphs = params.enableSubgraphs === true,
                portSeparator = params.portSeparator || ".",
                _topLevelCache = {},
                _removeFromTopLevelCache = function(v) {
                    delete  _topLevelCache[v.id];
                },
                _addToTopLevelCache = function(v) {
                    _topLevelCache[v.id] = v;
                },
                _clearTopLevelCache = function() {
                    _topLevelCache = {};
                };

            /**
             * Sets the default function to use to extract an appropriate ID from the JSON for any given object.
             * @method setIdFunction
             * @param {Function} idFunction Function to use to extract IDs.
             */
            this.setIdFunction = function (f) {
                _defaultIdFunction = f;
            };

            /**
             * Gets the current function to use to extract an appropriate ID from the JSON for any given object.
             * @method getIdFunction
             * @return {Function} Function in use for extracting IDs.
             */
            this.getIdFunction = function () {
                return _defaultIdFunction;
            };

            /**
             * Sets the default function to use to extract an appropriate type from the JSON for any given object.
             * @method setIdFunction
             * @param {Function} f Function to use to extract IDs.
             */
            this.setTypeFunction = function (f) {
                typeFunction = f;
            };

            /**
             * Gets the type for some data, by running it through the current typeFunction.
             * @param {Object} data Object to get type from.
             */
            this.getType = function (data) {
                return typeFunction(data);
            };

            this.getTopLevelElements = function() {
                return _topLevelCache;
            };

            /**
             * Sets whether or not Nodes are Graphs themselves, and can have child Nodes. If you enable this
             * then you cannot use slashes (/) in your Node ids, as they will be treated as components of a path
             * to a Node in a nested Graph.
             * @param {Boolean} enable True to enable, false to disable.
             */
            this.setEnableSubgraphs = function (enable) {
                enableSubgraphs = enable;
            };

            /**
             * Sets the character(s) used to separate ports from nodes in port ids. By default this is '.', ie a
             * port is addressed as `nodeId.portId`. This may need to be changed depending on the data in your model.
             * @method setPortSeparator
             * @param {String} separator Separator to use.
             */
            this.setPortSeparator = function (separator) {
                portSeparator = separator;
            };

            /**
             * Gets the current port separator.
             * @return {String} Port separator string. Default is "."
             */
            this.getPortSeparator = function () {
                return portSeparator;
            };

            var _getVertex = function (e, createPortsIfMissing) {
                if (e == null) return null;
                // if not a string, check if its an object
                if (typeof e != "string") {
                    if (e.constructor == exports.Port || e.constructor == exports.Node || e.constructor == exports.Group) return e;
                    var orig = e;
                    // if its an object from which we could get something that looks like an id, get the id and continue with the id lookup code.
                    e = _defaultIdFunction(e);
                    // otherwise, return.
                    if (typeof e != "string") return orig;
                }

                var path = enableSubgraphs ? e.split("/") : [ e ],
                    _one = function (_id) {
                        if (_vertexMap[_id]) return _vertexMap[_id];
                        if (_groupMap[_id]) return _groupMap[_id];
                        // otherwise, look for a node by assuming dotted notation.
                        var np = _id.split(portSeparator),
                            nodeId = np[0],
                            node = _vertexMap[nodeId] || _groupMap[nodeId];

                        if (np.length === 2 && node != null) {
                            var p = node.getPort(np[1]);
                            if (p == null && createPortsIfMissing)
                                p = node.addPort(np[1]);
                            return p;
                        }
                        else
                            return node;
                    };

                if (path.length == 1) return _one(path[0]);
                else if (path.length > 1 && path % 2 == 0)
                    throw "Subgraph path format error.";
                else {
                    // if path empty then this is a node/port lookup on the root. otherwise path should have an
                    // odd number of components, since it consists of a series of node/graph entries followed by
                    // a final node id.
                    var currentNode = null, currentGraph = null;
                    for (var i = 0; i < path.length - 1; i += 2) {
                        currentNode = _one(path[i]);
                        currentGraph = currentNode.getGraph(path[i + 1]);
                    }
                    return currentGraph.getVertex(path[path.length - 1]);
                }
            };

            // -------------------------               public API               -----------------------

            /**
             * Clears the Graph of all its Nodes, Ports and Edges.
             * @method clear
             */
            this.clear = function () {
                this.vertices.length= 0;
                this.groups.length= 0;
                _vertexCount = 0;
                _edgeCount = 0;
                _vertexMap = {};
                _edgeMap = {};
                _groupMap = {};
                _clearTopLevelCache();
            };

            /**
             * Gets all the Nodes in the Graph.
             * @method getNodes
             * @return {Node[]} All the Nodes in the Graph.
             */
            this.getVertices = this.getNodes = function () {
                return this.vertices;
            };

            /**
             * Gets the count of Nodes in the Graph.
             * @method getNodeCount
             * @return {Integer} The total number of Nodes in the graph.
             */
            this.getVertexCount = this.getNodeCount = function () {
                return this.vertices.length;
            };

            /**
             * Returns the Node at the given index (used for bulk init type purposes)
             * @method getNodeAt
             * @param {Integer} index Index of the Node to retrieve
             * @return {Node} Node at the given index.
             */
            this.getVertexAt = this.getNodeAt = function (index) {
                return this.vertices[index];
            };

            /**
             * Returns the total number of Edges in the graph.
             * @method getEdgeCount
             * @return {Integer} The total number of Edges.
             */
            this.getEdgeCount = function () {
                return _edgeCount;
            };

            /**
             * Adds an Edge to the Graph.
             * @method addEdge
             * @param {Object} params Parameters for new Edge.
             * @param {String|Node|Port} params.source Source for the Edge - a Node, Port or Node/Port id.
             * @param {String|Node|Port} params.target Target for the Edge - a Node, Port or Node/Port id.
             * @param {Integer} [params.cost=1] Edge cost. This is used when computing shortest paths through the graph. If
             * an Edge is not `directed`, then the same cost is applied regardless of the direction of traversal.
             * @param {Boolean} [params.directed=true] Whether or not the Edge is directed.
             * @param {Object} [params.data] Optional data to associate with the Edge. The default edgeIdFunction
             * @return {Edge} The Edge that was added.
             */
            this.addEdge = function (params, idFunction, connectableFilterFunction) {
                var directed = params.directed == null ? defaultDirected === true : !(params.directed === false),
                    cost = params.cost || defaultCost,
                    id = _getId(params.data, idFunction, this),
                    source = _getVertex(params.source, true),
                    target = _getVertex(params.target, true);

                if (source == null || source.objectType == null) throw new TypeError("Unknown source node [" + params.source + "]");
                if (target == null || target.objectType == null) throw new TypeError("Unknown target node [" + params.target + "]");

                if (connectableFilterFunction && !connectableFilterFunction(source, target)) {
                    return null;
                }

                var edge = new Edge({
                    source: source,
                    target: target,
                    cost: cost,
                    directed: directed,
                    data: params.data || {},
                    id: id,
                    graph: this
                });

                edge.source.addEdge(edge);
                if (edge.source !== edge.target) {
                    edge.target.addEdge(edge);
                }

                _edgeMap[id] = edge;
                _edgeCount++;

                return edge;
            };

            /**
             * Adds a Node to the Graph
             * @method addNode
             * @param {Object} data Backing data for the Node
             * @param {Function} [idFunction] Optional function to use to retrieve ID from backing data. Defaults to retrieving `id` from data object.
             * @param {Node} The Node that was added.
             */
            this.addVertex = this.addNode = function (data, idFunction) {
                var v = new Vertex(data, idFunction || _defaultIdFunction, this);
                if (!_vertexMap[v.id]) {
                    this.vertices.push(v);
                    _vertexMap[v.id] = v;
                    v._id = _vertexCount++;
                    _addToTopLevelCache(v);
                    return v;
                }
                return null;
            };

            /**
             * Adds a list of Nodes to the Graph
             * @method addNodes
             * @param {Object[]} data List of data objects, one for each Node to be added.
             * @param {Function} [idFunction] Optional function to use to retrieve ID from backing data. Defaults to retrieving `id` from data object.
             */
            this.addVertices = this.addNodes = function (data, idFunction) {
                for (var i = 0; i < data.length; i++) {
                    this.addVertex(data[i], idFunction || _defaultIdFunction);
                }
            };

            /**
             * Adds a Group to the Graph.
             * @param data
             * @param idFunction
             * @returns {*}
             */
            this.addGroup  = function (data, idFunction) {
                var g = new Group(data, idFunction || _defaultIdFunction, this);
                if (!_groupMap[g.id]) {
                    this.groups.push(g);
                    _groupMap[g.id] = g;
                    g._id = _groupCount++;
                    _addToTopLevelCache(g);
                    return g;
                }
                return _groupMap[g.id];
            };

            this.getGroupCount = function() { return this.groups.length; };

            /**
             * Returns the Group at the given index.
             * @method getGroupAt
             * @param {Number} idx Index into group list
             * @returns {Group} a Group, or null if not found.
             */
            this.getGroupAt = function(idx) {
                return this.groups[idx];
            };

            this.addVertexToGroup = function (v, g) {
                g = typeof g === "string" ? _groupMap[g] : g;
                v = _getVertex(v);
                if (v && g) {
                    g.addVertex(v);
                    _removeFromTopLevelCache(v);
                }
            };

            this.addVerticesToGroup = function (v, g) {
                for (var i = 0; i < v.length; i++) {
                    this.addVertexToGroup(v[i], g);
                }
            };

            this.deleteVertexFromGroup = function(v) {
                v = _getVertex(v);
                if (v && v.group) {
                    v.group.deleteVertex(v);
                    _addToTopLevelCache(v);
                }
            };

            this.deleteVerticesFromGroup = function (v, g) {
                for (var i = 0; i < v.length; i++) {
                    this.deleteVertexFromGroup(v[i], g);
                }
            };

            /**
             * Deletes a Group
             * @method deleteGroup
             * @param {Node|String} g Either a Group, or a Group id.
             * @param {Boolean} [removeMembers=false] If true, also remove all the Nodes that are members of the Group.
             */
            this.deleteGroup = function(g, removeMembers) {
                g = typeof g === "string" ? _groupMap[g] : g;
                if (g) {
                    g.cleanup(removeMembers);
                    delete _groupMap[g.id];

                    var idx = -1;
                    for (var i = 0; i < this.groups.length; i++) {
                        if (this.groups[i].id === g.id) {
                            idx = i;
                            break;
                        }
                    }
                    if (idx > -1) {
                        this.groups.splice(idx, 1);
                    }

                    _removeFromTopLevelCache(g);
                    return g;
                }
            };

            this.getGroup = function(group) {
                return typeof group === "string" ? _groupMap[group] : group;
            };

            /**
             * Deletes a Node
             * @method deleteNode
             * @param {Node|String} node Either a Node, or a Node id.
             */
            this.deleteVertex = this.deleteNode = function (vertex) {
                var v = _getVertex(vertex);
                if (v) {
                    var idx = -1;
                    for (var i = 0; i < this.vertices.length; i++) {
                        if (this.vertices[i].id === v.id) {
                            idx = i;
                            break;
                        }
                    }
                    if (idx > -1) {
                        this.vertices.splice(idx, 1);
                        if (v.group != null) {
                            v.group.deleteVertex(v);
                        }
                    }
                    var edges = v.getEdges();
                    for (var j = 0; j < edges.length; j++) {
                        this.deleteEdge(edges[j]);
                    }
                    _edgeCount -= edges.length;

                    if (v.getPorts) {
                        var ports = v.getPorts();
                        for (var k = 0; k < ports.length; k++) {
                            this.deleteVertex(ports[k]);
                        }
                    }

                    delete _vertexMap[v.id];
                    _vertexCount--;

                    _removeFromTopLevelCache(v);
                }
            };

            /**
             * Deletes an Edge.
             * @method deleteEdge
             * @param {Edge|String} edge Edge, or ID of Edge, to delete.
             */
            this.deleteEdge = function (edge) {
                edge = this.getEdge(edge);
                if (edge == null) return;
                var v = _getVertex(edge.source);
                if (v && v.deleteEdge(edge)) {
                    _edgeCount--;
                }
                var v2 = _getVertex(edge.target);
                if (v2) {
                    v2.deleteEdge(edge);
                }
                delete _edgeMap[edge.getId()];
            };

            /**
             * Gets an Edge by id, or if the given object is already an Edge, hands that back.
             * @method getEdge
             * @param {String|Edge|Object} e ID of the Edge to retrieve, or an actual Edge, or some data from which an ID could be derived.
             * @return {Edge} The requested Edge, if found, otherwise null.
             */
            this.getEdge = function (e) {
                if (e == null) return;
                if (typeof e != "string") {
                    if (e.constructor == exports.Edge) return e;
                    var orig = e;
                    // if its an object from which we could get something that looks like an id, get the id and continue with the id lookup code.
                    e = _defaultIdFunction(e);
                    // otherwise, return.
                    if (typeof e != "string") return orig;
                }
                return _edgeMap[e];
            };

            /**
             * For some given node, get a subset of edges that match the given filter function.
             * @param {Object} params Method parameters
             * @param {Boolean} [params.source] If true, only match edges for which this node is the source.
             * @param {Boolean} [params.target] If true, only match edges for which this node is the target.
             * @param filter
             */
            this.getEdges = function (params) {

                params = params || {};
                var s = params.source,
                    t = params.target,
                    f = params.filter || function () {
                        return true;
                    },
                    fe = function (e) {
                        return (s == null || ( (e.source == node) === s)) && (t == null || ( (e.target == node) === t));
                    },
                    out = [],
                    match = function (e) {
                        if (f(e) && fe(e)) out.push(e);
                    },
                    i;

                if (params.node) {
                    var node = _getVertex(params.node);
                    var e = node.getAllEdges();
                    for (i = 0; i < e.length; i++)
                        match(e[i]);
                }
                else {
                    for (i in _edgeMap)
                        match(_edgeMap[i]);
                }

                return out;
            };

            /**
             * Gets every edge in the Graph.
             * @returns {Array}
             */
            this.getAllEdges = function() {
                var a = [];
                for (var e in _edgeMap) a.push(_edgeMap[e]);
                return a;
            };

            /**
             * Finds the shortest path from source to target, using the Djikstra algorithm.
             * @method findPath
             * @param {Node|String} source Source Node or Node ID.
             * @param {Node|String} target Target Node or Node ID.
             * @param {Boolean} [strict=true] Sets whether or not paths are searched strictly by the given source/target. If, for instance, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
             * @param {Function} [nodeFilter] Optional function that is given each Node's backing data and asked to return true or false - true means include the Node, false means exclude it.
             * @param {Function} [edgeFilter] Optional function that is given each Edge's backing data and asked to return true or false - true means include the Edge, false means exclude it.
             * @return An array like `[  \{ vertex, cost, edge \}, \{ vertex,cost,edge \} ... ]` when successful; when unsuccessful the three compiled
             * tables are returned - distances to nodes, each node's previous node, and the associated edge.  so you can call this method with
             * no target set and get the entire table populated.
             */
            this.findPath = function (source, target, strict, nodeFilter, edgeFilter) {
                source = _getVertex(source);
                target = _getVertex(target);
                return Djikstra.compute({ graph: this, source: source, target: target, strict: !(strict === false), nodeFilter: nodeFilter, edgeFilter: edgeFilter });
            };

            /**
             * Finds the distance between source and target.
             * @method getDistance
             * @param {Node|String} source Source Node or Node ID.
             * @param {Node|String} target Target Node or Node ID.
             * @param {Boolean} [strict=true] Sets whether or not paths are searched strictly by the given source/target. If, for instance, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
             * @return {Number} Distance from the source to the target.
             */
            this.getDistance = function (source, target, strict) {
                var info = this.findPath(source, target, strict);
                return info.pathDistance;
            };

            /**
             * Gets the Node or Port with the given id, null if not found.
             * @method getNode
             * @param {String} id Node or Port id.
             * @return {Node} Node/Port if found, null otherwise.
             */
            this.getVertex = this.getNode = _getVertex;

            /**
             * Sets the target Node/Port for some Edge.
             * @method setTarget
             * @param {Node|Port|String} o Node/Port/id for new Edge target
             */
            this.setTarget = function (edge, o) {
                o = _getVertex(o);
                if (o == null) return { success:false };
                var old = edge.target;
                edge.target.deleteEdge(edge);
                edge.target = o;
                o.addEdge(edge);
                return { old: old, edge: edge, "new": o, success:true };
            };

            /**
             * Sets the source Node/Port for some Edge.
             * @method setSource
             * @param {Node|Port|String} o Node/Port/id for new Edge source
             */
            this.setSource = function (edge, o) {
                o = _getVertex(o);
                if (o == null) return { success:false };
                var old = edge.source;
                edge.source.deleteEdge(edge);
                edge.source = o;
                o.addEdge(edge);
                return { old: old, edge: edge, "new": o, success:true };
            };

            /**
             * Returns the path from source to target as a String.
             * @method printPath
             * @return {String} Printed path. Mostly useful for debugging.
             * @see findPath
             */
            this.printPath = function (source, target) {
                source = _getVertex(source);
                target = _getVertex(target);
                var path = this.findPath(source, target).path;
                var s = "[" + source.id + " - " + target.id + "] : ";
                for (var i = 0; i < path.length; i++)
                    s = s + "{ vertex:" + path[i].vertex.id + ", cost:" + path[i].cost + ", edge: " + (path[i].edge && path[i].edge.getId()) + " } ";
                return s;
            };

            /**
             * Returns the `diameter` of the Graph.
             * @method getDiameter
             * @param {Boolean} [dontUseMax=false] Whether or not to return Infinity if there is at least one pair of nodes for which there is no available path.
             * @return {Number} Diameter of the Graph.
             */
            this.getDiameter = function (dontUseMax) {
                var diameter = 0;
                for (var i = 0; i < this.vertices.length; i++) {
                    for (var j = 0; j < this.vertices.length; j++) {
                        if (j != i) {
                            var info = Djikstra.compute({graph: this, source: this.vertices[i], target: this.vertices[j]});
                            if (info.path == null || info.path.length == 0) {
                                if (!dontUseMax)
                                    return Infinity;
                            }
                            else
                                diameter = Math.max(diameter, info.pathDistance);
                        }
                    }
                }
                return diameter;
            };

            this.diameter = this.getDiameter;

            /**
             * Returns the degree centrality of the given node. This is an alias to `getDegreeCentrality`, as centrality
             * most commonly refers to degree centrality. Note that this returns incoming and outgoing connections; use
             * getIndegreeCentrality or getOutdegreeCentrality if you need to be more specific.
             * @method getCentrality
             * @param {Node|String} node Node, or Node ID, to retrieve centrality for.
             * @return {Integer} Node's centrality.
             * @see getBetweenness
             * @see getCloseness
             */
            this.getCentrality = function (node) {
                node = _getVertex(node);
                return (node.getIndegreeCentrality() + node.getOutdegreeCentrality()) / (this.getVertexCount() - 1);
            };

            this.getDegreeCentrality = this.getCentrality;

            /**
             * Returns the indegree centrality of the given node (number of connections entering the vertex)
             * @method getIndegreeCentrality
             * @param {Node|String} node Node, or Node ID, to retrieve indegree centrality for.
             * @return {Integer} Node's indegree centrality.
             */
            this.getIndegreeCentrality = function (node) {
                node = _getVertex(node);
                return node.getIndegreeCentrality() / (this.getVertexCount() - 1);
            };

            /**
             * Returns the outdegree centrality of the given node (number of connections exiting the vertex)
             * @method getOutdegreeCentrality
             * @param {Node|String} node Node, or Node ID, to retrieve outdegree centrality for.
             * @return {Integer} Node's indegree centrality.
             */
            this.getOutdegreeCentrality = function (node) {
                node = _getVertex(node);
                return node.getOutdegreeCentrality() / (this.getVertexCount() - 1);
            };

            /**
             * Returns the Closeness centrality of the given node. This is the inverse of the node's farness.
             * @method getCloseness
             * @param {Node|String} node Node, or Node ID, to retrieve closeness for.
             * @return {Float} Node's "closeness".
             * @see getFarness
             */
            this.getCloseness = function (node) {
                return 1 / this.getFarness(node);
            };

            /**
             * Returns the farness centrality of the given node, ie. the sum of its distance from all other nodes, where the distance from one Node to another is given by the associated cost of the Edge joining the two Nodes.
             * @method getFarness
             * @param {Node|String} node Node, or Node ID, to retrieve farness for.
             * @return {Number} Node's "farness".
             */
            this.getFarness = function (node) {
                node = _getVertex(node);
                // sum all of its paths to every other node.
                var info = Djikstra.compute({graph: this, source: node, target: node, processAll: true}), total = 0;
                for (var i in info.dist) {
                    total += info.dist[i];
                }
                return total / (this.getVertexCount() - 1);
            };

            /**
             * Returns the betweenness centrality of the given node.
             * @method getBetweenness
             * @param {Node|String} node Node, or Node ID, to retrieve betweenness centrality for.
             * @return {Float} Node's "betweenness" centrality.
             */
            this.getBetweenness = function (node) {

                var n = this.getVertexCount(),
                    denominator = (n - 1) * (n - 2) / 2,
                    betweenness = 0,
                    totalPathsThroughFocus = 0,
                    processNode = function (source, target, info, pathFromTarget, paths) {
                        var parents = info.parents[source][target];
                        if (parents.length == 0) {
                            var p = pathFromTarget.slice();
                            p.unshift(source);
                            paths.push(p);
                        }
                        else {
                            for (var i = 0; i < parents.length; i++) {
                                if (pathFromTarget.indexOf(parents[i][0].id) == -1) {
                                    var p = pathFromTarget.slice();
                                    p.unshift(parents[i][0].id);
                                    processNode(source, parents[i][0].id, info, p, paths);
                                }
                            }
                        }
                    };

                node = _getVertex(node);
                var info = FloydWarshall.compute({graph: this, focus: node});

                // for each node pair, retrieve the actual paths.  there may be multiple shortest paths for one given node
                // pair, and we use the 'parents' array to help with this. its a 2d array containing null for [v1,v1],
                // and an array of N entries for every [v1,vX]. N may be zero, which indicates that vN is adjacent to
                // v1. if it is greater than zero then it tells you how many nodes adjacent to vN are on shortest paths,
                // but note that it _does not_ tell you how many shortest paths join to vN.  we have to recurse back from
                // vN to each parent in this array, and look at that parent's entry; it will also be an array of N entries where
                // N may be zero or more.  we recurse up this parent array until we hit the trivial case - that N = 0.
                // as we go up the tree we can compare each node to see if it is the node for which we are computing
                // betweenness. remember that it only counts if the node is on the path, not the source or target.

                for (var v1 in info.paths) {
                    for (var v2 in info.paths[v1]) {
                        // v1 and v2 are the ids of our two nodes
                        if (v1 != v2) {
                            var pathsForPair = [], pathsUsingFocusNode = 0;
                            processNode(v1, v2, info, [v2], pathsForPair);
                            for (var i = 0; i < pathsForPair.length; i++) {
                                var idx = pathsForPair[i].indexOf(node.id);
                                if (idx > 0 && idx < pathsForPair[i].length - 1)
                                    pathsUsingFocusNode++;
                            }
                            betweenness += (pathsUsingFocusNode / pathsForPair.length);
                            totalPathsThroughFocus += pathsUsingFocusNode;
                        }
                    }
                }
                return betweenness / denominator;
            };

            // Helper method to dump the contents of the Graph to a string.
            this.inspect = function () {
                var r = "";
                for (var i = 0; i < this.vertices.length; i++)
                    r += this.vertices[i].inspect() + "\n";

                return r;
            };


            this.serialize = function () {
                var out = { nodes: [], edges: [], ports: [], groups:[] }, n, e, p, g;
                for (var i = 0; i < this.vertices.length; i++) {
                    n = this.vertices[i];
                    out.nodes.push(n.data);
                    e = n.getAllEdges(), p = n.getPorts();
                    for (var j = 0; j < e.length; j++) {
                        if (e[j].source == n || (e[j].source.objectType === "Port" && e[j].source.getNode() == n)) {
                            var ee = {
                                source: e[j].source.getFullId(),
                                target: e[j].target.getFullId()
                            };

                            if (e[j].data)
                                ee.data = e[j].data;

                            out.edges.push(ee)
                        }
                    }
                    for (var l = 0; l < p.length; l++) {
                        var le = { };

                        for (var m in p[l].data)
                            le[m] = p[l].data[m];

                        le.id = p[l].getFullId();

                        out.ports.push(le);
                    }
                }

                for (i = 0; i < this.groups.length; i++) {
                    g = this.groups[i];
                    out.groups.push(g.data);
                    e = g.getEdges();
                    for (var j = 0; j < e.length; j++) {
                        if(e[j].source === g) {
                            var ee = {
                                source: g.getFullId(),
                                target:e[j].target.getFullId()
                            };
                            if (e[j].data) {
                                ee.data = e[j].data;
                            }
                            out.edges.push(ee);
                        }
                    }
                }

                return out;
            };

            /**
             * Calculates "clusters" of nodes (and groups), where a 'cluster' is a set of Nodes/Groups that
             * are connected. Direction of connections is not taken into account. Nodes that are children of Groups are
             * included in all cluster calculations, which might cause some weird situations, but this functionality
             * is mostly intended just for Nodes anyway.
             * @returns {Array} An array of arrays, each entry being a list of nodes in the cluster.
             */
            this.getClusters = function() {
                var clusters = [], visited = {}, n;
                var _one = function(seed, cluster) {

                    if (seed == null || visited[seed.id]) return;

                    if (cluster == null) {
                        cluster = new Cluster(seed);
                        clusters.push(cluster);
                    } else {
                        cluster.addVertex(seed);
                    }

                    visited[seed.id] = true;
                    var e = seed.getAllEdges();
                    for (var i = 0; i < e.length; i++) {
                        var o = e[i].source === seed ? e[i].target : e[i].source;
                        _one(o, cluster);
                    }



                };

                for (n = 0; n < this.vertices.length; n++) {
                    _one(this.vertices[n]);
                }

                for (n = 0; n < this.groups.length; n++) {
                    _one(this.groups[n]);
                }

                return clusters;
            }
        },

        /**
         finds the Vertex in the 'dist' table that has not yet been computed and has the smallest cost so far.
         */
        _findSmallestDist = function (vertices, usedVertices, dist, idFunc, _getDist) {
            var idx = -1, node = null, smallest = Infinity;
            for (var i = 0; i < vertices.length; i++) {
                if (!usedVertices[i]) {
                    var d = _getDist(vertices[i]);
                    if (d < smallest) {
                        smallest = d;
                        idx = i;
                        node = vertices[i];
                    }
                }
            }
            return {node: node, index: idx};
        },

        _findPrev = function(previous, obj) {
           var id = obj.getFullId(), p = previous[id];
            if (p == null) {
                id = obj.getNode ? obj.getNode().id : obj.id;
                p = previous[id];
            }
            return p == null ? null : { p:p, id:id };
        },

        /**
         assembles a path to the given target, using data from the 'dist' and 'previous' tables.  the source of the path is the source that was most recently passed in to the
         Djikstra.compute method.
         */
        _findPath = function (dist, previous, edges, target, idFunc, strict) {
            var path = [], u = target;//, uid = idFunc(u);
            var p = _findPrev(previous, u);
            while (p != null) {
                path.splice(0, 0, {vertex: u, cost: dist[p.id], edge: edges[p.id]});
                u = p.p;
                //uid = idFunc(u);
                p = _findPrev(previous, u);
                //uid = u.getNode ? u.getNode().id : u.id;
            }
            // insert start vertex.
            path.splice(0, 0, {vertex: u, cost: 0, edge: null});
            return path;
        },

    // http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm
    /*
     Assume a function edgeCost(i,j) which returns the cost of the edge from i to j
     (infinity if there is none).
     Also assume that n is the number of vertices and edgeCost(i,i) = 0


     int path[][];
     A 2-dimensional matrix. At each step in the algorithm, path[i][j] is the shortest path
     from i to j using intermediate vertices (1..k1).  Each path[i][j] is initialized to
     edgeCost(i,j).


     procedure FloydWarshall ()
     for k := 1 to n
     for i := 1 to n
     for j := 1 to n
     path[i][j] = min ( path[i][j], path[i][k]+path[k][j] );
     */
        FloydWarshall = {
            getPath: function (pathInfo, nextInfo, source, target) {
                if (pathInfo[source.id][target.id] == Infinity)
                    return null;
                var intermediate = nextInfo[source.id][target.id];
                if (intermediate == null)
                    return " ";   //there is an edge from i to j, with no vertices between
                else
                    return FloydWarshall.getPath(pathInfo, nextInfo, source, intermediate) + " " + intermediate.id + " " + FloydWarshall.getPath(pathInfo, nextInfo, intermediate, target);
            },
            getPaths: function (pathInfo, nextInfo, source, target, paths) {
                if (pathInfo[source.id][target.id] == Infinity)
                    return null;
                var intermediate = nextInfo[source.id][target.id];
                if (intermediate.length == 0)
                    return " ";   // there is an edge from i to j, with no vertices between
                else
                    return FloydWarshall.getPaths(pathInfo, nextInfo, source, intermediate[0]) + " " + intermediate[0].id + " " + FloydWarshall.getPaths(pathInfo, nextInfo, intermediate[0], target);
            },
            compute: function (params) {
                var graph = params.graph,
                    n = graph.getVertexCount(),
                    path = {},
                    next = {}, i, j, k;

                // init
                for (i = 0; i < n; i++) {
                    var v = graph.getVertexAt(i);
                    if (!path[v.id]) path[v.id] = {};
                    if (!next[v.id]) next[v.id] = {};
                    path[v.id][v.id] = 0;
                    for (j = 0; j < n; j++) {
                        if (i != j) {
                            var v2 = graph.getVertexAt(j);
                            if (!path[v.id][v2.id]) path[v.id][v2.id] = Infinity;
                            if (!next[v.id][v2.id]) next[v.id][v2.id] = [];
                        }
                    }
                    var edges = v.getEdges();
                    for (k = 0; k < edges.length; k++) {
                        if (edges[k].source == v) {
                            path[v.id][edges[k].target.id] = edges[k].getCost();
                        }
                        else {
                            if (!path[edges[k].source.id]) {
                                path[edges[k].source.id] = {};
                                next[edges[k].source.id] = {};
                            }
                            path[v.id][edges[k].source.id] = edges[k].getCost();
                        }
                    }
                }
                //
                for (k = 0; k < n; k++) {
                    for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                            if (i != j && j != k && i != k) {
                                var id1 = graph.getVertexAt(i).id, id2 = graph.getVertexAt(j).id, id3 = graph.getVertexAt(k).id;
                                if ((path[id1][id3] + path[id3][id2]) <= path[id1][id2] && (path[id1][id3] + path[id3][id2]) != Infinity) {
                                    path[id1][id2] = path[id1][id3] + path[id3][id2];
                                    if (!next[id1][id2]) next[id1][id2] = [];
                                    next[id1][id2].unshift([graph.getVertexAt(k), path[id1][id2]]);
                                }
                            }
                        }
                    }
                }

                //return [ path, pathsThroughFocus ];
                return {paths: path, parents: next};
            }
        },
        /**
         * An implementation of the Djikstra shortest path algorithm. The algorithm has been modified
         * slightly to handle Ports on Nodes.
         */
        Djikstra = {
            compute: function (params) {
                var graph = params.graph,
                    source = params.source,
                    target = params.target,
                    nodeFilter = params.nodeFilter,
                    edgeFilter = params.edgeFilter,
                    dist = {},
                    previous = {},
                    edges = {},
                    retVal = { dist: dist, previous: previous, edges: edges, path: [] },
                    processAll = params.processAll,
                    portMap = {},
                    nodeFromPortMap = {},
                    strict = !(params.strict === false),
                    _getId = function (n) {
                        return n.getFullId ? n.getFullId() : n.id;
                    },
                    _vertices = [],
                    _getRelatedPorts = function (p) {
                        var n = nodeFromPortMap[p.getFullId()];
                        return portMap[n.v.id];
                    },
                    _setDist = function (o, v) {
                        var pp, i;
                        // if o is a node, v is applied to all ports also. otherwise, all other ports
                        // for the node that is the parent of o are given v + internalEdgeCost, which may
                        // vary by port.
                        if (o.objectType === "Port") {
                            dist[o.getFullId()] = v;
                            // it's a port.
                            pp = _getRelatedPorts(o);
                            for (i = 0; i < pp.length; i++) {
                                if (pp[i].p != o) {
                                    dist[pp[i].p.getFullId()] = v + o.getNode().getInternalEdge(o, pp[i].p).cost;
                                }
                            }

                            if (!strict)
                                dist[o.getNode().id] = v;
                        }
                        else {
                            dist[o.id] = v;
                            pp = portMap[o.id];
                            for (i = 0; i < pp.length; i++)
                                dist[pp[i].p.getFullId()] = v;
                        }
                    },
                    _getDist = function (o) {
                        if (nodeFilter && !nodeFilter(o)) return Infinity;
                        return dist[_getId(o)];
                    },
                    _setPrevious = function (n, nId, prevInfo) {
                        if (n.objectType === "Port") {
                            var pp = _getRelatedPorts(n);
                            for (var i = 0; i < pp.length; i++) {
                                previous[pp[i].p.getFullId()] = prevInfo.node;
                            }

                            if (!strict)
                                previous[n.getNode().id] = prevInfo.node;
                        }
                        previous[nId] = prevInfo.node;
                    },
                    _setEdge = function (n, nId, edge) {
                        if (n.objectType === "Port") {
                            var pp = _getRelatedPorts(n);
                            for (var i = 0; i < pp.length; i++) {
                                edges[pp[i].p.getFullId()] = edge;
                            }

                            if (!strict)
                                edges[n.getNode().id] = edge;
                        }
                        edges[nId] = edge;
                    };

                for (var i = 0; i < graph.vertices.length; i++) {
                    var v = graph.vertices[i], p = v.getPorts();
                    _vertices.push(v);
                    var nodeData = {v: v, i: _vertices.length - 1};
                    portMap[v.id] = [];
                    _setDist(v, Infinity);

                    for (var j = 0; j < p.length; j++) {
                        _vertices.push(p[j]);
                        nodeFromPortMap[p[j].getFullId()] = nodeData;
                        portMap[v.id].push({p: p[j], i: _vertices.length - 1});
                        _setDist(p[j], Infinity);
                    }
                }

                if (source == null) source = graph.getVertex(params.sourceId);
                if (target == null) target = graph.getVertex(params.targetId);
                if (source == null || target == null) return retVal;
                // save the nodes. source/target might be a port.
                var sourceNode = source, targetNode = target;
                // if source and/or target is a port, get the underlying Node.
                if (source.getNode) sourceNode = source.getNode();
                if (target.getNode) targetNode = target.getNode();

                _setDist(source, 0);

                var completedNodes = new Array(graph.vertices.length),
                    completed = 0,
                    processEdges = function (nodeInfo, _edges, edgeSelector, neighbourSelector) {
                        for (var i = 0; i < _edges.length; i++) {
                            var edge = _edges[i];
                            if (edgeSelector(edge)) {

                                var neighbour = neighbourSelector(edge),
                                    neighbourObject = neighbour.tp || neighbour.tn,
                                    nid = _getId(neighbourObject);

                                var alt = _getDist(nodeInfo.node) + edge.getCost(),
                                    d = _getDist(neighbourObject);

                                if (alt < d) {
                                    _setDist(neighbourObject, alt);
                                    _setPrevious(neighbourObject, nid, nodeInfo);
                                    _setEdge(neighbourObject, nid, edge);
                                }
                            }
                        }
                    };

                while (completed < _vertices.length) {
                    var curNodeInfo = _findSmallestDist(_vertices, completedNodes, dist, _getId, _getDist),
                        curObjectId = curNodeInfo.node ? _getId(curNodeInfo.node) : null;

                    if (!curNodeInfo.node || _getDist(curNodeInfo.node) == Infinity) break;

                    if (target && (curObjectId == _getId(target) || (!strict && curNodeInfo.node.isChildOf && curNodeInfo.node.isChildOf(target)))) {
                        retVal.path = _findPath(dist, previous, edges, target, _getId);
                        retVal.pathDistance = retVal.path[retVal.path.length - 1].cost;
                        if (!processAll) break;
                    }
                    completedNodes[curNodeInfo.index] = true;
                    completed = completed + 1;
                    // here we get all edges for the node - port and all, and the edge selector function
                    // filters out edges for which this node is not the source. It also uses the current
                    // edgeFilter function, if one is set.
                    processEdges(curNodeInfo, curNodeInfo.node.getAllEdges(),
                        function (e) {
                            if (edgeFilter && !edgeFilter(e)) return false;
                            return !e.isDirected() ||
                                (curNodeInfo.node == e.source) ||
                                (!strict && e.source.isChildOf && e.source.isChildOf(curNodeInfo.node));
                        },
                        // this is the neighbourSelector for some edge. it returns [targetNode, targetPort]
                        // if the current node/port is the source, or source info otherwise.
                        function (e) {
                            var sn = e.source.getNode ? e.source.getNode() : e.source,
                                sp = e.source.getNode ? e.source : null,
                                tn = e.target.getNode ? e.target.getNode() : e.target,
                                tp = e.target.getNode ? e.target : null;

                            return (e.source == curNodeInfo.node || (!strict && e.source.isChildOf && e.source.isChildOf(curNodeInfo.node))) ? {tn: tn, tp: tp} : {tn: sn, tp: sp};
                        });
                }
                // the shortcut exit does not get here; this function returns two different types of value!
                return retVal;
            }
        };


}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumbToolkit
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * Licensed under the GPL2 license.  This software is not free.
 *
 * @desc Higher level functionality built on top of jsPlumb.  This script provides various layout/ui generation
 * algorithms such as tree generation, force directed graph layout, shortest path calculations, animations etc.
 *
 */

;
(function () {

    "use strict";

    var root = this;

    var JUTIL = root.jsPlumbUtil;
    var JSP = root.jsPlumb;
    var UTIL = root.jsPlumbToolkitUtil;
    var GRAPH = root.jsPlumbGraph;

    var DEFAULT_TYPE_PROPERTY = "type";
    var DEFAULT_TYPE = "default";
    var DEFAULT_ID_PROPERTY = "id";

    var // This is the default function the jsPlumb Toolkit will use to derive an ID for some piece of JSON representing a node.  It looks
    //for an 'id' member in the JSON.
        _defaultGetId = function (data) {
            return data.id;
        },
    // This is the default function the jsPlumb Toolkit will use to derive a type for some piece of JSON representing a node.  It looks
    // for a 'type' member in the JSON.
        _defaultGetType = function (data) {
            return data.type || "default";
        };


    /**
     * An instance of the jsPlumb Toolkit.  Each instance is backed by a `Graph`, and has zero or more `Renderer`s attached.
     *
     * #### Creating an instance
     * You create an instance of the jsPlumb Toolkit via the static method `jsPlumbToolkit.newInstance(params)`. The contents of `params` are
     * any valid constructor parameters as detailed here.
     * #### Rendering data
     * An instance of the jsPlumb Toolkit does not itself handle rendering the data to your UI; to do that, you must call the `render`
     * method of your Toolkit instance:
     * ```
     * var myToolkit = jsPlumbToolkit.newInstance();
     * var aRenderer = myToolkit.render({
     *   container:"someElementId",
     *   ...other params, possibly..
     * });
     * ```
     * #### Operating on the dataset
     * In general, you will operate on the dataset via the `jsPlumbToolkitInstance` object, because any attached `Renderers` will
     * for the most part sort themselves out based on the data model. Occasionally you will want to perform some view-specific
     * operation such as highlighting a Path, or hiding some Nodes, etc.  These sorts of operations are executed on the
     * `Renderer` and not on the Toolkit object.
     *
     * @class jsPlumbToolkitInstance
     * @constructor
     * @param {Object} params Constructor parameters
     * @param {Function} [params.idFunction] Optional function to use to extract an id from a Node's data. The default
     * is to retrieve the `id` property.
     * @param {Function} [params.typeFunction] Optional function to use to extract a type identifier from a Node's data.
     * The default is to retrieve the property defined by `typeProperty`.
     * @param {Function} [params.typeProperty="type"] Optional name of the property that identifies a Node's type from its data.
     * The default is `type`.
     * @param {Function} [params.edgeIdFunction] Optional function to use to extract an id from an Edge's data. The
     * default is to retrieve the `id` property.
     * @param {Function} [params.edgeTypeFunction] Optional function to use to extract a type identifier from an Edge's data.
     * The default is to retrieve the property defined by `edgeTypeProperty`.
     * @param {Function} [params.edgeTypeProperty="type"] Optional name of the property that identifies an Edge's type from its data.
     * The default is `type`.
     * @param {Function} [params.portIdFunction] Optional function to use to extract an id from a Port's data. The
     * default is to retrieve the `id` property.
     * @param {Function} [params.portTypeFunction] Optional function to use to extract a type identifier from a Port's
     * data. The default is to retrieve the `type` property.
     * @param {Object} [params.model] Model of Node, Edge and Port definitions.  See documentation.
     * @param {Function} [params.beforeConnect] Optional function that will be called prior to any edge being
     * established (either programmatically or via the mouse). It is passed the (source, target) of the proposed edge
     * and if it returns anything other than boolean true, the edge is aborted.
     * If not supplied, the default behaviour of this function is to honor the `allowLoopback`, `allowNodeLoopback`
     * and `maxConnections` parameters on any Node or Port definitions you supplied to this Toolkit via the `model`.
     * @param {Function} [params.beforeMoveConnection] Optional function that will be called prior to any existing edge
     * being moved (either programmatically or via the mouse). It is passed the source and target of the existing edge,
     * as well as the edge itself, and if it returns anything other than boolean true, the edge move is aborted.
     * If not supplied, the default behaviour of this function is to honor the `allowLoopback`, `allowNodeLoopback` and
     * `maxConnections` parameters on any Node or Port definitions you supplied to this Toolkit via the `model`.
     * @param {Function} [params.beforeStartConnect] Optional function that will be called prior to an edge being
     * established. This is different from `beforeConnect` in that this function is called right at the beginning of a
     * connection drag by attached renderers, and the function is given the node/port that is the source, plus the edge
     * type. If you return false the Edge is aborted. Otherwise your return value is used as the Edge data.
     * @param {Function} [params.beforeDetach] Optional function that can be used to override connection detachment from
     * the mouse. The function is given (source, target, edge) and is expected to return true to confirm the detach
     * should occur. Any other return value will abort the detach.
     * @param {Function} [params.beforeStartDetach] Optional function that can be used to override connection detachment
     * from the mouse. Distinct from `beforeDetach` in that this function is called as soon as the user begins to drag.
     * The function is given (source, target, edge) and is expected to return true to confirm the detach should occur.
     * Any other return value will abort the detach.
     * @param {Function} [params.nodeFactory] Function to use to generate data for a new Node. Default is to create an
     * object with an `id` property.
     * @param {Function} [params.edgeFactory] Function to use to generate data for a new Edge. Default is to create an
     * object with an `id` property.
     * @param {Function} [params.portFactory] Function to use to generate data for a new Port. Default is to create an
     * object with an `id` property.
     * @param {Function} [params.groupFactory] Function to use to generate data for a new Group. Default is to create an
     * object with an `id` property.
     * @param {Function} [params.portExtractor] Optional function to call whenever a Node is added; it extracts, from
     * the Node's data, any Ports that are associated with the Node.
     * @param {Boolean} [params.autoSave=false] Whether or not to automatically save the dataset when changes occur. You
     * must supply the `saveUrl` property if you set this to true.
     * @param {String} [params.saveUrl] Url to use when saving automatically.
     * @param {Object} [params.saveHeaders] Optional HTTP headers to pass when auto saving. If not provided the Toolkit
     * will use its default of `Content-Type:"application/json"`.
     * @param {Function} [params.onAutoSaveSuccess] Optional function to call on autoSave success.
     * @param {Function} [params.onAutoSaveError] Optional function to call on autoSave error.
     * @param {Boolean} [params.doNotUpdateOriginalData=false] If true, won't try to update the original data when a
     * Node/Edge is removed.
     * @param {Integer} [params.maxSelectedEdges] Optional limit for the number of edges allowed to be selected at any
     * one time.
     * @param {Integer} [params.maxSelectedNodes] Optional limit for the number of nodes allowed to be selected at any
     * one time.
     * @param {Integer} [params.selectionCapacityPolicy] Optional selection capacity policy. See
     * `setSelectionCapacityPolicy` docs.
     * @param {Boolean} [params.createMissingGroups=false] If true, when a Node is added that has a `group` data member that
     * identifies a Group not known by the Toolkit, a Group with that ID is created.
     */
    root.jsPlumbToolkitInstance = function (params) {

        params = params || {};

        var _idFunction = params.idFunction || _defaultGetId,
            _typeProperty = params.typeProperty || DEFAULT_TYPE_PROPERTY,
            _edgeTypeProperty = params.edgeTypeProperty || DEFAULT_TYPE_PROPERTY,
            _portTypeProperty = params.portTypeProperty || DEFAULT_TYPE_PROPERTY,
            _typeFunction = params.typeFunction || function(d) { return d[_typeProperty] || DEFAULT_TYPE; },
            _edgeIdFunction = params.edgeIdFunction || _idFunction,
            _edgeTypeFunction = params.edgeTypeFunction || function(d) { return d[_edgeTypeProperty] || DEFAULT_TYPE; },
            _portIdFunction = params.portIdFunction || _idFunction,
            _portTypeFunction = params.portTypeFunction || function(d) { return d[_portTypeProperty] || DEFAULT_TYPE; },
            _portExtractor = params.portExtractor,
            _currentInstance = this,
            _suspendGraph = false,
            debugEnabled = false,
            _model = params.model || {},
            _defaultObjectFactory = function (type, data, callback) {
                data = data == null || !JUTIL.isObject(data) ? {} : data;
                data = JUTIL.clone(data);
                data.id = data.id || UTIL.uuid();
                data.type = data.type || (type == null ? null : type.type || type);
                callback(data);
            },
            _nodeFactory = params.nodeFactory || _defaultObjectFactory,
            _edgeFactory = params.edgeFactory || _defaultObjectFactory,
            _portFactory = params.portFactory || _defaultObjectFactory,
            _groupFactory = params.groupFactory || _defaultObjectFactory,
            autoSave = params.autoSave && params.saveUrl,
            saveUrl = params.saveUrl,
            saveHeaders = params.saveHeaders,
            onAutoSaveSuccess = params.onAutoSaveSuccess || function () { },
            onAutoSaveError = params.onAutoSaveError || function () { },
            doNotUpdateOriginalData = params.doNotUpdateOriginalData === true,
            onBeforeAutoSave = params.onBeforeAutoSave || function() {},
            onAfterAutoSave = params.onAfterAutoSave || function() {},
            graphParams = {
                portSeparator: params.portSeparator,
                defaultCost: params.defaultCost,
                defaultDirected: params.defaultDirected,
                enableSubgraphs: params.enableSubgraphs
            },
            createMissingGroups = params.createMissingGroups === true;

        JUTIL.EventGenerator.apply(this, arguments);
        var _graph = new GRAPH.Graph(graphParams);
        if (autoSave) {
            new UTIL.AutoSaver(this, saveUrl, saveHeaders, onAutoSaveSuccess, onAutoSaveError, onBeforeAutoSave, onAfterAutoSave);
        }

        // catch all event handler fires 'dataUpdated' for lots of events.
        new UTIL.CatchAllEventHandler(this);

        /**
         * Gets the current NodeFactory.
         * @return {Function} Current Node Factory; see documentation for a discussion.
         */
        this.getNodeFactory = function () {
            return _nodeFactory;
        };
        /**
         * Gets the current GroupFactory.
         * @return {Function} Current Group Factory; see documentation for a discussion.
         */
        this.getGroupFactory = function () {
            return _groupFactory;
        };
        /**
         * Gets the current EdgeFactory.
         * @return {Function} Current Edge Factory; see documentation for a discussion.
         */
        this.getEdgeFactory = function () {
            return _edgeFactory;
        };
        /**
         * Gets the current PortFactory.
         * @method getPortFactory
         * @return {Function} Current Port Factory; see documentation for a discussion.
         */
        this.getPortFactory = function () {
            return _portFactory;
        };
        /**
         * Sets the current NodeFactory.
         * @method setNodeFactory
         * @param {Function} f Node factory to set as current.
         * @return {Function} Node Factory to use; see documentation for a discussion.
         */
        this.setNodeFactory = function (f) {
            _nodeFactory = f;
        };
        /**
         * Sets the current GroupFactory.
         * @method setGroupFactory
         * @param {Function} f Group factory to set as current.
         * @return {Function} Group Factory to use; see documentation for a discussion.
         */
        this.setGroupFactory = function (f) {
            _groupFactory = f;
        };
        /**
         * Sets the current EdgeFactory.
         * @return {Function} Edge Factory to use; see documentation for a discussion.
         */
        this.setEdgeFactory = function (f) {
            _edgeFactory = f;
        };
        /**
         * Sets the current PortFactory.
         * @return {Function} Port Factory to use; see documentation for a discussion.
         */
        this.setPortFactory = function (f) {
            _portFactory = f;
        };

        this.setDebugEnabled = function (d) {
            debugEnabled = d;
        };
        this.isDebugEnabled = function () {
            return debugEnabled;
        };

        /**
         * Gets the model registered with this Toolkit instance, if any. Models may be registered on the Toolkit or on each individual
         * Surface. In general it is a good idea to use the Toolkit's model to map data model event handlers and other data model considerations
         * such as the maximum number of connections a Port allows, and each Surface's model definition to configure view concerns.
         * @method getModel
         * @return {Object} Current model. May be null.
         */
        this.getModel = function () {
            return _model || {};
        };

        var _internalModel, _getModel = function() {
            if (_internalModel == null)
                _internalModel = new root.jsPlumbToolkit.Model(_model || {});
            return _internalModel;
        };

        var _defaultConnectHandler = function(source, target) {
            if (_model == null) return true; // shortcut for setups where there is no model on the toolkit.
            var st = this.getType(source), tt = this.getType(target),
                p = _getModel(),
                sn = source.getNode ? source.getNode() : source,
                tn = target.getNode ? target.getNode() : target,
                sd = source.objectType == "Node" ? p.getNodeDefinition(st) : p.getPortDefinition(st),
                td = target.objectType == "Node" ? p.getNodeDefinition(tt) : p.getPortDefinition(tt),
                snt = this.getNodeType(sn),
                tnt = this.getNodeType(tn),
                snd = p.getNodeDefinition(snt),
                tnd = p.getNodeDefinition(tnt);

            // maxConnections
            if (sd.maxConnections != null) {
                if (source.getEdges().length >= sd.maxConnections) return false;
            }

            if (td.maxConnections != null) {
                if (target.getEdges().length >= td.maxConnections) return false;
            }

            // it's loopback if the source is the same as the target (whether they be nodes or ports).
            if (source == target) {
                return !(snd.allowLoopback === false || sd.allowLoopback === false|| td.allowLoopback === false || tnd.allowLoopback === false);
            }

            // it's nodeLoopback if the source node is the same as the target node.
            if (sn == tn) {
                return !(snd.allowNodeLoopback === false|| sd.allowNodeLoopback === false || td.allowNodeLoopback === false || tnd.allowNodeLoopback === false);
            }

            return true;
        }.bind(this);

        this.beforeConnect = params.beforeConnect || _defaultConnectHandler;
        this.beforeMoveConnection = params.beforeMoveConnection || _defaultConnectHandler;

        this.beforeStartConnect = params.beforeStartConnect || function(obj, edgeType) {
            return { };
        };

        this.beforeDetach = params.beforeDetach || function(source, target, edge) {
            return true;
        };

        this.beforeStartDetach = params.beforeStartDetach || function(nodeOrPort, edge) {
            return true;
        };

        this.setSuspendGraph = function (v) {
            _suspendGraph = v;
        };

        /**
         * Sets whether or not the original dataset will be updated whenever a node/edge is removed or added. This functionality is suspended
         * when a `load` operation is taking place. Note that for this functionality to work there must be a `manager` registered for the given
         * data type in jsPlumbToolkitIO. The Toolkit ships with a manager for the default `json` datatype, but if you have your own custom
         * datatype you will need to provide one of these to support this functionality. See the documentation on data loading for a full
         * discussion.
         * @param {Boolean} update True if you want the backing data to be updated, false otherwise.
         */
        this.setDoNotUpdateOriginalData = function (update) {
            doNotUpdateOriginalData = update;
        };

        /**
         * Returns the type function that is currently in use.
         * @return {Function} Function currently being used to determine types of nodes from their data. The default is to look for a `type` member in the data.
         */
        this.getTypeFunction = function () {
            return _typeFunction;
        };

        /**
         * Connects two nodes/ports (or a combination of the two), by ID.  This function does not know about the DOM: tou cannot pass it DOM elements
         * or selectors. By default, this method will create nodes that are missing. Port ids are specified with a dotted syntax, eg `foo.bar` refers
         * to the port "bar" on the node "foo".
         * @method connect
         * @param {Object} params Connect parameters.
         * @param {Object|String} params.source Either the data for a node, or a node id as a string, representing the source node in the connection.
         * @param {Object|String} params.target Either the data for a node, or a node id as a string, representing the target node in the connection
         * @param {Number} [params.cost=1] Optional; the cost of the connection.
         * @param {Boolean} [params.directed=false] Optional, defaults to false. Whether the edge is directed.
         * @param {Boolean} [params.doNotCreateMissingNodes=false] Optional, defaults to false. Whether to NOT create nodes that do not exist yet. Sorry about the double negative.
         * @param {Object} [params.data] Optional backing data for the Edge. Here you might like to set id:'some value' if you need o retrieve the Edge by id later on.
         * @return {Edge} The new Edge.
         */
        this.connect = function (params) {
            params = params || {};
            var edge;
            if (!_suspendGraph) {
                var sv = _graph.getVertex(params.source),
                    tv = _graph.getVertex(params.target),
                    cost = params.cost,
                    directed = params.directed;

                if (!sv) {
                    if (!params.doNotCreateMissingNodes) {
                        sv = _graph.addVertex(params.source);
                        _currentInstance.fire("nodeAdded", { data: {}, node: sv });
                    }
                    else
                        return;  // probaby better to throw here? but maybe not.
                }

                if (!tv) {
                    if (!params.doNotCreateMissingNodes) {
                        tv = _graph.addVertex(params.target);
                        _currentInstance.fire("nodeAdded", { data: {}, node: tv });
                    }
                    else
                        return;
                }

                var _continue = this.beforeStartConnect(sv, _edgeTypeFunction(params.data || {}));
                if (_continue) {
                    var data = params.data || {};
                    if (typeof _continue === "object") JSP.extend(data, _continue);
                    var _reallyContinue = this.beforeConnect(sv, tv, data);
                    if (_reallyContinue !== false) {
                        edge = _graph.addEdge({source: sv, target: tv, cost: cost, directed: directed, data: data});
                        _currentInstance.fire("edgeAdded", {edge: edge});
                    }
                }
            }

            return edge;
        };

        /**
         * Clears the graph, then fires a `graphCleared` event.
         * @method clear
         * @return {jsPlumbToolkitInstance} The current Toolkit instance.
         */
        this.clear = function () {

            this.fire("graphCleared");
            _graph.clear();
            return this;
        };

        /**
         * Returns the current Graph.
         * @method getGraph
         * @return {Graph} The underlying Graph.
         */
        this.getGraph = function () {
            return _graph;
        };

        /**
         * Returns the count of nodes in the Graph.
         * @method getNodeCount
         * @return {Number} The count of Nodes in the Graph.
         */
        this.getNodeCount = function () {
            return _graph.getVertexCount();
        };

        /**
         * Returns the Node at the given index.
         * @method getNodeAt
         * @return {Object} The Node at the given index, null if not found.
         */
        this.getNodeAt = function (idx) {
            return _graph.getVertexAt(idx);
        };

        /**
         * Returns all the nodes in the Graph.
         * @method getNodes
         * @return {Node[]} All the Nodes in the graph.
         */
        this.getNodes = function () {
            return _graph.getVertices();
        };

        /**
         * Iterates through all Nodes in the Toolkit one at a time. You should not perform destructive editing of
         * the dataset inside one of these loops.
         * @method eachNode
         * @param {Function} fn A function that takes (index, node) as arguments and is applied for every Node in the Toolkit instance.
         */
        this.eachNode = function (fn) {
            var v;
            for (var i = 0, j = _graph.getVertexCount(); i < j; i++) {
                v = _graph.getVertexAt(i);
                fn(i, v);
            }
        };

        /**
         * Iterates through all Groups in the Toolkit one at a time. You should not perform destructive editing of
         * the dataset inside one of these loops.
         * @method eachGroup
         * @param {Function} fn A function that takes (index, node) as arguments and is applied for every Node in the Toolkit instance.
         */
        this.eachGroup = function (fn) {
            var v;
            for (var i = 0, j = _graph.getGroupCount(); i < j; i++) {
                v = _graph.getGroupAt(i);
                fn(i, v);
            }
        };

        /**
         * Iterates through all Edges in the Toolkit one at a time. You should not perform destructive editing of
         * the dataset inside one of these loops.
         * @method eachEdge
         * @param {Function} fn A function that takes (index, edge) as arguments and is applied for every Node in the Toolkit instance.
         */
        this.eachEdge = function (fn) {
            var e = _graph.getEdges();
            for (var i = 0, j = e.length; i < j; i++) {
                fn(i, e[i]);
            }
        };

        /**
         * Returns the total number of Edges.
         * @method getEdgeCount
         * @return {Number} The total number of Edges in the Graph.
         */
        this.getEdgeCount = function () {
            return _graph.getEdgeCount();
        };

        /**
         * Returns the total number of Groups
         * @method getGroupCount
         * @returns {Number} The total number of Groups in the Graph.
         */
        this.getGroupCount = function() {
            return _graph.getGroupCount();
        };

        /**
         * Returns the Group at the given index.
         * @method getGroupAt
         * @param {Number} idx Index into group list
         * @returns {Group} a Group, or null if not found.
         */
        this.getGroupAt = function(idx) {
            return _graph.getGroupAt(idx);
        };

        /**
         * Calculates "clusters" of nodes (and groups), where a 'cluster' is a set of Nodes/Groups that
         * are connected. Direction of connections is not taken into account. Nodes that are children of Groups are
         * included in all cluster calculations, which might cause some weird situations, but this functionality
         * is mostly intended just for Nodes anyway.
         * @returns {Array} An array of arrays, each entry being a list of nodes in the cluster.
         */
        this.getClusters = function() { return _graph.getClusters(); }

        /**
         * Gets the id of the Node represented by the given arguments. If this is a JS object, we extract the id using the
         * current idFunction. Otherwise we just pass it back as-is.
         * @method getNodeId
         * @param {Object} node Object from which to retrieve id.
         * @return {String} The Node's id, if the current idFunction was able to resolve it, or the given object.
         */
        this.getNodeId = function (node) {
            return JUTIL.isObject(node) ? _idFunction(node) : node;
        };


        /**
         * Gets the type of the Node represented by the given JS object. We first try for a return value from the current typeFunction,
         * but if that returns nothing we just return 'default'.
         * @method getNodeType
         * @param {Object} nodeData  Node's data. Note: this is NOT a Node object, it is the backing data. You can use
         * `getType` to get the type for some Toolkit object.
         * @return {String} Either the object's type, or `default`.
         */
        this.getNodeType = function (nodeData) {
            return _typeFunction(nodeData) || "default";
        };

        /**
         * Gets the id of the Edge represented by the given arguments. If this is a JS object, we extract the id using the
         * current edgeIdFunction. Otherwise we just pass it back as-is.
         * @method getEdgeId
         * @param {Object} edge Edge from which to retrieve id.
         * @return {String} Edge's id, if we could resolve it, otherwise the object we were given.
         */
        this.getEdgeId = function (edge) {
            return JUTIL.isObject(edge) ? _edgeIdFunction(edge) : edge;
        };

        /**
         * Gets the type of the Edge represented by the given JS object.
         * @method getEdgeType
         * @param {Object} edgeData Edge's data. Note: this is NOT an Edge object, it is the backing data. You can use
         * `getType` to get the type for some Toolkit object.
         * @return {String} Either the Edge's type, if set, or "default".
         */
        this.getEdgeType = function (edgeData) {
            return _edgeTypeFunction(edgeData) || "default";
        };

        /**
         * Gets the id of the Port represented by the given arguments. If this is a JS object, we extract the id using the
         * current portIdFunction. Otherwise we just pass it back as-is.
         * @method getPortId
         * @return {String} Port's id, if we could resolve it, otherwise the object we were given.
         */
        this.getPortId = function (port) {
            return JUTIL.isObject(port) ? _portIdFunction(port) : port;
        };

        /**
         * Gets the type of the Port represented by the given JS object
         * @method getPortType
         * @return {String} Either the port's type, if set, or "default".
         */
        this.getPortType = function (port) {
            return _portTypeFunction(port) || "default";
        };

        /**
         * Gets the type of the given Object. This is not a type such as `Node`, `Port` or `Edge` - this is the type of the
         * object as defined by your system to identify types; these are the types used to lookup objects in the view.
         * @param obj
         * @returns {String} The object's type.
         */
        this.getType = function(obj) {
            var m = obj.objectType === "Node" ? _typeFunction : obj.objectType === "Port" ? _portTypeFunction : _edgeTypeFunction;
            return m(obj.data) || "default";
        };

        /**
         * Sets the type of the given object. This will do two things:
         * 1. update the appropriate propprty in the object's data to this new value. You can set what properties define
         * types, but by default each of Node, Edge and Port use `type` as the property that indicates their type.
         * 2. attempt to apply a type definition for the new type, if one is found. NB this only applies to Edge objects,
         * as at version 1.1.0. Support for Nodes (including switching node templates) is a possible future enhancement.
         * @param obj
         * @param type
         */
        this.setType = function(obj, type) {
            var currentType = this.getType(obj);
            if (currentType === type) return;
            var m = obj.objectType === "Node" ? _typeProperty: obj.objectType === "Port" ? _portTypeProperty : _edgeTypeProperty,
                evt = obj.objectType.charAt(0).toLowerCase() + obj.objectType.substring(1) + "TypeChanged";
            obj.data[m] = type;
            this.fire(evt, {
                obj:obj,
                previousType:currentType,
                newType:type
            });
        };

        /**
         * Adds a Node with the given data. If the data is null, the Toolkit creates an empty object and assigns
         * a uuid as the Node's id.  If no id can be derived for the given data, the Toolkit creates a uuid and
         * sets it as the data object's 'id' member. This method also calls the current `portExtractor` function, if
         * one was supplied. Its purpose is to extract any Ports from the data for some given Node.
         * @method addNode
         * @param {Object} data The Node's backing data - from your data model.
         * @param {Object} [eventInfo] Optional data member that the Toolkit will pass into any registered event listeners. This can be used
         * by the UI layer, for instance, to track the position on screen of any newly added elements.
         * @return {Node} A Node object.  Your original data is available via the `data` member. The Node's id is available via the `id` member.
         */
        this.addNode = function (data, eventInfo, doNotFireEvent) {
            var id = _idFunction(data);
            // assign an id if one was not supplied.
            if (id == null && (typeof data) !== "string") {
                data.id = UTIL.uuid();
            }

            var v = _graph.addNode(data, _idFunction);
            if (v != null) {

                // optionally extract port information
                if (_portExtractor != null) {
                    var ports = _portExtractor(v.data, v);
                    if (ports != null) {
                        for (var i = 0; i < ports.length; i++)
                            v.addPort(ports[i]);
                    }
                }

                // is the node a member of a group?
                if (typeof data !== "string" && data.group != null) {
                    var g = this.getGroup(data.group);
                    if (g == null && createMissingGroups) {
                        g = _graph.addGroup(data.group);
                    }
                    if (g != null) {
                        g.addVertex(v);
                    }
                }

                if (!_dataLoading && !doNotUpdateOriginalData)
                    root.jsPlumbToolkitIO.manage("addNode", _originalData, _originalDataType, v, _idFunction || _graph.getIdFunction(), _currentInstance);

                // if not null, it didnt exist. fire event and return. Pass in the optional eventInfo params here to the listener.
                if (!doNotFireEvent) {
                    _currentInstance.fire("nodeAdded", {data: data, node: v, eventInfo: eventInfo});
                }

                return v;
            }
            else
            // otherwise get the existing node.
                return _graph.getNode(id);
        };

        /**
         * Adds a Node by type, running the data generation for the node through the current NodeFactory.  This is
         * different from `addNode` in that with `addNode` you are supplying the final data and your NodeFactory is
         * not called. This method can be called with one, two or three arguments. A single argument is considered to be
         * the new Node's `type`, and a backing data object will be created with this set, and no callback will occur.
         * If you provide two arguments the second argument may be either the new Node's backing data OR a callback to
         * hit with the newly created Node. With three arguments the second argument is the Node's backing data and the
         * third is a callback to hit with the newly created Node.
         * @method addFactoryNode
         * @param {String} type Required. Type of the object to create. `type` will be passed as the first argument to your node factory.
         * @param {Object} data Optional backing data for the Node.
         * @param {Function} callback Optional function to call with the newly created Node.
         */
        this.addFactoryNode = function(type, data, callback) {
            data = arguments.length == 2 && (arguments[1] == null || typeof arguments[1] === "object") ? arguments[1]: {};
            callback = arguments.length == 3 ? arguments[2] : typeof arguments[1] == "function" ? arguments[1] : null;
            data.type = data.type || type;
            _nodeFactory(type, data, function(n) {
                var node = this.addNode(n);
                if (callback) { callback(node); }
            }.bind(this));
        };

        /**
         * Adds a list of Nodes.
         * @method addNodes
         * @param {Array} nodeList An array of objects, one for each Node to be added.
         * @return {jsPlumbToolkitInstance} The current Toolkit instance.
         */
        this.addNodes = function (nodeList) {
            for (var i = 0; i < nodeList.length; i++) {
                _currentInstance.addNode.apply(_currentInstance, [ nodeList[i] ]);
            }
            return _currentInstance;
        };

        /**
         * Adds a new Group.
         * @method addGroup
         * @param {Object} data Backing data for the Group.
         * @param {Object} [eventInfo] Used internally, sometimes, by the Toolkit.
         * @param {Boolean} [doNotFireEvent=false] If true, a `groupAdded` event will not be fired by this method.
         * Otherwise a `groupAdded` event will be fired.
         */
        this.addGroup = function(data, eventInfo, doNotFireEvent) {
            var id = _idFunction(data);
            // assign an id if one was not supplied.
            if (id == null && (typeof data) !== "string") {
                data.id = UTIL.uuid();
            }

            var g = _graph.addGroup(data, _idFunction);
            if (!_dataLoading && !doNotUpdateOriginalData)
                root.jsPlumbToolkitIO.manage("addGroup", _originalData, _originalDataType, g, _idFunction || _graph.getIdFunction(), _currentInstance);

            // if not null, it didnt exist. fire event and return. Pass in the optional eventInfo params here to the listener.
            if (!doNotFireEvent) {
                _currentInstance.fire("groupAdded", {data: data, group: g, eventInfo: eventInfo});
            }

            return g;
        };

        /**
         * Adds a Node to a Group.
         * @method addToGroup
         * @param {Node} node Node to add
         * @param {Group} group Group to add the Node to
         */
        this.addToGroup = function(node, group) {
            var added = false;
            node = _currentInstance.getNode(node);
            group = _currentInstance.getGroup(group);
            if (node && group) {
                added = group.addVertex(node);
                if (added) {
                    node.data.group = group.id;
                    _currentInstance.fire("group:addMember", { node: node, group: this.getGroup(group) });
                    _currentInstance.fire("dataUpdated");
                }
            }
            return added;
        };

        /**
         * Removes a Node from a Group.
         * @method removeFromGroup
         * @param {Node} node Node to remove
         * @param {Boolean} [doNotFireEvent=false] If true, a `group:removeMember` event will not be fired as a result of
         * this operation. Otherwise it will.
         */
        this.removeFromGroup = function(node, doNotFireEvent) {
            node = _currentInstance.getNode(node);
            var group;
            if (node && node.group) {
                group = node.group;
                group.deleteVertex(node);
                delete node.data.group;
                if (!doNotFireEvent) {
                    _currentInstance.fire("group:removeMember", { node:node, group:group });
                }
                _currentInstance.fire("dataUpdated");
            }
            return group;
        };

        /**
         * Removes the given Group from the dataset.
         * @param {Group} group Group to remove.
         * @param {Boolean} [removeChildNodes=false] If true, Nodes that are members of the Group will also be
         * removed.
         * @param {Boolean} [doNotFireEvent=false] If true, a `groupRemoved` will not be fired as a result of this
         * operation. Otherwise it will.
         */
        this.removeGroup = function(group, removeChildNodes, doNotFireEvent) {
            var g = _graph.deleteGroup(group, removeChildNodes);
            if (g) {
                if (!_dataLoading && !doNotUpdateOriginalData)
                    root.jsPlumbToolkitIO.manage("removeGroup", _originalData, _originalDataType, g, _idFunction || _graph.getIdFunction(), _currentInstance);

                if (!doNotFireEvent) {
                    _currentInstance.fire("groupRemoved", {group: g, removeChildNodes: removeChildNodes});
                }
            }
        };

        /**
         * Gets a Node by id, or if the given object is already a Node, hands that back.
         * @method getNode
         * @param {String} nodeId ID of the Node to retrieve.
         * @return {Node} The requested Node, if found, otherwise null.
         */
        this.getNode = function (nodeId) {
            return _graph.getVertex(nodeId);
        };

        /**
         * Gets an Edge by id, or if the given object is already an Edge, hands that back.
         * @method getEdge
         * @param {String} edgeId ID of the Edge to retrieve.
         * @return {Edge} The requested Edge, if found, otherwise null.
         */
        this.getEdge = function (edgeId) {
            return _graph.getEdge(edgeId);
        };

        /**
         * Gets a Group by its ID, or if the object is already a Group, hands that back.
         * @param groupId
         * @returns {Group} The requested Group, if found, otherwise null.
         */
        this.getGroup = function(groupId) {
            return _graph.getGroup(groupId);
        };

        /**
         * Returns whether or not object(s) exist for the given id(s).
         * @method exists
         * @param {Object...} objects List of ids to check existence for.  This method takes an arbitrary number of arguments.
         * @return {Boolean} True if objects exist for all given ids, false otherwise.
         */
        this.exists = function (objects) {
            for (var i = 0; i < arguments.length; i++) {
                if (_graph.getVertex(arguments[i]) == null) return false;
            }
            return true;
        };

        /**
         * Removes the given Node, which may be passed in as the actual Node object, or its id.
         * @method removeNode
         * @param {Node|String} node Either a Node, or its ID.
         * @return {jsPlumbToolkitInstance} The current Toolkit instance.
         */
        this.removeNode = function (node, doNotFireEvent) {
            node = (node.constructor == GRAPH.Vertex || node.constructor == GRAPH.Port) ? node : _graph.getVertex(node);
            var edges = node.getAllEdges() || [];
            for (var i = 0; i < edges.length; i++)
                _currentInstance.removeEdge(edges[i]);
            // delete the vertex from the graph.
            _graph.deleteVertex(node.id);

            // optionally, clean up the original backing data. requires that a DataManager for the current _originalDataType be registered
            // on jsPlumbToolkitIO
            if (!_dataLoading && !doNotUpdateOriginalData)
                root.jsPlumbToolkitIO.manage("removeNode", _originalData, _originalDataType, node, _idFunction || _graph.getIdFunction(), _currentInstance);

            if (!doNotFireEvent) {
                _currentInstance.fire("nodeRemoved", { node: node, nodeId: node.id, edges: edges });
            }
            return _currentInstance;
        };

        /**
         * Adds an Edge to the Graph.
         * @method addEdge
         * @param {Object} params Method params.
         * @param {Node|String} params.source Source Node, or id of the source Node. If given as a string, this may be in "dotted" format, eg. nodeId.portId, to identify a particular port on the source Node.
         * @param {Node|String} params.target Target Node, or id of the target Node. If given as a string, this may be in "dotted" format, eg. nodeId.portId, to identify a particular port on the target Node.
         * @param {Integer} [params.cost=1] Edge cost. This is used when computing shortest paths through the graph. If
         * an Edge is not `directed`, then the same cost is applied regardless of the direction of traversal.
         * @param {Boolean} [params.directed=true] Whether or not the Edge is directed.
         * @return {Edge} The Edge that was added.
         */
        this.addEdge = function (params, source, doNotFireEvent) {
            var edge = _graph.addEdge(params, _edgeIdFunction, this.beforeConnect);

            if (!_dataLoading && !doNotUpdateOriginalData)
                root.jsPlumbToolkitIO.manage("addEdge", _originalData, _originalDataType, edge, _edgeIdFunction || _graph.getIdFunction(), _currentInstance);

            if (!doNotFireEvent) {
                _currentInstance.fire("edgeAdded", {
                    edge: edge,
                    source: source,
                    geometry:params.geometry,
                    addedByMouse:params.addedByMouse
                }, null);
            }

            return edge;
        };

        /**
         * Removes an Edge from the Graph.
         * @method removeEdge
         * @param {Edge|String} edge The Edge to remove, as either an Edge object or its id.
         * @param {Object} [source] The source for the removeEdge operation. For internal use.
         * @return {jsPlumbToolkitInstance} The current Toolkit instance.
         */
        this.removeEdge = function (edge, source) {
            edge = _graph.getEdge(edge);
            if (edge != null) {
                // delete the vertex from the graph.
                _graph.deleteEdge(edge);
                // optionally, clean up the original backing data. requires that a DataManager for the current _originalDataType be registered
                // on jsPlumbToolkitIO
                if (!_dataLoading && !doNotUpdateOriginalData)
                    root.jsPlumbToolkitIO.manage("removeEdge", _originalData, _originalDataType, edge, _edgeIdFunction || _graph.getIdFunction(), _currentInstance);

                _currentInstance.fire("edgeRemoved", { edge: edge, source: source }, null);
            }
            return _currentInstance;
        };

        this.edgeMoved = function(edge, obj, index) {
            var current = edge[index === 0 ? "source" : "target"],
                fn = index == 0 ? "setSource" : "setTarget";

            return this[fn](edge, obj);
        };

        /**
         * Sets the target Node/Port for some Edge.
         * @method setTarget
         * @param {Edge} edge Edge to retarget.
         * @param {Node|Port|String} o Node/Port/id for new Edge target
         */
        this.setTarget = function (edge, o, doNotFireEvent) {
            var info = _graph.setTarget.apply(_graph, arguments);
            if (info.success !== false && !doNotFireEvent) {
                _currentInstance.fire("edgeTarget", info);
            }
            return info;
        };

        /**
         * Sets the source Node/Port for some Edge.
         * @method setSource
         * @param {Edge} edge Edge to set source for.
         * @param {Node|Port|String} o Node/Port/id for new Edge source
         */
        this.setSource = function (edge, o, doNotFireEvent) {
            var info = _graph.setSource.apply(_graph, arguments);
            if (info.success !== false && !doNotFireEvent) {
                _currentInstance.fire("edgeSource", info);
            }
            return info;
        };

        /**
         * Adds a new Port to some Node. This will call the current `PortFactory` to get the data for a new Port.
         * @method addNewPort
         * @param {Node|String} node Node or id of the Node to add a new Port to.
         * @param {String} type Type of Port to add.
         * @param {Object} [portData] Optional data to pass to the PortFactory.
         */
        this.addNewPort = function (obj, type, portData, doNotFireEvent) {
            obj = _graph.getVertex(obj);
            _portFactory({node: obj, type: type}, portData, function (p) {
                var portId = _portIdFunction(p),
                    port = obj.addPort(portId);

                port.data = p;

                if (!_dataLoading && !doNotUpdateOriginalData)
                    root.jsPlumbToolkitIO.manage("addPort", _originalData, _originalDataType, {node: obj, port: port}, _portIdFunction || _graph.getIdFunction(), _currentInstance);

                if (!doNotFireEvent) {
                    _currentInstance.fire("portAdded", { node: obj, data: p, port: port }, null);
                }
            });
        };

        /**
         * Adds a Port from existing data to some Node. This is distinct from `addNewPort`, because in this
         * case the data for the Port already exists.
         * @method addPort
         * @param {Node|String} node Node or id of the Node to add the Port to.
         * @param {Object} data Data for the Port.
         * @return {Port} The port that was added.
         */
        this.addPort = function (node, data, doNotFireEvent) {
            var p = node.addPort(data, _portIdFunction);

            if (!_dataLoading && !doNotUpdateOriginalData)
                root.jsPlumbToolkitIO.manage("addPort", _originalData, _originalDataType, {node: node, port: p}, _portIdFunction || _graph.getIdFunction(), _currentInstance);

            if (!doNotFireEvent) {
                _currentInstance.fire("portAdded", { node: node, data: data, port: p }, null);
            }
            return p;
        };

        /**
         * Removes the Port with the given id from the given Node.
         * @method removePort
         * @param {Node|String} node Either a node id, or a Node, from which the Port should be removed.
         * @param {String} portId Id of the port to remove from the given node.
         * @return {Boolean} True if the port existed and was removed, false otherwise.
         */
        this.removePort = function (node, portId, doNotFireEvent) {
            var removed = false;
            node = (node.constructor == GRAPH.Vertex || node.constructor == GRAPH.Port) ? node : _graph.getVertex(node);
            var port = node.getPort(portId);
            if (port) {
                var edges = port.getAllEdges();
                removed = node.removePort(port);
                if (removed && !doNotFireEvent) {
                    _currentInstance.fire("portRemoved", { node: node, port: port, edges: edges }, null);
                    for (var i = 0; i < edges.length; i++)
                        _currentInstance.removeEdge(edges[i]);
                }
            }
            return removed;
        };

        /**
         * Removes whatever is identified by `obj`, which may be one of a number of things.
         * @method remove
         * @param {Node|Group|Edge|Selection|Path} obj Either a Node id, a Node, a Group ID, a Group, an Edge, or
         * Selection or Path whose Nodes/Ports and Edges to remove.
         */
        this.remove = function (obj) {
            if (obj == null) return;
            var o = _currentInstance.getObjectInfo(obj), thisObj;
            _currentInstance.setSuspendRendering(true);

            try {
                if (o.obj && (o.type == "Node" || o.type == "Edge" || o.type === "Group")) {
                    _currentInstance["remove" + o.type](o.obj);
                }
                else {

                    while (obj.getNodeCount() > 0) {
                        _currentInstance.removeNode(obj.getNodeAt(0));
                    }

                    while (obj.getEdgeCount() > 0) {
                        _currentInstance.removeEdge(obj.getEdgeAt(0));
                    }

                    while (obj.getGroupCount() > 0) {
                        _currentInstance.removeGroup(obj.getGroupAt(0));
                    }
                }
            }
            finally {
                _currentInstance.setSuspendRendering(false, true);
            }
        };

        /**
         * Suspends or re-enables rendering. This method simply round-robins all the registered renderers
         * and calls `setSuspendRendering` on each of them.
         * @method setSuspendRendering
         * @param {Boolean} v True to suspend rendering, false to enable it.
         * @param {Boolean} [thenRefresh=false] If true, a refresh will be called on all renderers after rendering is unsuspended.
         */
        this.setSuspendRendering = function (v, thenRefresh) {
            for (var r in _renderersById)
                _renderersById[r].setSuspendRendering(v, thenRefresh);
        };

        /**
         * Suspends rendering and then runs the given function, unsuspending rendering afterwards and doing
         * a refresh. This method is just a convenience method that handles suspending
         * and subsequent enabling of rendering. You might use this if you're adding a whole load of Nodes or
         * Edges, or maybe you want to add a Node and one or more Edges before
         * the layout recomputes.
         * @param fn
         */
        this.batch = function (fn) {
            _currentInstance.setSuspendRendering(true);
            try {
                fn();
            }
            catch (e) {
                jsPlumbUtil.log("Error in transaction " + e);
            }
            finally {
                _currentInstance.setSuspendRendering(false, true);
            }
        };

        var _updateNodeOrPort = function (obj, updates, evtId, generator, refresh) {
            var n = _graph.getNode(obj);
            if (n && n.objectType) {
                if (updates) {
                    for (var u in updates) {
                        JUTIL.replace(n.data, u, updates[u]);
                    }
                }
                _currentInstance.fire(evtId, generator(n), null);
            }
        }.bind(this);

        /**
         * Updates the given Node, notifying any Renderers to do a redraw. If autoSave is set, this method
         * will cause the dataset to be saved.
         * @method updateNode
         * @param {Node|String|Object} node Either a Node, a Node id, or the backing data for a Node.
         * @param {Object} [updates] An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
         */
        this.updateNode = function (node, updates) {
            _updateNodeOrPort(node, updates, "nodeUpdated", function (o) {
                return { node: o, updates:updates || {} };
            });
        };

        /**
         * Updates the given Port, notifying any Renderers to do a redraw. If autoSave is set, this method
         * will cause the dataset to be saved.
         * @method updatePort
         * @param {Port|String|Object} port Either a Port, a Port id, or the backing data for a Port.
         * @param {Object} [updates] An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
         */
        this.updatePort = function (port, updates) {
            _updateNodeOrPort(port, updates, "portUpdated", function (o) {
                return { port: o, node: o.getNode(), updates:updates || {} };
            });
        };

        /**
         * Updates the given Edge, notifying any Renderers to do a redraw. If autoSave is set, this method
         * will cause the dataset to be saved.
         * @method updateEdge
         * @param {Edge|String|Object} edge Either an Edge, an Edge id, or the backing data for an Edge.
         * @param {Object} [updates] An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
         */
        this.updateEdge = function (edge, updates) {
            var e = _graph.getEdge(edge);
            if (e) {
                if (updates) {
                    for (var u in updates) {
                        if (e.data[u] == null)
                            e.data[u] = updates[u];
                        else
                            JUTIL.replace(e.data, u, updates[u]);
                    }
                }
                _currentInstance.fire("edgeUpdated", {edge: e, updates:updates || {}}, null);
            }
        };

        /**
         * Updates the given object, notifying any renderers to do a repaint.
         * @param {Node|Port|Edge|String} object Either a Node, Port or Edge, or, as a string, the id of some Node or Port.
         * @param {Object} [updates] An object with path->value pairs. Path can be in dotted notation. You do not actually have to supply this, although in most cases you will want to. But there are edge cases in which you might simply wish to kick off a repaint.
         * @return {Node|Port|Edge} The object that was updated, or null if not found.
         */
        this.update = function (object, updates) {
            if (JUTIL.isString(object)) object = this.getNode(object);
            if (object && object.objectType) {
                this["update" + object.objectType](object, updates);
            }
            return object;
        };

// ----------------- end nodes

// -------------------------- miscellaneous -------------------------------------


// -------------------------- end miscellaneous -------------------------------------

// ---------------------------- paths ------------------------------------------------

        /**
         * Gets a Path from some source Node/Port to some target Node/Port.
         * @param {Object} params Path spec params
         * @param {Node|Port|String} params.source Source node or port, or id of source node/port
         * @param {Node|Port|String} params.target Target node or port, or id of target node/port
         * @param {Boolean} [params.strict=true] Sets whether or not paths are searched strictly by the given source/target. If, for instance, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
         * @param {Function} [params.nodeFilter] Optional function that is given each Node's backing data and asked to return true or false - true means include the Node, false means exclude it.
         * @param {Function} [params.edgeFilter] Optional function that is given each Edge's backing data and asked to return true or false - true means include the Edge, false means exclude it.
         * @return {Path} a Path object. Even if no path exists you will get a return value - but it will just be empty.
         */
        this.getPath = function (params) {
            return new root.jsPlumbToolkit.Path(this, params);
        };

        /**
         * Finds the Graph object that matches the given spec.
         * @method findGraphObject
         * @param {String|Node|Port} spec If a string, a Node/Port matching that id is retrieved. Otherwise if `spec` is already a Graph object (Node or Port), it is
         * returned.
         * @return {Node|Port} Node or Port matching the spec, null if no match or spec was not a Graph object.
         */
        var _findGraphObject = this.findGraphObject = function (spec) {
            if (spec == null) return null;
            if (spec === "*") return _graph;
            else if (spec.constructor == GRAPH.Vertex || spec.constructor == GRAPH.Port)
                return spec;
            else if (JUTIL.isString(spec) || JUTIL.isObject(spec))
                return _graph.getVertex(spec);
            return null;
        };

        var _selectEdges = function (params, edgeSelector, checkForPorts) {
            params = params || {};
            var edges = [], _edgeMap = {},
                _add = function (edge) {
                    if (!_edgeMap[edge.getId()]) {
                        edges.push(edge);
                        _edgeMap[edge.getId()] = true;
                    }
                },
                _addEdges = function (obj, matchSource, matchTarget, matchElement) {
                    if (obj != null) {
                        var e = obj[edgeSelector]({filter: params.filter});
                        for (var i = 0; i < e.length; i++) {
                            var isSource = ((matchSource && obj == _graph) || e[i].source == obj || (checkForPorts && e[i].source.constructor == GRAPH.Port && e[i].source.getNode() == obj)),
                                isTarget = ((matchTarget && obj == _graph) || e[i].target == obj || (checkForPorts && e[i].target.constructor == GRAPH.Port && e[i].target.getNode() == obj));

                            if ((matchSource && isSource) || (matchTarget && isTarget) || (matchElement && (isSource || isTarget)))
                                _add(e[i]);
                        }
                    }
                };

            _addEdges(_findGraphObject(params.source), true, false, false);
            _addEdges(_findGraphObject(params.target), false, true, false);
            _addEdges(_findGraphObject(params.element), false, false, true);
            return edges;
        };

        /**
         * Gets a set of edges.
         * @method getEdges
         * @param {Object} params parameters for the select call
         * @param {Node|String} [params.source] Source Node or id of source Node from which to select Edges.
         * @param {Node|String} [params.target] Target Node or id of target Node from which to select Edges.
         * @return {Edge[]} a list of edges corresponding to the given params.
         */
        this.getEdges = function (params) {
            return _selectEdges(params, "getEdges", false);
        };

        /**
         * Get all Edges in the Toolkit instance.
         * @method getAllEdges
         * @return {Edge[]}
         */
        this.getAllEdges = function () {
            return _graph.getAllEdges();
        };

        /**
         * Gets all edges for the given Node or Port.
         * @method getAllEdgesFor
         * @param {Node|Port} obj Object to retrieve edges for.
         * @param {Function} [filter] Optional filter function for edge selection.
         * @return {Edge[]} a list of Edges.
         */
        this.getAllEdgesFor = function(obj, filter) {
            return obj.getAllEdges({filter:filter});
        };

        /**
         * Gets all edges in the Toolkit instance as a Selection object.
         * @method selectAllEdges
         * @returns {Selection}
         */
        this.selectAllEdges = function() {
            return this.filter(function(o) { return o.objectType  === "Edge"; });
        };

        /**
         * Adds all the Edges in the Toolkit instance to the Toolkit's current selection.
         * @method addAllEdgesToSelection
         */
        this.addAllEdgesToSelection = function() {
            this.addToSelection(this.getAllEdges());
        };

// ---------------------------- end paths ------------------------------------------------

// ---------------------- import /export -------------------------------

        var _originalData, _originalDataType, _dataLoading;
        var _doLoad = function(params, startEvent, endEvent) {
            params = params || {};

            var type = params.type || "json",
                data = params.data,
                url = params.url,
                jsonp = params.jsonp,
                onload = params.onload,
                parameters = params.parameters || { },
                error = params.error || function () { };

            if (data == null && url == null) {
                throw new TypeError("You must supply either data or url to load.");
            }

            var parse = function (d) {
                _originalData = d;
                _originalDataType = type;
                _dataLoading = true;
                _currentInstance.fire(startEvent);
                root.jsPlumbToolkitIO.parse(type, d, _currentInstance, parameters);
                _notifyDataLoaded(endEvent);
                if (onload) onload(_currentInstance, d);
                _currentInstance.fire("graphChanged");
            };

            // then, import the data.
            if (data) {
                parse(data);
            }
            else if (url) {
                if (jsonp) {
                    var sep = url.indexOf("?") === -1 ? "?" : "&";
                    url = url + sep + "callback=?";
                }

                var dataType = type === "json" ? type : params.dataType;
                var headers = params.headers || { Accept:"application/json" };
                UTIL.ajax({
                    url: url,
                    success: parse,
                    dataType: dataType,
                    error: error,
                    headers:headers
                });
            }

            return _currentInstance;
        };


        /**
         * Loads some data, either via ajax, or directly from a JS object.
         * @method load
         * @param {Object} params Load parameters.
         * @param {String} [params.type="json"] Specifies the data type of the data to load. This must match the name of a loader registered with the given instance of the Toolkit.
         * @param {Object} [params.data] Optional. JSON data to load directly.
         * @param {String} [params.url]  URL to retrieve data from. Optional, but you need to supply either this or `data`.
         * @param {Boolean} [params.jsonp=false] Optional, defaults to false. Tells the Toolkit that the data is coming via JSON-P.
         * @param {Function} [params.onload] Optional callback to execute once the data has loaded. Most often used when you are retrieving remote data (using `url` and possibly `jsonp`)
         * @param {Object} [params.parameters] Optional parameters to pass to the loader.
         * @param {Function} [params.error] Optional function to call on load error.
         * @param {Object} [params.headers] Optional map of HTTP header values, if loading via URL.
         * @return {jsPlumbToolkitInstance} The current instance of the Toolkit. If you provide data directly to this method you can then chain a load call with a subsequent `render`.
         */
        this.load = function (params) {
            return _doLoad(params, "dataLoadStart", "dataLoadEnd");
        };

        /**
         * Appends some data to the dataset, either via ajax, or directly from a JS object. The only difference
         * between this and `load` is the events that are fired during the loading process.
         * @method append
         * @param {Object} params Append parameters.
         * @param {String} [params.type="json"] Specifies the data type of the data to load. This must match the name of a loader registered with the given instance of the Toolkit.
         * @param {Object} [params.data] Optional. JSON data to load directly.
         * @param {String} [params.url]  URL to retrieve data from. Optional, but you need to supply either this or `data`.
         * @param {Boolean} [params.jsonp=false] Optional, defaults to false. Tells the Toolkit that the data is coming via JSON-P.
         * @param {Function} [params.onload] Optional callback to execute once the data has loaded. Most often used when you are retrieving remote data (using `url` and possibly `jsonp`)
         * @param {Object} [params.parameters] Optional parameters to pass to the loader.
         * @param {Function} [params.error] Optional function to call on load error.
         * @return {jsPlumbToolkitInstance} The current instance of the Toolkit. If you provide data directly to this method you can then chain a load call with a subsequent `render`.
         */
        this.append = function (params) {
            return _doLoad(params, "dataAppendStart", "dataAppendEnd");
        };

        /**
         * Saves the current data via ajax POST to a given URL.
         * @method load
         * @param {Object} params Load parameters
         * @param {String} [params.type="json"] Specifies the data type in which to format the data. This must match the name of an exporter registered with the given instance of the Toolkit.
         * @param {String} params.url URL to POST data to.
         * @param {Object} [params.parameters] Optional parameters to pass to the exporter. If you write a custom exporter you may wish to use this.
         * @param {Function} [params.success] Callback to execute once the data has saved successfully.
         * @param {Function} [params.error] Callback to execute if there was an error saving the data.
         * @param {Object} [params.headers] Optional headers to set on the ajax request. By default, the Toolkit will send
         * a `Content-Type:"application/json"` header. If you provide your own headers this header will continue to be sent, unless
         * of course you override it.
         * @return {jsPlumbToolkitInstance} The current instance of the Toolkit. If you provide data directly to this
         * method you can then chain a load call with a subsequent `render`.
         */
        this.save = function (params) {
            params = params || {};
            var data = this.exportData(params);
            var headers = { "Content-Type":"application/json" };
            JSP.extend(headers, params.headers ||  {});
            UTIL.ajax({
                url: params.url,
                type: "POST",
                data: data,
                success: params.success || function() {},
                error: params.error || function() {},
                headers:headers
            });
            return _currentInstance;
        };

        /**
         * Exports the current data to JSON.
         * @method exportData
         * @param {Object} params Export parameters
         * @param {String} [params.type="json"] Specifies the data type in which to format the data. This must match the name of an exporter
         * registered with the given instance of the Toolkit.
         * @param {Object} [params.parameters] Optional parameters to pass to the exporter. If you write a custom exporter you may wish to use this.
         * @return {Object} JSON payload.
         */
        this.exportData = function (params) {
            params = params || {};
            return root.jsPlumbToolkitIO.exportData(params.type || "json", _currentInstance, params.parameters);
        };

        // ------------------------------------- NODE/EDGE selection -----------------------------------

        var _createSelection = function (onClear) {
            return new UTIL.Selection({
                toolkit: _currentInstance,
                onClear: onClear || function () {
                }
            });
        };

        var _currentSelection = _createSelection(function (sel) {
            _currentInstance.fire("selectionCleared", {
                selection: sel
            });
        });
        if (params.maxSelectedNodes) {
            _currentSelection.setMaxNodes(params.maxSelectedNodes);
        }
        if (params.maxSelectedEdges) {
            _currentSelection.setMaxEdges(params.maxSelectedEdges);
        }
        if(params.selectionCapacityPolicy) {
            _currentSelection.setCapacityPolicy(params.selectionCapacityPolicy);
        }

        var _select = function (obj, append, _selection, fireSelectEvent) {
            if (!append) _selection.clear(true);
            return _selection.append(obj, function (o) {
                if (fireSelectEvent) {
                    _currentInstance.fire("select", {
                        append: append,
                        obj: o,
                        selection: _selection
                    });
                }
            });
        };

        /**
         * Sets obj as the current selection for this instance of the jsPlumb Toolkit.
         * @method setSelection
         * @param {Node|Edge|Node[]|Edge[]|Path|String} obj Object to select. May be a Node/Edge or an array of either
         * of these, or a Node id, or a Path.
         */
        this.setSelection = function (obj) {
            _select(obj, false, _currentSelection, true);
        };

        /**
         * Gets an ad-hoc selection
         * @method select
         * @param {Node|Port|Edge|Node[]|Port[]|Edge[]|Path|String} obj Object to select. May be a Node/Port/Edge or an array of either
         * of these, or a Node id, a Selection, or a Path.
         */
        this.select = function (obj, includeEdges) {
            var s = _createSelection();
            var objects = _select(obj, true, s);
            if (includeEdges) {
                for (var i = 0; i < objects[0].length; i++) {
                    var so = objects[0][i];
                    if (so.objectType == "Node" || so.objectType == "Port") {
                        var ae = so.getAllEdges();
                        for (var j = 0; j < ae.length; j++)
                            s.append(ae[j]);
                    }
                }
            }
            return s;
        };

        var _descendants = function (focus, selection, includeEdges, touched) {
            var edges = focus.getAllEdges();
            for (var i = 0, j = edges.length; i < j; i++) {
                if (edges[i].source === focus || (edges[i].getNode && edges[i].getNode() === focus)) {
                    var t = edges[i].target, tid = t.getFullId();
                    if (!touched[tid]) {
                        selection.append(t);
                        if (includeEdges) selection.append(edges[i]);
                        touched[tid] = true;
                        _descendants(t, selection, includeEdges, touched);
                    }
                }
            }
        };

        /**
         * Selects all descendants of some Node, and, optionally, the Node itself.
         * @method selectDescendants
         * @param {Node|Port|Edge|Node[]|Port[]|Edge[]|Path|String} obj Object to select. May be a Node/Port/Edge or an array of either
         * of these, or a Node id, a Selection, or a Path.
         * @param {Boolean} [includeRoot=false] Whether or not to include the root node in the returned dataset.
         * @param {Boolean} [includeEdges=false] Whether or not to include edges in the returned dataset.
         */
        this.selectDescendants = function (obj, includeRoot, includeEdges) {
            var info = _currentInstance.getObjectInfo(obj);
            var s = _createSelection();

            if (info.obj && info.obj.objectType === "Node") {
                if (includeRoot) _select(info.obj, true, s);
                var touched = {};
                touched[info.obj.getFullId()] = true;
                _descendants(info.obj, s, includeEdges, touched);
            }

            return s;
        };

        /**
         * Gets a Selection that is a filtered set of Nodes and Edges.
         * @method filter
         * @param {Object|Function} spec Either a function, which will be passed each Edge and Node and is expected to return
         * true to indicate inclusion, or an object consisting of key/value pairs, all of which are expected to match the `data` for any Edge or Node that should be included in the output.
         * @param {Boolean} [includePartials=false] If true, and you're using a match object, the results will include any objects that match at least one key in the match object.
         * @return {Selection} A Selection.
         */
        this.filter = function (spec, includePartials) {
            var fn = typeof spec == "function" ? spec : function (obj) {
                    var d = obj.data, out = false;
                    for (var i in spec) {
                        var match = spec[i] === d[i];
                        if (!match && !includePartials) return false;
                        out = out || match;
                    }
                    return out;
                },
                s = _createSelection();

            this.eachNode(function (i, n) {
                if (fn(n)) s.append(n);
                var o = n.getPorts();
                for (var j = 0; j < o.length; j++)
                    if (fn(o[j])) s.append(o[j]);
            });

            this.eachEdge(function (i, e) {
                if (fn(e)) s.append(e);
            });

            this.eachGroup(function (i, e) {
                if (fn(e)) s.append(e);
            });

            return s;
        };

        /**
         * Appends `obj` to the current selection. If there is no current selection, `obj` becomes it.
         * @method addToSelection
         * @param {Node|Edge|Node[]|Edge[]|Path|String|Element} obj Object to select. May be a Node/Edge or an array of either
         * of these, or a Node id, or a Path, or a DOM element.
         */
        this.addToSelection = function (obj) {
            var info = this.getObjectInfo(obj);
            if (info) {
                var objects = _select(info.obj, true, _currentSelection, true);
                _adhocSel("deselect", objects[1]);
                _adhocSel("select", objects[0]);
            }
        };

        var _adhocSel = function(evt, objects) {
            for (var i = 0; i < objects.length; i++) {
                _currentInstance.fire(evt, {
                    obj: objects[i],
                    selection: _currentSelection
                });
            }
        };
        /**
         * Toggles whether or not the given `obj` forms part of the current selection.
         * @param {Node|Edge|Node[]|Edge[]|Path|String} obj Object to select. May be a Node/Edge or an array of either
         * of these, or a Node id, or a Path, or a DOM element.
         */
        this.toggleSelection = function (obj) {
            var info = this.getObjectInfo(obj);
            if (info) {
                var sel = [], desel = [];
                var objects = _currentSelection.toggle(info.obj, function (o, wasAdded) {
                    // seems we dont need to add to 'sel'
                    if (!wasAdded) {
                        desel.push(o);
                    }
                });
                _adhocSel("deselect", objects[1]);
                _adhocSel("deselect", desel);
                _adhocSel("select", objects[0]);
                //_adhocSel("select", sel);
            }
        };

        /**
         * Removes obj from the current selection
         * @method deselect
         * @param {Node|Edge|Node[]|Edge[]|Path|String} obj Object to deselect. May be a Node/Edge or an array of either
         * of these, or a Node id, or a Path, or a DOM element.
         */
        this.removeFromSelection = function (obj) {
            var info = this.getObjectInfo(obj);
            if (info) {
                _currentSelection.remove(info.obj, function (o) {
                    _currentInstance.fire("deselect", {
                        obj: o,
                        selection: _currentSelection
                    });
                });
            }
        };

        /**
         * Appends the Path from `source` to `target` to the current selection. If there is no current selection, `obj` becomes it.
         * If the Path does not exist, there is no selection.
         * @method addPathToSelection
         * @param {Object} params Path params
         * @param {Node|String} params.source ID of source, or source Node/Port
         * @param {Node|String} params.target ID of target, or target Node/Port
         */
        this.addPathToSelection = function (params) {
            this.addToSelection(this.getPath(params));
        };

        /**
         * Sets the current selection to be every node in the toolkit instance.
         * @method selectAll
         */
        this.selectAll = function () {
            // get all nodes, pipe them into the select function.
            throw new TypeError("not implemented");
        };

        /**
         * Clears the current selection and fires a `selectionCleared` event.
         * @method clearSelection
         */
        this.clearSelection = _currentSelection.clear;

        /**
         * Gets the current Selection for this Toolkit instance.
         * @method getSelection
         * @return {Selection} Current Selection.
         */
        this.getSelection = function () {
            return _currentSelection;
        };

        /**
         * Sets the maximum number of nodes that may be selected at any one time. Default is Infinity.
         * @method setMaxSelectedNodes
         * @param {Integer} maxNodes Max number of nodes allowed to be selected at once.
         */
         this.setMaxSelectedNodes = function(maxNodes) {
             _currentSelection.setMaxNodes(maxNodes);
         };

        /**
         * Sets the maximum number of edges that may be selected at any one time. Default is Infinity.
         * @method setMaxSelectedEdges
         * @param {Integer} maxEdges Max number of edges allowed to be selected at once.
         */
        this.setMaxSelectedEdges = function(maxEdges) {
            _currentSelection.setMaxEdges(maxEdges);
        };

        /**
         * Sets The action taken when appending an edge or node that would
         * take the selection above its limit for that given type. Depends on the current `capacityPolicy`, which can be either
         * Selection.DISCARD_EXISTING (the default) or Selection.DISCARD_NEW.
         * @method setSelectionCapacityPolicy
         * @param {String} policy One of `Selection.DISCARD_EXISTING` (which removes the 0th entry from the list before insertion of the new value) or `Selection.DISCARD_NEW`.
         */
        this.setSelectionCapacityPolicy = function(policy) {
            _currentSelection.setCapacityPolicy(policy);
        };

// --------------------- rendering -------------------------------------

        var // notification that some data was loaded. initializes all current renderers.
            _notifyDataLoaded = function (endEvent) {
                _currentInstance.setSuspendGraph(true);
                _currentInstance.fire(endEvent);
                _currentInstance.setSuspendGraph(false);
                _dataLoading = false;
            },
            _renderersById = {};

        /**
         * Configures the given element as a renderer, registering it so that it reflects any changes to the
         * underlying data. This method turns the given element into a Surface if it is not already one.  If there is any data in the
         * Toolkit at the time of this call it is rendered; any data subsequently loaded is automatically rendered. You can supply
         * layout arguments to this method (layout type + layout specific parameters), as well as jsPlumb rules for
         * endpoints, paint styles etc.
         * @method render
         * @param {Object} params Method parameters
         * @param {Element|Selector} params.container Element to convert into a Surface.
         * @param {String} [params.id] Optional id to register the created Surface against. You can then retrieve the Surface via `toolkit.getRenderer(id)`. If you do not provide this, one will be assigned. The ID is written as the renderer's `id` property.
         * @param {Boolean} [params.elementsDraggable=true] Whether or not elements in the Surface should be draggable.
         * @param {Object} [params.dragOptions] Options for draggable elements.
         * @param {Object} [params.events] Optional event bindings. See documentation.
         * @param {Object} [params.miniview] Optional miniview configuration. See documentation.
         * @param {String} [params.mode="Pan"] Mode to initialize the Surface in.
         * @param {Number} [params.panDistance=50] How far a pan nudge should move the UI (in pixels).
         * @param {Boolean} [params.enablePan=true] Whether or not panning (via mouse drag) is enabled.
         * @param {Boolean} [params.enableWheelZoom=true] Whether or not zooming with the mouse wheel is enabled.
         * @param {String} [params.wheelFilter] Optional CSS selector representing elements that should not respond to wheel zoom.
         * @param {Number} [params.wheelSensitivity=10] How many pixels each click of the mouse wheel represents when zooming. Note that this value, while expressed in pixels, is mapped in a variety of ways depending on the browser.
         * @param {Boolean} [params.enablePanButtons=true] Whether or not to show the pan nudge buttons on the borders of the widgets.
         * @param {Number[]} [params.padding] Optional values for padding in the x/y axes to leave around the content. This is only of any use if you have disabled panning via mouse drag,
         * since in that case the user sees only scroll bars and has no way of navigating beyond the content. Some padding makes the UI nicer to use. Default is [0,0].
         * @param {String} [params.lassoFilter] Optional selector for elements on which a mousedown should not cause the lasso to activate.
         * @param {Boolean} [params.consumeRightClick=true] Useful for development: set this to false if you don't want the widget to consume context menu clicks.
         * @param {Object} [params.jsPlumb] Optional set of jsPlumb Defaults to use for this renderer. The format and allowed properties is that of
         *                 the Defaults object in jsPlumb. You can also set display properties in the model.
         * @param {Boolean} [params.enhancedModel=true] If false, there will be no support for preconfigured parameters or functions in the definitions inside a Model. You will want to set this for Angular if you use the 2-way data binding.
         */
        this.render = function (params, referenceParams) {
            var p = JSP.extend({}, referenceParams || {});
            JSP.extend(p, params);
            p.toolkit = _currentInstance;

            // if a selection supplied, set that as the toolkit (model supplier, basically). two cases
            // are supported: one, that `selection` is a pre-prepared Selection, in which case we use it.
            // second case is that `selection` is just some function that can populate a selection, in
            // which case we make a new Selection and set what we were given as its "generator".
            if (params.selection != null) {
                if (params.selection.constructor === UTIL.Selection) {
                    p.toolkit = params.selection;
                }
                else {
                    p.toolkit = new UTIL.Selection({
                        generator: params.selection,
                        toolkit:_currentInstance
                    });
                }
            }

            var type = p.type || root.jsPlumbToolkit.DefaultRendererType;
            var renderer = new root.jsPlumbToolkit.Renderers[type](p);
            var id = p.id || JUTIL.uuid();
            _renderersById[id] = renderer;
            renderer.id = id;
            return renderer;
        };

        /**
         * Gets a renderer by the `id` parameter supplied to the `render` call (which is by default null, and only renderers for which an `id` was supplied are retrievable via this method)
         * @method getRenderer
         * @param {String} id ID of the renderer to retrieve.
         * @return {AbstractRenderer} Either a Renderer that was registered against the given id, or null if none found.
         */
        this.getRenderer = function (id) {
            return _renderersById[id];
        };

        /**
         * Gets all renderers registered on this instance of the jsPlumb Toolkit.
         * @method getRenderers
         * @return {Object} A map of `id-> Renderer` pairs.
         */
        this.getRenderers = function () {
            return _renderersById;
        };

        /**
         * Finds information related to the given object, which may be a DOM node or an existing Toolkit object. This function is
         * useful for mapping some UI element to its underlying data.
         * @method getObjectInfo
         * @param {String|Element|Node|Port} obj An element id, node id, DOM element, Node or Port.
         * @param {Function} [elementResolver] For internal use. Resolves a Node or Port into its DOM element.
         * @return {Object} A JS object containing `obj` (the Toolkit object), `id` (the Node/Port ID), `type` ("port" or "node"), `els` - a map of Surface ids
         * to [ Surface, Element ] pairs, one for each Surface that has rendered the given Node/Port.
         */
        this.getObjectInfo = function (obj, elementResolver) {
            var out = { els: {}, obj: null, type: null, id: null, el: null },
                _findJtkParent = function (el) {
                    if (el != null) {
                        if (el.jtk) return el;
                        return _findJtkParent(el.parentNode);
                    }
                },
                _findEls = function (item) {
                    var o = {};
                    for (var i in _renderersById) {
                        o[i] = [
                            _renderersById[i],
                            _renderersById[i].getRenderedElement(item)
                        ];
                    }
                    return o;
                };

            if (obj != null) {
                if (obj.eachNode && obj.eachEdge) return {obj:obj}; // a Path, Selection, or Toolkit instance.
                else if (JUTIL.isArray(obj)) return { obj:obj }; // an array
                var de = JSP.getElement(obj);
                if (de != null && de.jtk) {
                    out.el = de;
                    out.obj = de.jtk.port || de.jtk.node;
                } else if (obj.tagName != null) {
                    // it's some element that is a child of a toolkit object.
                    var jp = _findJtkParent(de);
                    if (jp != null) {
                        out.el = jp;
                        out.obj = jp.jtk.port || jp.jtk.node || jp.jtk.group;
                    }
                } else {
                    if (typeof obj === "string") {
                        obj = this.getNode(obj);
                    }
                    else if (typeof obj === "object" && typeof obj.objectType === "undefined") {
                        obj = this.getNode(_idFunction(obj));
                    }
                    if (obj != null) {
                        // it's a toolkit object (in theory.)
                        out.obj = obj;
                        if (elementResolver != null)
                            out.el = elementResolver(obj);
                    }
                    else
                        return out;
                }

                if (elementResolver == null)
                    out.els = _findEls(out.obj);

                if (out.obj != null) {
                    out.id = out.obj.id;
                    out.type = out.obj.objectType;
                }
            }
            return out;
        };

        // if data supplied to constructor, load it.
        if (params.data) {
            var t = params.dataType || "json";
            _currentInstance.load({
                data: params.data,
                type: t
            });
        }
    };

    JUTIL.extend(root.jsPlumbToolkitInstance, JUTIL.EventGenerator);


// ---------------------- static jsPlumbToolkit members ----------------------------------------
    root.jsPlumbToolkit = new root.jsPlumbToolkitInstance({});
    root.jsPlumbToolkit.DefaultRendererType = null;
    root.jsPlumbToolkit.ready = JSP.ready;
    root.jsPlumbToolkit.Renderers = {};
    root.jsPlumbToolkit.Widgets = {};
    /**
     * Gets a new instance of the jsPlumb Toolkit.
     * @param params Valid constructor parameters for a jsPlumbToolkitInstance.
     * @returns {jsPlumbToolkitInstance}
     */
    var newInstance = function (params) {
        return new root.jsPlumbToolkitInstance(params);
    };

    root.jsPlumbToolkit.newInstance = newInstance;

    // npm / commonJS
    if (typeof exports !== "undefined") {
        exports.jsPlumbToolkit = root.jsPlumbToolkit;
        exports.newInstance = newInstance;
    }

}).call(typeof window !== 'undefined' ? window : this);

/*
 * Model
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */

;
(function () {

    // --------------------------------------------- MODEL -------------------------------------------------

    var root = this,
        JTK = root.jsPlumbToolkit,
        UTIL = root.jsPlumbToolkitUtil,
        JUTIL = root.jsPlumbUtil;

    /**
     * A Model describes the appearance and behaviour of a set of Nodes, Edges, Ports and Groups. You do not
     * create one of these directly; instead you pass a definition to a `jsPlumbToolkit.render` or
     * `jsPlumbToolkit.newInstance()` call. Although the Model has the same syntax in each context, you are
     * encouraged to configure model-specific things in the Model you pass to the `newInstance` method (such as,
     * which Nodes/Ports can be connected to which others, what is the maximum number of connections, etc), and
     * view-specific things (such as css classes, paint styles, connector appearance etc) to the model you pass to
     * the `render` method. The `render` method automatically merges in a Node/Port/Edge definition from a Model
     * defined on the associated Toolkit, if there is one.
     * @class jsPlumbToolkit.Model
     * @constructor
     * @param {Object} params Model parameters
     * @param {Object} [params.nodes] Node definitions.
     * @param {Object} [params.edges] Edge definitions.
     * @param {Object} [params.ports] Port definitions.
     * @param {Object} [params.groups] Group definitions.
     * @param {jsPlumbInstance} [_jsPlumb] An instance of jsPlumb on which to register associated Connection and Endpoint types.
     * Only the Surface widget provides this. The Toolkit instance creates a Model but it is headless.
     */
    JTK.Model = function (params, _jsPlumb) {

        params = params || { };
        params.nodes = params.nodes || {};
        params.edges = params.edges || {};
        params.ports = params.ports || {};
        params.groups = params.groups || {};

        var _states = {}, def, i;

        var _getNodeDefinition = function (typeId) {
                var _def = UTIL.mergeWithParents([typeId, "default"], params.nodes);
                delete _def.parent;
                return _def;
            },
            _getEdgeDefinition = function (typeId) {
                var _def = UTIL.mergeWithParents([typeId, "default"], params.edges);
                delete _def.parent;
                return _def;
            },
            _getPortDefinition = function (portId, nodeDefinition) {
                var _def = nodeDefinition && nodeDefinition.ports ? UTIL.mergeWithParents([portId, "default"], nodeDefinition.ports) : UTIL.mergeWithParents([portId, "default"], params.ports);
                delete _def.parent;
                return _def;
            },
            _getGroupDefinition = function(typeId) {
                var _def = UTIL.mergeWithParents([typeId, "default"], params.groups);
                delete _def.parent;
                return _def;
            };

// populate the connection and endpoint types in the supplied jsPlumb instance (if it was supplied. The Toolkit does not
// provide a jsPlumb instance; it is headless.

        if (typeof _jsPlumb != "undefined") {
            // edges (connections)
            for (var di in params.edges) {
                def = _getEdgeDefinition(di);
                // now look for listeners registered on overlays. we actually want to replace those	with our
                // own listeners, because jsPlumb passes only the overlay and the event, whereas we want to pass
                // the event and the overlay as well as the edge and connection.
                if (def.overlays) {
                    for (i = 0; i < def.overlays.length; i++) {
                        if (JUTIL.isArray(def.overlays[i]) && def.overlays[i][1].events) {
                            for (var j in def.overlays[i][1].events) {
                                def.overlays[i][1].events[j] = (function (fn, overlay) {
                                    return function (o, e) {
                                        fn.call(overlay, {
                                            overlay: o,
                                            e: e,
                                            component: o.component,
                                            edge: o.component.edge
                                        });
                                    }
                                })(def.overlays[i][1].events[j], def.overlays[i]);
                            }
                        }
                    }
                }
                _jsPlumb.registerConnectionType(di, def);
            }
            // ports (endpoints)
            for (i in params.ports) {
                def = _getPortDefinition(i);
                _jsPlumb.registerEndpointType(i, def);
            }

            // UI states. These result in `connectionType` definitions on the associated jsPlumb for edges,
            // but for nodes the manipulations are made on the DOM elements.
            if (params.states) {
                for (var s in params.states) {
                    _states[s] = new JTK.UIState(s, params.states[s], _jsPlumb);
                }
            }
        }

        return {
            getNodeDefinition: _getNodeDefinition,
            getEdgeDefinition: _getEdgeDefinition,
            getPortDefinition: _getPortDefinition,
            getGroupDefinition: _getGroupDefinition,
            getState: function (stateId) {
                return _states[stateId];
            }
        };
    };

// --------------------------------------------- / MODEL -------------------------------------------------


}).call(typeof window !== 'undefined' ? window : this);

/*
 * Layout
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * Licensed under the GPL2 license.  This software is not free.
 */
/**
 *
 * functionality to support template loading from script tags (browser only)
 */
;(function() {
    var jptr = jsPlumbToolkit.ready,
        Queue = function (templateHolder) {
            var c = 0,
                _dec = function () {
                    c--;
                    if (c <= 0) {
                        _toolkitReady();
                    }
                };

            this.add = function (src) {
                c++;
                jsPlumbToolkitUtil.ajax({
                    url: src,
                    success: function (html) {
                        var ih = templateHolder.innerHTML;
                        ih += html;
                        templateHolder.innerHTML = ih;
                        _dec();
                    },
                    error: function (http) {
                        _dec();
                        //_log(&quot;jsPlumbToolkit: cannot load model from &quot; + src);
                    }
                });
            };

            this.ensureNotEmpty = function() {
                if (c <= 0) _toolkitReady();
            };
        },
        readyFuncs = [],
        _ready = false,
        _toolkitReady = function () {
            _ready = true;
            for (var i = 0; i < readyFuncs.length; i++) {
                jptr.call(jptr, readyFuncs[i])
            }
        };

    jsPlumbToolkit.ready = function (f) {
        if (!_ready)
            readyFuncs.push(f);
        else
            jptr.call(jptr, f);
    };

    jsPlumb.ready(function () {
        var templateHolder = document.getElementById("jsPlumbToolkitTemplates");
        if (!templateHolder) {
            templateHolder = document.createElement("div");
            templateHolder.style.display = "none";
            templateHolder.id = "jsPlumbToolkitTemplates";
            document.body.appendChild(templateHolder);

            var queue = new Queue(templateHolder);

            var tags = document.getElementsByTagName("script");
            for (var i = 0; i < tags.length; i++) {
                var type = tags[i].getAttribute("type"), src = tags[i].getAttribute("src");
                if (type == "text/x-jtk-templates") {
                    queue.add(src);
                }
            }

            queue.ensureNotEmpty();
        }
        else {
            _toolkitReady();
        }

    });

}).call(typeof window !== 'undefined' ? window : this);
/*
 * Constants
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 * This file contains event and class constants.
 *
 */
;
(function () {

    "use strict";

    this.jsPlumbToolkit.Classes = {
        LASSO: "jtk-lasso",
        LASSO_SELECT_DEFEAT: "jtk-lasso-select-defeat",
        MINIVIEW: "jtk-miniview",
        MINIVIEW_CANVAS: "jtk-miniview-canvas",
        MINIVIEW_PANNER: "jtk-miniview-panner",
        MINIVIEW_ELEMENT: "jtk-miniview-element",
        MINIVIEW_GROUP_ELEMENT: "jtk-miniview-group-element",
        MINIVIEW_PANNING: "jtk-miniview-panning",
        MINIVIEW_COLLAPSE: "jtk-miniview-collapse",
        MINIVIEW_COLLAPSED: "jtk-miniview-collapsed",
        NODE: "jtk-node",
        PORT: "jtk-port",
        GROUP: "jtk-group",
        SELECT_DEFEAT:"jtk-drag-select-defeat",
        SURFACE: "jtk-surface",
        SURFACE_NO_PAN: "jtk-surface-nopan",
        SURFACE_CANVAS: "jtk-surface-canvas",
        SURFACE_PAN: "jtk-surface-pan",
        SURFACE_PAN_LEFT: "jtk-surface-pan-left",
        SURFACE_PAN_TOP: "jtk-surface-pan-top",
        SURFACE_PAN_RIGHT: "jtk-surface-pan-right",
        SURFACE_PAN_BOTTOM: "jtk-surface-pan-bottom",
        SURFACE_PAN_ACTIVE: "jtk-surface-pan-active",
        SURFACE_SELECTED_ELEMENT: "jtk-surface-selected-element",
        SURFACE_SELECTED_CONNECTION:"jtk-surface-selected-connection",
        SURFACE_PANNING:"jtk-surface-panning",
        SURFACE_ELEMENT_DRAGGING:"jtk-surface-element-dragging",
        SURFACE_DROPPABLE_NODE:"jtk-surface-droppable-node",
        TOOLBAR: "jtk-toolbar",
        TOOLBAR_TOOL: "jtk-tool",
        TOOLBAR_TOOL_SELECTED: "jtk-tool-selected",
        TOOLBAR_TOOL_ICON: "jtk-tool-icon"
    };

    this.jsPlumbToolkit.Constants = {
        click:"click",
        start:"start",
        stop:"stop",
        drop:"drop",
        disabled:"disabled",
        pan:"pan",
        select:"select",
        drag:"drag",
        left: "left",
        right: "right",
        top: "top",
        bottom: "bottom",
        width: "width",
        height: "height",
        leftmin: "leftmin",
        leftmax: "leftmax",
        topmin: "topmin",
        topmax: "topmax",
        min: "min",
        max: "max",
        nominalSize:"50px",
        px: "px",
        onepx: "1px",
        nopx: "0px",
        em: "em",
        absolute: "absolute",
        relative: "relative",
        none: "none",
        block: "block",
        hidden: "hidden",
        div: "div",
        id: "id",
        plusEquals: "+=",
        minusEquals: "-=",
        dot: ".",
        transform: "transform",
        transformOrigin: "transform-origin",
        nodeType:"Node",
        portType:"Port",
        edgeType:"Edge",
        groupType:"Group",
        surfaceNodeDragScope:"surfaceNodeDrag",
        mistletoeLayoutType:"Mistletoe",
        surfaceType:"Surface",
        jtkStatePrefix:"jtk-state-",
        msgCannotSaveState:"Cannot save state",
        msgCannotRestoreState:"Cannot restore state"
    };

    this.jsPlumbToolkit.Attributes = {
        jtkNodeId:"jtk-node-id",
        relatedNodeId:"related-node-id"
    };

    this.jsPlumbToolkit.Methods = {
        addClass:"addClass",
        removeClass:"removeClass"
    };

    this.jsPlumbToolkit.Events = {
        beforeDrop: "beforeDrop",
        beforeDetach: "beforeDetach",
        click: "click",
        canvasClick:"canvasClick",
        canvasDblClick:"canvasDblClick",
        connection: "connection",
        connectionAborted:"connectionAborted",
        connectionDetached: "connectionDetached",
        connectionMoved:"connectionMoved",
        connectionDragStop:"connectionDragStop",
        contentDimensions: "contentDimensions",
        contextmenu: "contextmenu",
        dataLoadStart: "dataLoadStart",
        dataAppendStart:"dataAppendStart",
        dataLoadEnd: "dataLoadEnd",
        dataAppendEnd:"dataAppendEnd",
        dblclick: "dblclick",
        drag: "drag",
        drop:"drop",
        dragover:"dragover",
        dragend:"dragend",
        edgeAdded: "edgeAdded",
        edgeRemoved: "edgeRemoved",
        edgeTypeChanged:"edgeTypeChanged",
        elementDragged: "elementDragged",
        elementAdded: "elementAdded",
        elementRemoved: "elementRemoved",
        endOverlayAnimation:"endOverlayAnimation",
        graphCleared:"graphCleared",
        groupAdded:"groupAdded",
        groupDragStop:"groupDragStop",
        groupExpand:"group:expand",
        groupCollapse:"group:collapse",
        groupRemoved:"groupRemoved",
        groupMemberAdded:"group:addMember",
        groupMemberRemoved:"group:removeMember",
        groupMoveEnd:"groupMoveEnd",
        groupUpdated:"groupUpdated",
        lassoEnd:"lasso:end",
        modeChanged: "modeChanged",
        mousedown: "mousedown",
        mousemove: "mousemove",
        mouseout: "mouseout",
        mouseup: "mouseup",
        mouseenter: "mouseenter",
        mouseleave: "mouseleave",
        mouseover: "mouseover",
        nodeAdded: "nodeAdded",
        nodeDropped:"nodeDropped",
        nodeMoveStart: "nodeMoveStart",
        nodeMoveEnd: "nodeMoveEnd",
        nodeRemoved: "nodeRemoved",
        edgeTarget: "edgeTarget",
        nodeTypeChanged:"nodeTypeChanged",
        edgeSource: "edgeSource",
        objectRepainted: "objectRepainted",
        pan: "pan",
        portAdded: "portAdded",
        portRemoved: "portRemoved",
        portTypeChanged:"portTypeChanged",
        redraw:"redraw",
        start: "start",
        startOverlayAnimation:"startOverlayAnimation",
        stateRestored:"stateRestored",
        stop: "stop",
        tap: "tap",
        touchend: "touchend",
        touchmove: "touchmove",
        touchstart: "touchstart",
        unload: "unload",
        portRefreshed: "portRefreshed",
        nodeRefreshed: "nodeRefreshed",
        edgeRefreshed: "edgeRefreshed",
        nodeRendered: "nodeRendered",
        nodeUpdated: "nodeUpdated",
        portUpdated: "portUpdated",
        edgeUpdated: "edgeUpdated",
        zoom: "zoom",
        relayout: "relayout",
        deselect:"deselect",
        selectionCleared:"selectionCleared",
        resize:"resize",
        anchorChanged:"anchorChanged"
    };


}).call(typeof window !== 'undefined' ? window : this);

/*
 * Storage
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
;
(function () {
    "use strict";

    var root = this;

    root.jsPlumbToolkit.util = {
        Cookies: {
            get: function (key) {
                var value = document.cookie.match((new RegExp(key + "=[a-zA-Z0-9.()=|%/_]+($|;)", "g")));
                if (!val || val.length == 0)
                    return null;
                else
                    return unescape(val[0].substring(key.length + 1, val[0].length).replace(";", "")) || null;
            },
            set: function (key, value, path, ttl) {
                var c = [ key + "=" + escape(value),
                            "path=" + (!path) ? "/" : path,
                            "domain=" + (!domain) ? window.location.host : domain ],
                    _ttl = function () {
                        if (parseInt(ttl) == 'NaN') return "";
                        else {
                            var now = new Date();
                            now.setTime(now.getTime() + (parseInt(ttl) * 60 * 60 * 1000));
                            return now.toGMTString();
                        }
                    };

                if (ttl)
                    c.push(_ttl(ttl));

                return document.cookie = c.join('; ');
            },
            unset: function (key, path, domain) {
                path = (!path || typeof path != "string") ? '' : path;
                domain = (!domain || typeof domain != "string") ? '' : domain;
                if (root.jsPlumbToolkit.util.Cookies.get(key))
                    root.jsPlumbToolkit.util.Cookies.set(key, '', 'Thu, 01-Jan-70 00:00:01 GMT', path, domain);
            }
        },
        Storage: {
            set: function (key, value) {
                if (typeof localStorage == "undefined")
                    root.jsPlumbToolkit.util.Cookies.set(key, value);
                else {
                    localStorage.setItem(key, value);
                }
            },
            get: function (key) {
                return (typeof localStorage == "undefined") ?
                    root.jsPlumbToolkit.util.Cookies.read(key) :
                    localStorage.getItem(key);
            },
            clear: function (key) {
                if (typeof localStorage == "undefined")
                    root.jsPlumbToolkit.util.Cookies.unset(key);
                else {
                    localStorage.removeItem(key);
                }
            },
            clearAll: function () {
                if (typeof localStorage == "undefined") {
                    // unset all cookies.
                }
                else {
                    while (localStorage.length > 0) {
                        var k = localStorage.key(0);
                        localStorage.removeItem(k);
                    }
                }
            },
            setJSON: function (key, value) {
                if (typeof JSON == "undefined")
                    throw new TypeError("JSON undefined. Cannot store value.");
                root.jsPlumbToolkit.util.Storage.set(key, JSON.stringify(value));
            },
            getJSON: function (key) {
                if (typeof JSON == "undefined")
                    throw new TypeError("JSON undefined. Cannot retrieve value.");
                return JSON.parse(root.jsPlumbToolkit.util.Storage.get(key));
            }
        }
    };
}).call(typeof window !== 'undefined' ? window : this);
/*
 * Path
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */

/**
 * Models a Path - the series of edges and intermediate nodes between two nodes or ports
 * in some toolkit of the Toolkit.
 */
;
(function () {

    "use strict";
    var root = this;
    var JTK = root.jsPlumbToolkit;
    var exports = JTK;
    var JUTIL = root.jsPlumbUtil;

    /**
     * Models the path between two Nodes/Ports, which consists of a series of [Node/Port, Edge] pairs.
     * @class Path
     */
    /**
     * @constructor
     * @param {jsPlumbToolkitInstance} toolkit toolkit instance from which to get the path info.
     * @param {Object} params Path spec params
     * @param {Node|Port|String} params.source Source node or port, or id of source node/port
     * @param {Node|Port|String} params.target Target node or port, or id of target node/port
     * @param {Boolean} [params.strict=true] Sets whether or not paths are searched strictly by the given source/target. If, for toolkit, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
     * @param {Function} [params.nodeFilter] Optional function that is given each Node's backing data and asked to return true or false - true means include the Node, false means exclude it.
     * @param {Function} [params.edgeFilter] Optional function that is given each Edge's backing data and asked to return true or false - true means include the Edge, false means exclude it.
     */
    exports.Path = function (toolkit, params) {

        this.bind = toolkit.bind;
        this.getModel = toolkit.getModel;
        this.setSuspendGraph = toolkit.setSuspendGraph;
        this.getNodeId = toolkit.getNodeId;
        this.getEdgeId = toolkit.getEdgeId;
        this.getPortId = toolkit.getPortId;
        this.getNodeType = toolkit.getNodeType;
        this.getEdgeType = toolkit.getEdgeType;
        this.getPortType = toolkit.getPortType;

        var p = toolkit.getGraph().findPath(params.source, params.target, params.strict, params.nodeFilter, params.edgeFilter),
            deleteEdges = function () {
                // detach all edges in the path
                for (var i = 0; i < p.path.length; i++) {
                    if (p.path[i].edge) {
                        toolkit.removeEdge(p.path[i].edge);
                    }
                }
                return this;
            }.bind(this),
            deleteNodes = function () {
                for (var i = 0; i < p.path.length; i++) {
                    toolkit.removeNode(p.path[i].vertex);
                }
                return this;
            }.bind(this),
            contains = function (obj, doNotFuzzyMatchNodes) {
                var gObj = toolkit.findGraphObject(obj), c = false;
                if (gObj) {
                    for (var i = 0; i < p.path.length; i++) {
                        if (p.path[i].vertex == gObj || p.path[i].edge == gObj || (!doNotFuzzyMatchNodes && p.path[i].vertex.objectType == "Port" && p.path[i].vertex.isChildOf(gObj))) {
                            c = true;
                            break;
                        }
                    }
                }
                return c;
            },
            nodes = [],
            nodeMap = {};

            for (var i = 0; i < p.path.length; i++) {
                nodes.push(p.path[i].vertex);
                nodeMap[toolkit.getNodeId(p.path[i].vertex)] = [ p.path[i].vertex, i ];
            }

        this.getNodes = function() { return nodes; };
        this.getNode = function(obj) {
            return nodeMap[typeof obj === "string" ? obj : obj.id][0];
        };
        this.getAllEdgesFor = function(node) {
            var idx = nodeMap[node.id][1];
            if (idx < p.path.length - 1) {
                return [ p.path[ idx + 1 ].edge ];
            }
            else return [];

        };

        var _each = function (dispatcher, startAt) {
            for (var i = startAt || 0; i < p.path.length; i++) {
                try {
                    dispatcher(i, p.path[i]);
                }
                catch (e) {
                    JUTIL.log("Path iterator function failed", e);
                }
            }
        };

        /**
         * Iterates through the path one step at a time. Each step consists of an object containing a
         * `vertex`, and, for all entries except the first, an `edge` member, which supplies the Edge that links
         * to the Vertex (which is why it is null for the first entry).
         * @method each
         * @param {Function} fn Function to call for each step. Arguments are `(index, {vertex:v,edge:e})`.
         */
        this.each = function (fn) {
            _each(function (i, p) {
                fn(i, p);
            });
        };

        /**
         * Iterates through the Nodes/Ports in the path one step at a time.
         * @method eachNode
         * @param {Function} fn Function to call for each step. Arguments are `(index, Node|Port)`.
         */
        this.eachNode = function (fn) {
            _each(function (i, p) {
                fn(i, p.vertex);
            });
        };

        /**
         * Iterates through the Edges in the path one step at a time. There is always one fewer Edges than Nodes/Ports.
         * @method eachEdge
         * @param {Function} fn Function to call for each step. Arguments are `(index, Edge)`.
         */
        this.eachEdge = function (fn) {
            _each(function (i, p) {
                fn(i, p.edge);
            }, 1);
        };

        /**
         * Gets the number of Nodes in the Path.
         * @method getNodeCount
         * @return {Integer} Number of Nodes in the Path.
         */
        this.getNodeCount = function () {
            return p.path.length;
        };

        /**
         * Gets the Node at the given index in the path.
         * @method getNodeAt
         * @param idx
         * @returns {*}
         */
        this.getNodeAt = function(idx) {
            return p.path[idx].vertex;
        };

        /**
         * Gets the number of Edges in the Path.
         * @method getEdgeCount
         * @return {Integer} Number of Edges in the Path.
         */
        this.getEdgeCount = function () {
            return p.path.length == 0 ? 0 : p.path.length - 1;
        };

        /**
         * gets the Edge at the given index in the Path.
         * @param idx Index of the Edge to retrieve. You can use negative numbers here: an index of -1 means get the last edge.
         * An index of -2 means get the last but one. etc.
         * @returns {*}
         */
        this.getEdgeAt = function(idx) {
            if (idx < 0) idx = p.path.length - 1 + idx;
            return p.path.length > idx + 1 ? p.path[idx + 1].edge : null;
        };

        /**
         * The Path from the underlying Graph. See Graph documentation.
         * @property path
         * @type {Graph.Path}
         */
        this.path = p;

        /**
         * Deletes every Edge in this Path from the underlying Toolkit toolkit.
         * @method deleteEdges
         */
        this.deleteEdges = deleteEdges;

        /**
         * Deletes every Node in this Path from the underlying Toolkit toolkit.  Note that this has the
         * effect of also deleting all the Edges, so this is analogous to #deleteAll.
         * @method deleteNodes
         */
        this.deleteNodes = deleteNodes;

        /**
         * Deletes every object in this Path from the underlying Toolkit toolkit.
         * @method deleteAll
         */
        this.deleteAll = deleteNodes;

        /**
         * Returns whether or not a given path is empty
         * @method isEmpty
         * @return {Boolean} True if path is empty, false otherwise.
         */
        this.isEmpty = function () {
            return p.path.length == 0;
        };

        /**
         * Returns the cost of a given path, computed as the sum of the cost of all of the edges in the path.
         * @method getCost
         * @return {Number} Total cost of the Path. Null if path does not exist.
         */
        this.getCost = function () {
            return p.pathDistance;
        };

        /**
         * Returns whether or not a Path contains the given object.
         * @method contains
         * @param {Node|Port|Edge|String} Node/Port/Edge, or object id, of the element to test for.
         * @param {Boolean} [doNotFuzzyMatchNodes=false] If true, will return true iff a given Node is on the Path. Otherwise,
         * if the test object is a Node that has a Port on the Path, this method will return true.
         * @return {Boolean} True if Path contains the object, false otherwise.
         */
        this.contains = contains;

        /**
         * Returns whether or not a given path exists.
         * @method exists
         * @return {Boolean} True if path exists, false otherwise.
         */
        this.exists = function () {
            return p.pathDistance != null;
        };

        /**
         * Select a set of edges.
         * @method selectEdges
         * @param {Object} params parameters for the select call
         * @param {Node|String} [params.source] Source Node or id of source Node from which to select Edges.
         * @param {Node|String} [params.target] Target Node or id of target Node from which to select Edges.
         */
        this.selectEdges = function (params) {
            return _selectEdges(params, "getEdges", false);
        };

        /**
         * Select all edges in the toolkit toolkit.
         * @method selectAllEdges
         * @param {Object} params Parameters for the selectAllEdges call.
         */
        this.selectAllEdges = function (params) {
            return _selectEdges(params, "getAllEdges", true);
        };
    };


}).call(typeof window !== 'undefined' ? window : this);

/*
 * IO
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * Licensed under the GPL2 license.  This software is not free.
 *
 * This file contains IO support - loading/saving of the internal JSON format used by the Toolkit (and also support for custom formats)
 *
 */

/*
 DOM:

 - no knowledge of the DOM.

 DEPENDENCIES:

 jsPlumbUtil
 */
;
(function () {

    "use strict";

    var root = this;
    var IO = root.jsPlumbToolkitIO = {};
    var JUTIL = root.jsPlumbUtil;
    var JSPLUMB = root.jsPlumb;

    /*
     This uses the toolkit's internal JSON format.
     */
    var JSONGraphParser = function (data, toolkit, parameters) {
            var nodes = data.nodes || [],
                edges = data.edges || [],
                ports = data.ports || [],
                groups = data.groups || [];

            for (var l = 0; l < groups.length; l++) {
                toolkit.addGroup(groups[l]);
            }

            for (var i = 0; i < nodes.length; i++) {
                toolkit.addNode(nodes[i]);
            }

            for (var k = 0; k < ports.length; k++) {
                if (ports[k].nodeId) {
                    var n = toolkit.getNode(ports[k].nodeId);
                    if (n == null)
                        throw new TypeError("Unknown node [" + ports[k].nodeId + "]");
                    n.addPort(ports[k]);
                }
            }

            for (var j = 0; j < edges.length; j++) {
                var edgePayload = {
                        source: edges[j].source,
                        target: edges[j].target,
                        cost: edges[j].cost || 1,
                        directed: edges[j].directed,
                        data: edges[j].data
                    };

                if (edges[j].geometry) {
                    edgePayload.geometry = edges[j].geometry;
                }

                toolkit.addEdge(edgePayload);
            }
        },
        JSONGraphExporter = function (toolkit, parameters) {
            return toolkit.getGraph().serialize();
        };

    // parser for the "hierarchical json" format
    var hierarchicalJsonParser = function (data, toolkit, parameters) {
        var _one = function (d) {
            var n = toolkit.addNode(d);
            if (d.children) {
                for (var i = 0; i < d.children.length; i++) {
                    var c = toolkit.addNode(d.children[i]);
                    toolkit.addEdge({source: n, target: c});
                    _one(d.children[i]);
                }
            }
        };
        _one(data);
    };

    IO.exporters = {
        "json": JSONGraphExporter
    };

    IO.parsers = {
        "json": JSONGraphParser,
        "hierarchical-json": hierarchicalJsonParser
    };

    IO.managers = {
        "json": {
            "removeNode": function (dataset, node, idFunction) {
                var id = idFunction(node.data);
                JUTIL.removeWithFunction(dataset.nodes, function (n) {
                    return n.id == id;
                });
            },
            "removeEdge": function (dataset, edge, idFunction) {
                var id = idFunction(edge.data);
                JUTIL.removeWithFunction(dataset.edges, function (e) {
                    return e.data && (e.data.id == id);
                });
            },
            "addNode": function (dataset, node, idFunction) {
                dataset.nodes = dataset.nodes || [];
                dataset.nodes.push(node.data);
            },
            "addEdge": function (dataset, edge, idFunction) {
                var j = {
                    source: edge.source.getFullId(),
                    target: edge.target.getFullId(),
                    data: edge.data || {}
                };
                dataset.edges = dataset.edges || [];
                dataset.edges.push(j);
            },
            "addPort": function (dataset, params, idFunction) {
                dataset.ports = dataset.ports || [];
                var d = JSPLUMB.extend({}, params.port.data || {});
                d.id = params.port.getFullId();
                dataset.ports.push(d);
            },
            "removePort": function (dataset, params, idFunction) {
                var id = params.port.getFullId();
                JUTIL.removeWithFunction(dataset.ports, function (p) {
                    return p.id == id;
                });
            }
        }
    };

    IO.parse = function (type, source, toolkit, parameters) {
        var parser = IO.parsers[type];
        if (parser == null)
            throw new Error("jsPlumb Toolkit - parse - [" + type + "] is an unsupported type");
        else
            return parser(source, toolkit, parameters);
    };

    IO.exportData = function (type, toolkit, parameters) {
        var exporter = IO.exporters[type];
        if (exporter === null)
            throw new Error("jsPlumb Toolkit - exportData - [" + type + "]  is an unsupported type");
        else
            return exporter(toolkit, parameters);
    };

    IO.manage = function (operation, dataset, dataType, obj, idFunction, toolkit) {
        if (IO.managers[dataType] && IO.managers[dataType][operation]) {
            IO.managers[dataType][operation](dataset, obj, idFunction);
        }
    };

    if (typeof exports !== "undefined") {
        exports.jsPlumbToolkitIO = IO;
    }

}).call(typeof window !== 'undefined' ? window : this);

/*
 * Support
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
;
(function () {

    var root = this;
    var JTK = root.jsPlumbToolkit;
    var exports = JTK;

    /**
     * Support functionality for working with existing jsPlumb instances in the Toolkit. Using the `ingest` method in this
     * class, you can ingest an existing jsPlumb instance into a new instance of the Toolkit; this for many people may
     * prove to be a logical upgrade path from their existing jsPlumb code.
     *
     * When you ingest an existing jsPlumb instance, its `Container` is configured to be a `Surface` widget, which makes
     * it pannable and zoomable, and the set of Nodes and Edges it is managing are loaded into the Toolkit's data model.
     * @class jsPlumbToolkit.Support
     */
    exports.Support = {

        /**
         * Ingests an existing jsPlumb instance into a new Toolkit instance, and turns the instance's Container into a Surface.  Every element
         * that is the source or target of a Connection is added to the Toolkit instance as a Node, and every Connection is added as an Edge. You
         * can provide your own functions for determining the `id` and `type` of Nodes and Edges, if you need to. This method will throw an error
         * if your jsPlumb instance does not have a Container set; it is a requirement for the Surface widget.
         * @method ingest
         * @static
         * @param {Object} params Method parameters.
         * @param {jsPlumbInstance} [params.jsPlumb] The instance of jsPlumb to ingest. If null, it uses the static jsPlumb window instance.
         * @param {String} [params.nodeSelector] Optional selector to identify elements that may not yet be managed by jsPlumb but which you would like to have imported as Nodes.
         * @param {Function} [params.idFunction] A function to use to extract the id from elements that are being loaded as Nodes. If null,
         *                                       the default behaviour is to ask the jsPlumb instance for the element's `id` attribute.
         * @param {Function} [params.typeFunction] A function to use to extract the type from elements that are being loaded as Nodes. If null,
         *                                       the default behaviour is to use `default` as the Node type.
         * @param {Function} [params.edgeIdFunction] A function to use to extract the id from Connections that are being loaded as Edges. If null,
         *                                       the default behaviour is to use the Connection's `id`.
         * @param {Function} [params.edgeTypeFunction] A function to use to extract the type from Connections that are being loaded as Edges. If null,
         *                                       the default behaviour is to use `default` as the Edge type.
         * @param {Object} [params.renderParams] Parameters to pass to the Surface constructor.
         * @param {Boolean} [params.render=true] If false, this method returns only a Toolkit instance with data loaded, and doesn't create a Surface renderer for it.
         * @return {jsPlumbToolkitInstance|Surface} A Surface instance whose underlying Toolkit has been loaded with the contents of the jsPlumb instance (you can access the Toolkit itself via `surface.getToolkit()`), or, if `render` was set to false, a `jsPlumbToolkitInstance`..
         */
        ingest: function (params) {
            var _jsPlumbInstance = params.jsPlumb || root.jsPlumb;
            if (!_jsPlumbInstance.getContainer()) throw new TypeError("No Container set on jsPlumb instance. Cannot continue.");
            var tk = JTK.newInstance(),
                conns = _jsPlumbInstance.select(),
                nMap = {},
                _defaultFunction = function () {
                    return "default";
                },
                idFunction = params.idFunction || function (el) {
                    return _jsPlumbInstance.getId(el);
                },
                typeFunction = params.typeFunction || _defaultFunction,
                edgeIdFunction = params.idFunction || function (c) {
                    return c.id;
                },
                edgeTypeFunction = params.edgeTypeFunction || _defaultFunction,
                render = params.render !== false;

            var _addNode = function (el) {
                var id = idFunction(el), type = typeFunction(el);
                var elId = _jsPlumbInstance.getId(el);
                if (nMap[elId] == null) {
                    nMap[elId] = tk.addNode({id: id, type: type}, null, true);
                    el.jtk = { node: nMap[elId] };
                }
            };

            var _addEdge = function (conn) {
                var ourSource = nMap[conn.sourceId], ourTarget = nMap[conn.targetId],
                    id = edgeIdFunction(conn), type = edgeTypeFunction(conn);

                conn.edge = tk.addEdge({source: ourSource, target: ourTarget, data: { id: id, type: type }}, null, true);
            };

            // extra nodes
            if (params.nodeSelector) {
                var selectorNodes = _jsPlumbInstance.getContainer().querySelectorAll(params.nodeSelector);
                for (var i = 0; i < selectorNodes.length; i++) {
                    var id = _jsPlumbInstance.getId(selectorNodes[i]);
                    _addNode(selectorNodes[i], id);
                    _jsPlumbInstance.manage(id, selectorNodes[i]);
                }
            }

            // nodes
            var managedElements = _jsPlumbInstance.getManagedElements();
            for (var id in managedElements) {
                _addNode(managedElements[id].el, id);
            }

            // edges
            conns.each(function (conn) {
                _addEdge(conn);
            });

            // now the data has been loaded. if render==false, return the toolkit
            if (!render)
                return tk;
            else {
                var rp = root.jsPlumb.extend({}, params.renderParams || {});
                rp.jsPlumbInstance = _jsPlumbInstance;
                rp.container = _jsPlumbInstance.getContainer();
                var renderer = tk.render(rp);

                renderer.ingest = function(el) {
                    _addNode(el);
                    renderer.importNode(el, idFunction(el));
                };

                return renderer;
            }
        }
    };

}).call(typeof window !== 'undefined' ? window : this);

/*
 * Layout
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 * This file contains the layouts supported by the Toolkit.
 *
 */
;
(function () {

    "use strict";

    var root = this;
    var JTK = root.jsPlumbToolkit;
    var LAYOUTS = JTK.Layouts = {
        Decorators: {}
    };
    var JUTIL = root.jsPlumbUtil;

// common utility functions

    var //
    // gets the bounding box for all positioned elements.  this is in the coord space of the layout in use, and
    // may differ from pixels coords.  it is mapped by the updateUIPosition function to pixel space.
    //
        getBoundingBox = function (positions) {
            var xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
            for (var i in positions) {
                xmin = Math.min(xmin, positions[i][0]);
                xmax = Math.max(xmax, positions[i][0]);
                ymin = Math.min(ymin, positions[i][1]);
                ymax = Math.max(ymax, positions[i][1]);
            }
            return [
                [ xmin, ymin ],
                [ xmax, ymax ],
                Math.abs(xmin - xmax),
                Math.abs(ymin - ymax)
            ];
        },
        _initialiseDecorators = function (dlist, adapter, container) {
            if (dlist == null) return [];
            var out = [];
            var _resolve = function (d) {
                var fnName = (typeof d == "string") ? d : d[0],
                    fn = LAYOUTS.Decorators[fnName],
                    fnParams = (typeof d == "string") ? {} : d[1];

                if (!fn) {
                    JUTIL.log("Decorator [" + fnName + "] nor registered on jsPlumbToolkit.Layouts.Decorators. Not fatal.");
                    return null;
                }
                return new fn(fnParams, adapter, container);
            };
            for (var i = 0; i < dlist.length; i++) {
                var d = _resolve(dlist[i]);
                if (d) out.push(d);
            }


            return out;
        };

    /**
     * The parent for all layouts. This class maintains an array of element positions and
     * sizes, and provides the key methods for executing layout functionality.  When using the Toolkit
     * you will not ordinarily need to interact directly with a layout, but if you write your own layout
     * then you need to extend this class and implement the abstract methods you need.
     *
     * ##### Custom Layouts
     *
     * The general syntax for writing a custom layout is to call `AbstractLayout`'s constructor and assign the
     * return value to a variable:
     *
     * ```
     * jsPlumbToolkit.Layouts["MyLayout"] = function(params) {
    *   var _super = jsPlumbToolkit.Layouts.AbstractLayout.apply(this, arguments);
    *   ...
    *  };
    * ```
    *
    * ##### Lifecycle
    *
    * The lifecycle of a layout - controlled by this class - is as follows:
     *
     * - `begin(_jsPlumbToolkit, parameters)` This is an optional method.
     * - `step(_jsPlumbToolkit, parameters)` This is called repeatedly until your code has indicated that the layout is complete (see below)
     * - `end(_jsPlumbToolkit, parameters)` Also an optional method.
     *
     * ##### Layout Completion
     *
    * You are required to inform the superclass when your layout is complete, via this method:
     *
     * ```
     * _super.setDone(true);
     * ```
     *
     * #### Other Optional Methods
     * Your layout can implement several optional methods should you need finer grained control of the lifecycle:
     *
     * - `_nodeAdded` - Notification that a new Node was added to the dataset.
     * - `_nodeRemoved` - Notification that a new Node was added to the dataset.
     * - `_nodeMoved` - Notification that a Node was moved.
    *
    * @class Layouts.AbstractLayout
     * @abstract
     * @constructor
     * @param {Object} params Constructor parameters
     * @param {Boolean} [params.draggable=true] Whether or not elements should be draggable.
     * @param {Object} [params.dragOptions] Drag options to set on individual elements.
     */
    LAYOUTS.AbstractLayout = function (params) {
        params = params || {};
        var self = this,
            _defaultParameters = function () {
                return { padding: [0, 0] }
            },
        // this takes the current value of 'parameters' and merges it on top of any default param
        // values declared by the layout, then assigns those to the parameters object.
        // it is called at 'begin'
            _prepareParameters = function () {
                var p = root.jsPlumb.extend(_defaultParameters(), self.defaultParameters || {});
                root.jsPlumb.extend(p, parameters || {});
                parameters = p;
            },
            adapter = params.adapter,
            parameters = params.parameters || {},
            getElementForNode = params.getElementForNode,
            magnetizer = root.Farahey.getInstance({
                getPosition: function (o) {
                    var p = positions[o.id];
                    return { left: p[0], top: p[1] };
                },
                getSize: function (o) {
                    return sizes[o.id];
                },
                getId: function (o) {
                    return o.id;
                },
                setPosition: function (o, p) {
                    _setPosition(o.id, p.left, p.top);
                },
                padding: parameters.padding,
                filter:function(id) {
                    // if a node in a group, ignore it.
                    if (_nodes[id] && _nodes[id].group) return false;
                    // otherwise if layout wants to tell us, allow it, otherwise it gets included.
                    return self.canMagnetize ? self.canMagnetize(id) : true;
                }
            }),
            magnetize = params.magnetized === false ? false : (self.defaultMagnetized || params.magnetize === true);

        this.decorators = _initialiseDecorators(params.decorators, params.adapter, params.container);
        this.adapter = params.adapter;

        var _jsPlumb = params.jsPlumb || root.jsPlumb,
            _jsPlumbToolkit = params.jsPlumbToolkit,
        // this x,y location of every element.  all layouts write to this.
        // this is a map whose keys are node ids and whose values are [x,y] positions.  access to it is restricted
        // to the 'getPosition' method, which creates an entry for the given node if one does not yet exist.
            positions = {},
            positionArray = [],
            _minx = Infinity, _miny = Infinity, _maxx = -Infinity, _maxy = -Infinity,
            _nodes = {},
            _groups = {},
            sizes = {},
            container = params.container,
            containerSize = _jsPlumb.getSize(container),
            width = (params.width || containerSize[0]),
            height = (params.height || containerSize[1]),
            done = false,
            _reset = function () {
                done = false;
                _minx = Infinity;
                _maxx = -Infinity;
                _miny = Infinity;
                _maxy = -Infinity;
                // clear decoration
                for (var i = 0; i < self.decorators.length; i++)
                    self.decorators[i].reset({remove: _jsPlumb.remove});
                positions = {};
                positionArray.splice(0);
                sizes = {};
                magnetizer.reset();
                self.reset && self.reset();
            };

        this.getMagnetizedElements = function() { return magnetizer.getElements(); };

        /**
         * Magnetize the display. You must indicate what sort of magnetization you wish to perform: if you provide an event,
         * the event's location will be the magnetization origin. If you provide `origin:{left;xxx, top:xxx}`, that value will be used. If
         * you provide neither, the computed center of all elements will be used. You can also provide an `options:{...}` value, whose
         * values can contain `filter`, `constrain` and `padding` values for the specific run of the magnetizer.
         * @param {Object} [params] Magnetize parameters. If ommitted, the origin of magnetization will be the computed center of all the elements.
         * @param {Event} [params.event] If provided, the event location will be used as the origin of magnetization.
         * @param {Object} [params.origin] An object with `left` and `top` properties. If provided, will be used as the origin of magnetization.
         * @param {Object} [params.options] Extra magnetizer options for this run of the magnetizer.
         */
        this.magnetize = function (params) {
            params = params || {};
            var fn = params.event ? "executeAtEvent" : params.origin ? "execute" : "executeAtCenter";
            var args = params.event ? [params.event, params.options] : params.origin ? [params.origin, params.options] : [params.options];
            magnetizer[fn].apply(magnetizer, args);
            _draw(_jsPlumb.repaintEverything);
        };

        /**
         * Called by components to inform a layout that a new Node was added. You should never
         * call this method directly. Also, you should not override this method in a custom layout: if your layout
         * needs to track Node addition, implement `_nodeAdded` instead.
         * @method nodeAdded
         * @param {Object} params Method args
         * @param {Node} params.node Node that was added
         * @param {Element} params.el The DOM element associated with the Node.
         * @param {Object} [eventInfo] Optional information associated with the Event that the host system needs to pass through without adding to the data model.
         */
        this.nodeAdded = function (params, eventInfo) {
            // stash position and size for this node.
            var up = eventInfo && eventInfo.position ? eventInfo.position :params.node.data && params.node.data.left && params.node.data.top ? params.node.data : self.adapter.getOffset(params.el);
            if (this._nodeAdded) {
                var newPosition = this._nodeAdded(params, eventInfo);
                if (newPosition) {
                    up.left = newPosition[0];
                    up.top= newPosition[1];
                }
            }
            _nodes[params.node.id] = params.node;
            _setPosition(params.node.id, up.left, up.top);
            _getSize(params.node.id, params.el);
            magnetizer.addElement(params.node);
        };

        /**
         * Optional method for subclasses to override should they wish to be informed of Node addition.
         * @method _nodeAdded
         * @param {Object} params Method args
         * @param {Node} params.node Node that was added
         * @param {Object} params.data Data associated with the Node
         * @param {Element} params.el The DOM element associated with the Node.
         */

        /**
         * Called by components to inform a layout that a given Node was removed. You should never
         * call this method directly.
         * @method nodeRemoved
         * @param {String} nodeId  Id of the the Node that was removed.
         */
        this.nodeRemoved = function (nodeId) {
            delete positions[nodeId];
            delete sizes[nodeId];
            delete _nodes[nodeId];
            if (this._nodeRemoved) this._nodeRemoved(nodeId);
            magnetizer.removeElement(params.node);
        };

        /**
         * Optional method for subclasses to implement if they wish to be informed of Node removal.
         * @method _nodeRemoved
         * @param {String} nodeId Id of the Node that was removed.
         */

        /**
         * Called by components to inform a layout that a new Group was added. You should never
         * call this method directly. Also, you should not override this method in a custom layout: if your layout
         * needs to track Group addition, implement `_groupAdded` instead.
         * @method groupAdded
         * @param {Object} params Method args
         * @param {Group} params.group Group that was added
         * @param {Element} params.el The DOM element associated with the Group.
         * @param {Object} [eventInfo] Optional information associated with the Event that the host system needs to pass through without adding to the data model.
         */
        this.groupAdded = function (params, eventInfo) {
            // stash position and size for this group.
            var up = eventInfo && eventInfo.position ? eventInfo.position :params.group.data && params.group.data.left && params.group.data.top ? params.group.data : self.adapter.getOffset(params.el);
            if (this._groupAdded) {
                var newPosition = this._groupAdded(params, eventInfo);
                if (newPosition) {
                    up.left = newPosition[0];
                    up.top= newPosition[1];
                }
            }
            _groups[params.group.id] = params.group;
            _setPosition(params.group.id, up.left, up.top);
            _getSize(params.group.id, params.el);
            magnetizer.addElement(params.group);
        };

        /**
         * Optional method for subclasses to override should they wish to be informed of Group addition.
         * @method _groupAdded
         * @param {Object} params Method args
         * @param {Node} params.group Group that was added
         * @param {Object} params.data Data associated with the Group
         * @param {Element} params.el The DOM element associated with the Group.
         */

        /**
         * Called by components to inform a layout that a given Group was removed. You should never
         * call this method directly.
         * @method groupRemoved
         * @param {String} groupId Id of the Group that was removed.
         */
        this.groupRemoved = function (groupId) {
            delete positions[groupId];
            delete sizes[groupId];
            delete _groups[groupId];
            if (this._groupRemoved) this._groupRemoved(groupId);
            magnetizer.removeElement(params.group);
        };

        /**
         * Optional method for subclasses to implement if they wish to be informed of Group removal.
         * @method _groupRemoved
         * @param {String} groupId  Id of the the Group that was removed.
         */


        /**
         * Optional method for subclasses to implement if they wish to be informed of a Node having moved.
         * @method _nodeMoved
         * @param {String} nodeId  Id of the the Node that was moved.
         * @param {Number} x New X location of the Node.
         * @param {Number} y New Y location of the Node.
         */


        /**
         * Optional method for subclasses to implement if they wish to be informed of a Group having moved.
         * @method _groupMoved
         * @param {String} groupId  Id of the the Group that was moved.
         * @param {Number} x New X location of the Group.
         * @param {Number} y New Y location of the Group.
         */

        /**
         * Gets the size of the node with given id, caching it for later use.
         * @method getSize
         * @param {String} id ID of the node to retrieve size for.
         * @return {Number[]} Width and height of the Node in an array.
         */
        var _getSize = function (id, n) {
                var s = sizes[id];
                if (!s) {
                    n = n || getElementForNode(id);
                    if (n != null) {
                        s = _jsPlumb.getSize(n);
                        sizes[id] = s;
                    }
                    else
                        s = [0, 0];
                }
                return s;
            },
            /**
             * Gets the position of the node with given id, creating it (as a random value) if null and optionally setting values.
             * note this method does a 'pass by reference' thing as the return value - any changes you make will
             * be used by the final layout step (this is a good thing). Note that here it is fine to work with
             * the node's id, as we are not going anywhere near a DOM element yet. When it comes time to
             * actually set a DOM element's position, we use the supplied `getElementForNode` function to
             * get it.  And of course note also that we are not necessarily dealing with DOM elements.
             * @method getPosition
             * @param {String} id ID of the Node to retrieve the position for
             * @param {Number} [x] Optional X location for the Node if its position has not yet been set.
             * @param {Number} [y] Optional Y location for the Node if its position has not yet been set.
             * @param {Boolean} [doNotRandomize=false] If true, won't set a random position for an element whose position is not yet being tracked.
             */
            _getPosition = function (id, x, y, doNotRandomize) {
                var p = positions[id];
                if (!p) {
                    if (x != null && y != null)
                        p = [x, y];
                    else if (!doNotRandomize)
                        p = [Math.floor(Math.random() * (width + 1)), Math.floor(Math.random() * (height + 1))];
                    else return null;

                    _setPosition(id, p[0], p[1]);
                }
                return p;
            },
            _updateMinMax = function (p) {
                _minx = Math.min(_minx, p[0]);
                _miny = Math.min(_miny, p[1]);
                _maxx = Math.max(_maxx, p[0]);
                _maxy = Math.max(_maxy, p[1]);
            },
            _doSetPosition = function(id, x, y) {
                var p = positions[id];
                if (!p) {
                    p = positions[id] = [ parseFloat(x), parseFloat(y) ];
                    positionArray.push([p, id]);
                }
                else {
                    p[0] = parseFloat(x);
                    p[1] = parseFloat(y);
                }

                _updateMinMax(p);
            },
            _doUpdateAfterMove = function(id, x, y) {
                if (_nodes[id] && self._nodeMoved) {
                    self._nodeMoved(id, x, y);
                }
                else if (_groups[id] && self._groupMoved) {
                    self._groupMoved(id, x, y);
                }
            },
            _setMagnetizedPosition = this.setMagnetizedPosition = function (id, x, y, updateMove) {
                _doSetPosition(id, x, y);
                this.magnetize({
                    options:{
                        filter:function(nodeId) {
                            return nodeId === id;
                        },
                        padding:[5,5],
                        exclude:function(id, el) {
                            return el.group != null;
                        },
                        excludeFocus:true
                    }
                });
                var p = this.getPosition(id);
                if (updateMove) {
                    _doUpdateAfterMove(id, p[0], p[1]);
                }
                return p;
            },
            /**
             * Sets the Position of the Node with the given ID.
             * @method setPosition
             * @param {String} id ID of the Node to set the position for
             * @param {Number} x X location for the Node.
             * @param {Number} y Y location for the Node.
             */
            _setPosition = this.setPosition = function (id, x, y, updateMove) {
                _doSetPosition(id, x, y);

                if (updateMove) {
                    _doUpdateAfterMove(id, x, y);
                }
            },
        /*
         * Gets a random position for the Node with the given ID.
         * @param {String} id ID of the Node to get a random position for
         * @param {Number} [w] Optional max width constraint for the value. Defaults to 10.
         * @param {Number} [h] Optional max height constraint for the value. Defaults to 10.
         * @returns {Number[]} [x,y] position for the Node.
         * @private
         */
            _getRandomPosition = function (id, w, h) {
                w = w || 10;
                h = h || 10;
                var p = positions[id];
                if (!p) {
                    p = positions[id] = [];
                }
                p[0] = Math.floor(Math.random() * w);
                p[1] = Math.floor(Math.random() * h);
                _updateMinMax(p);
                return p;
            },
            dumpPos = function () {
                for (var e in positions)
                    console.log(e, positions[e][0], positions[e][1]);
            },
            _positionNode = function (nodeId, onComplete) {
                var el = getElementForNode(nodeId);

                if (el != null) {
                    var o = positions[nodeId];
                    self.adapter.setPosition(el, o[0], o[1], onComplete);
                    savedPositions[nodeId] = [ o[0], o[1] ];
                    return o.concat(_getSize(nodeId));
                }

                return null;
            }.bind(this),

            _draw = this.draw = function (onComplete) {
                for (var e in positions) {
                    var o = _positionNode(e);
                    if (o != null) {
                        _minx = Math.min(o[0], _minx);
                        _miny = Math.min(o[1], _miny);
                        _maxx = Math.max(o[0] + o[2], _maxx);
                        _maxy = Math.max(o[1] + o[3], _maxy);
                    }
                }

                for (var i = 0; i < self.decorators.length; i++) {
                    self.decorators[i].decorate({
                        adapter: self.adapter,
                        layout: self,
                        append: function(el, id, pos) {
                            self.adapter.append(el, id, pos, true);
                        },
                        setAbsolutePosition: self.adapter.setAbsolutePosition,
                        toolkit: _jsPlumbToolkit,
                        jsPlumb: _jsPlumb,
                        bounds: [_minx, _miny, _maxx, _maxy],
                        floatElement:self.adapter.floatElement,
                        fixElement:self.adapter.fixElement
                    });
                }
                onComplete && onComplete();
            },
            bb = function (msg) {
                console.log(msg);
                var b = getBoundingBox(positions, _getSize, getElementForNode);
                dumpPos();
                console.log(b[0], b[1], b[2], b[3]);
            };

        // debug
        this.bb = bb;

        var getPositions = this.getPositions = function () {
            return positions;
        };
        var getPosition = this.getPosition = function (id) {
            return positions[id];
        };
        var savedPositions = {};

        var getSize = this.getSize = function(id) {
            return sizes[id];
        };

        /**
         * Sets what the layout considers to be the size of the node with the given id. This method is not
         * generally necessary if you use the `layout` methods on the surface widget.
         * @param {String} id ID of the Node to set the size for.
         * @param {Number[]} s Size of the node.
         */
        var setSize = this.setSize = function(id, s) {
            sizes[id] = s;
        };

        /**
         * This is an abstract function that subclasses may implement if they wish. It will be called at the beginning of a layout.
         * @method begin
         * @abstract
         * @param {jsPlumbToolkitInstance} _jsPlumbToolkit The associated jsPlumbToolkit instance
         * @param {Object} parameters Parameters configured for the layout.
         */
        this.begin = function (_jsPlumbToolkit, parameters) { };

        /**
         * This is an abstract function that subclasses may implement if they wish. It will be called at the end of a layout.
         * @method end
         * @abstract
         * @param {jsPlumbToolkitInstance} _jsPlumbToolkit The associated jsPlumbToolkit instance
         * @param {Object} parameters Parameters configured for the layout.
         */
        this.end = function (_jsPlumbToolkit, parameters) { };

        // private method that actually runs the layout.
        var _layout = function (onComplete) {
            if (_jsPlumbToolkit == null) return;
            _prepareParameters();
            magnetizer.setElements(adapter.getNodes()).addElements(adapter.getGroups(), true);
            this.begin && this.begin(_jsPlumbToolkit, parameters);

            var _end = function () {
                _draw(function () {
                    if (magnetize) {
                        self.magnetize();
                    }

                    self.end && self.end(_jsPlumbToolkit, parameters);

                    onComplete && onComplete();
                });
            };

            while (!done) {
                this.step(_jsPlumbToolkit, parameters);
            }

            _end();

        }.bind(this);

        /**
         * Runs the layout, first doing a reset of element positions. Next, if the subclass has defined a `begin` method, that will
         * be called first.  Then, the subclass's `step` method will be called repeatedly, until the subclass makes a call to `_super.setDone`.
         * Use the `layout` method to run the layout incrementally without first resetting everything.
         * @method relayout
         * @param {Object} [newParameters]  Optional new set of parameters to apply.
         * @param {Function} [onComplete] Optional function to call on completion of relayout.
         */
        this.relayout = function (newParameters, onComplete) {
            _reset();
            if (newParameters != null)
                parameters = newParameters;
            _layout(onComplete);
        };

        /**
         * Runs the layout, without resetting calculated or user-provided positions beforehand.
         * If the subclass has defined a `begin` method, that will be called first.  Then, the subclass's
         * `step` method will be called repeatedly, until the subclass makes a call to `_super.setDone`.
         * @method layout
         */
        this.layout = function (onComplete) {
            done = false;
            _layout(onComplete);
        };

        /**
         * Resets user-supplied and calculated positions.
         * @method clear
         */
        this.clear = function () {
            _reset();
        };

        function _positionNodesInsideGroups() {
            // ---------------------------- this section needs to move into some "group aware" thing, probably in the root layout,
// because any layout that supports Groups should support the placement of Nodes inside the Groups.

            var _defaultLocationFunction = function (n) {
                return [ n.data.left, n.data.top ];
            };
            var _findLocation = function(v, parameters) {
                return (params.locationFunction || _defaultLocationFunction)(v);
            };

            var nodes, i, j, gc = _jsPlumbToolkit.getGroupCount(), group;
            for (i = 0; i < gc; i++) {
                group = _jsPlumbToolkit.getGroupAt(i);
                nodes = group.getVertices();
                for (j = 0; j < nodes.length; j++) {
                    var l = _findLocation(nodes[j]);
                    _setPosition(nodes[j].id, l[0], l[1]);
                }
            }
        }

        return {
            adapter: params.adapter,
            jsPlumb: _jsPlumb,
            toolkit: _jsPlumbToolkit,
            getPosition: _getPosition,
            setPosition: _setPosition,
            getRandomPosition: _getRandomPosition,
            getSize: _getSize,
            setSize: setSize,
            getPositions: getPositions,
            setPositions: function (p) {
                positions = p;
            },
            width: width,
            height: height,
            reset: _reset,
            draw: _draw,
            setDone: function (d) {
                done = d;
                _positionNodesInsideGroups();
            }
        };
    };

    /**
     * A layout that does very little beyond implementing the functions present in the layout API
     * @class Layouts.EmptyLayout
     * @extends Layouts.AbstractLayout
     */
    LAYOUTS.EmptyLayout = function (adapter) {
        var positions = {};
        this.refresh =
            this.relayout =
                this.layout = function () {
                    // here we assign 0,0 to everything.
                    this.clear();
                    var vc = adapter.getNodeCount();
                    for (var i = 0; i < vc; i++) {
                        var v = adapter.getNodeAt(i);
                        positions[v.getFullId()] = [0, 0];
                    }
                    vc = adapter.getGroupCount();
                    for (i = 0; i < vc; i++) {
                        v = adapter.getGroupAt(i);
                        positions[v.id] = [0, 0];
                    }
                };

        this.nodeRemoved = this.groupRemoved = function (obj) {
            delete positions[obj.id];
        };
        this.nodeAdded = this.groupAdded = function (obj) {
            positions[obj.id] = false;
        };
        this.getPositions = function () {
            return positions;
        };
        this.getPosition = function (id) {
            return positions[id];
        };
        this.setPosition = function (id, x, y) {
            positions[id] = [x, y];
        };

        this.clear = function () { };

        this.getMagnetizedElements = function() { return []; };
    };

    /**
     * Mistletoe layout grows on another layout and does nothing except override lifecycle events and then
     * update itself once all the hard work has been done. It is used by the Miniview component.
     * @class Layouts.Mistletoe
     * @extends Layouts.AbstractLayout
     * @constructor {Object} params Constructor parameters
     * @param {Layouts.AbstractLayout} params.layout The layout on which to leech.
     */
    LAYOUTS.Mistletoe = function (params) {
        if (!params.parameters.layout) throw ("No layout specified for MistletoeLayout");
        var _map = {};
        var p = root.jsPlumb.extend({}, params);
        p.getElementForNode = function (nId) {
            return _map[nId];
        };

        var _super = LAYOUTS.AbstractLayout.apply(this, [p]),
            layout = params.parameters.layout,
            _redraw = function () {
                _super.setPositions(layout.getPositions());
                _super.draw();
                this.fire("redraw");
            }.bind(this),
        // original refs
            _layout, _relayout, _clear;

        JUTIL.EventGenerator.apply(this, arguments);

        this.map = function (nodeId, el) {
            _map[nodeId] = el;
        };

        var _attach = function () {
            _map = {}, _layout = layout.layout, _relayout = layout.relayout, _clear = layout.clear;
            layout.layout = function () {
                _layout.apply(layout, arguments);
                _redraw();
            };

            layout.relayout = function () {
                _super.reset();
                _relayout.apply(layout, arguments);
                _redraw();
            };

            layout.clear = function () {
                _clear.apply(layout, arguments);
                _super.reset();
            };
        };

        _attach();

        /**
         * Set the layout on which to base this layout.
         */
        this.setHostLayout = function (l) {
            layout = l;
            _attach();
        };
    };

    /**
     * Mixin for layouts that have an absolute backing.  This includes, of course, the `Absolute` layout,
     * which is actually just a direct reference to this class.
     * The default behaviour is to look for a `left` and `top` member in each Node/Group, but you
     * can supply a `locationFunction` parameter to the constructor to derive your own
     * position from each Node/Group.
     * @class Layouts.AbsoluteBackedLayout
     * @extends Layouts.AbstractLayout
     * @constructor
     * @param {Object} params Constructor parameters
     * @param {Function} [params.locationFunction] Takes a Node/Group and returns an [x,y] array indicating
     * the location of the given Node/Group. The backing data for a Node/Group is available as the `data` property.
     */
    var AbsoluteBackedLayout = LAYOUTS.AbsoluteBackedLayout = function (params) {
        params = params || {};
        var _super = LAYOUTS.AbstractLayout.apply(this, arguments);
        var _defaultLocationFunction = function (n) {
            return [ n.data.left, n.data.top ];
        };
        var _findLocation = function(v, parameters) {
            return (params.locationFunction || _defaultLocationFunction)(v);
        };

        var _oneSet = function(countMethod, getMethod, toolkit, parameters) {
            var count = _super.adapter[countMethod]();

            for (var i = 0; i < count; i++) {
                var v = _super.adapter[getMethod](i),
                    id = v.getFullId(),
                    p = _super.getPosition(id, null, null, true);

                // if no position yet tracked, get it from the data.
                if (p == null)
                    p = _findLocation(v, parameters);

                // we position ALL Nodes here, including those inside Groups.
                this.setPosition(id, p[0], p[1], true);
            }
        }.bind(this);

        this.begin = function (toolkit, parameters) {
            _oneSet("getNodeCount", "getNodeAt", toolkit, parameters);
            _oneSet("getGroupCount", "getGroupAt", toolkit, parameters);
        };

        // override _nodeAdded so we can set initial pos
        this._nodeAdded = function(nodeAddParams, eventInfo) {
            return _findLocation(nodeAddParams.node, params.parameters || {});
        };

        // override _groupAdded so we can set initial pos
        this._groupAdded = function(groupAddParams, eventInfo) {
            return _findLocation(groupAddParams.group, params.parameters || {});
        };

        /**
         * Gets the position for the given Node/Group as dictated by either the `left`/`top` properties, or some other nominated pair, in the Node/Group's data.
         * This position is what the Absolute layout uses itself, and this method exposes the absolute position for subclasses that wish to make use
         * of the absolute backing.
         * @param {Node|Group} v Node/Group to get absolute position for.
         * @param {Object} parameters Constructor parameters. May contain a custom `locationFunction`.
         * @returns {Number[]}
         */
        this.getAbsolutePosition = function(v, parameters) {
            return _findLocation(v, parameters);
        };

        this.step = function () {
            _super.setDone(true); // all the work was done in 'begin'
        };

        return _super;
    };
    JUTIL.extend(AbsoluteBackedLayout, LAYOUTS.AbstractLayout);

    /**
     * This layout places elements with absolute positioning. The default is to look for a `left` and `top`
     * member in each Node/Group, but you can supply your own `locationFunction` parameter to the constructor to
     * derive your own position from each Node/Group.
     * @class Layouts.Absolute
     * @extends Layouts.AbsoluteBackedLayout
     * @constructor
     * @param {Object} params Constructor parameters
     * @param {Function} [params.locationFunction] Takes Node/Group data and returns an [x,y] array indicating the location of the given Node/Group.
     */
    LAYOUTS.Absolute = function (params) {
        LAYOUTS.AbsoluteBackedLayout.apply(this, arguments);
    };
    JUTIL.extend(LAYOUTS.Absolute, LAYOUTS.AbsoluteBackedLayout);

    /**
     * Mixin for hierarchical layouts (those that expect a root node). This class takes care of
     * putting `rootNode` and `root` values in the parameters that are subsequently passed into the
     * various lifecycle methods of the layout. The layout supports multiple root elements; if you do not supply a root then
     * the default behaviour is to look for all top level Nodes and Groups that are not the target of any Edges. You can switch off multiple
     * roots, and then the root element is the first Node (or Group, if there are no top level Nodes) found in the Graph (ie the first Node
     * or Group you added to the Graph)
     * @class Layouts.AbstractHierarchicalLayout
     * @extends Layouts.AbstractLayout
     * @constructor
     * @param {Object} params Constructor parameters
     * @param {Boolean} [params.ignoreLoops=true] Whether or not to ignore loops in the layout. When false,
     * an exception will be thrown if a loop is found.
     * @param {Boolean} [params.multipleRoots=true] If false, multiple root elements are not supported.
     * @param {Function} [params.getRootNode] Optional function that can return the Node(s)/Group(s) that should be the root(s)
     * of the hierarchy. If this is not provided and `multipleRoots` is not set to false, all top level Nodes and all Groups that are not the target
     * of any Edges form the set of root elements. If `multipleRoots` is set to false then the first top level Node in the Toolkit is used, or if no such Node
     * exists, then the first Group is used.
     * @param {Function} [params.getChildEdges] Optional function to be used to get edges to child elements for each Node/Group. The
     * default is simply to look for Nodes/Groups that are targets of an Edge from the focus Node/Group (or one of a Node's port)s. Note that here we
     * use the term "children" to mean elements that should appear in the next row/column from the focus element; the children
     * of a Group itself are a different concept.
     * @param {Boolean} [params.ignorePorts=false] If true, Ports will not be considered when looking for edges (by the default getChildEdges function..if your
     * provide your own getChildEdges function this parameter is ignored.)
     */
    var AbstractHierarchicalLayout = LAYOUTS.AbstractHierarchicalLayout = function (params) {
        var self = this,
            _super = LAYOUTS.AbstractLayout.apply(this, arguments);

        self.begin = function (toolkit, parameters) {
            parameters.ignoreLoops = !(params.ignoreLoops === false);
            parameters.getRootNode = parameters.getRootNode || function(toolkit) {
                if (params.multipleRoots !== false) {
                    return toolkit.filter(function(o) {
                            return (o.objectType === "Node" && o.getTargetEdges().length == 0 && o.group == null) ||
                                (o.objectType === "Group" && o.getTargetEdges().length == 0);
                        }).getAll();
                }
                else {
                    return (_super.adapter.getNodeCount() > 0) ? _super.adapter.getNodeAt(0) : null;
                }
            };
            parameters.getChildEdges = parameters.getChildEdges || function(node, toolkit) {
                return _super.toolkit.getAllEdgesFor(node, function(e) {
                    return e.source === node || (params.ignorePorts !== true && e.source.getNode && e.source.getNode() === node);
                });
            };
            parameters.rootNode = parameters.getRootNode(toolkit);
            if (!parameters.rootNode) {
                _super.setDone(true);
            }
        };

        return _super;
    };
    JUTIL.extend(AbstractHierarchicalLayout, LAYOUTS.AbstractLayout);

}).call(typeof window !== 'undefined' ? window : this);

/*
 * Circular Layout
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 * This file contains the Circular layout.
 *
 */
/**
 * @name jsPlumbToolkit.Layouts.Circular
 * @desc Provides a circular layout.
 */
/**
 * @constructor
 * @param {Object} params Constructor parameters
 * @param {Integer} [params.padding=30] Minimum distance between a node and its neighbours. Defaults to 30 pixels.
 */
;
(function () {

    "use strict";

    var root = this;
    var JTK = root.jsPlumbToolkit;
    var exports = JTK.Layouts;
    var FARAHEY = root.Farahey;

    exports.Circular = function (params) {
        params = params || {};
        var _super = exports.AbstractLayout.apply(this, arguments);
        var centerRootNode = params.parameters ? params.parameters.centerRootNode === true : false;

        this.defaultParameters = {
            padding: 30,
            locationFunction:params.locationFunction
        };

        // filter nodes that are in groups. also, if centerRootNode is true, omit it from the nodes.
        function filterNodes(nodes) {
            var out = [], startIdx = centerRootNode ? 1 : 0;
            for (var i = startIdx; i < nodes.length; i++) {
                if (!nodes[i].group) {
                    out.push(nodes[i]);
                }
            }
            return out;
        }

        this.step = function (toolkit, parameters) {
            var elements = [], nodes = _super.adapter.getNodes();


            if (nodes.length === 0) {
                _super.setDone(true);
                return;
            }

            Array.prototype.push.apply(elements, filterNodes(nodes));
            Array.prototype.push.apply(elements, _super.adapter.getGroups());

            var x = 0, y = 0, i, n,
                radius = 10,
                degreesPerNode = 2 * Math.PI / elements.length,
                curDegree = -Math.PI / 2;

            if (centerRootNode) {
                var s = _super.getSize(nodes[0].id);
                radius = Math.max(s[0], s[1]) + 80;
            }

            // The basic algorithm is to set a radius of 10 and assign a center to each of the elements, and as
            // we go along we keep track of the radius of the circle required for each node
            // as if all the elements were as large as the largest one. We can do that by drawing a box whose
            // dimensions are as big as the node at loc 0,0.  we do this at every step and keep a record of the
            // largest value. Finally we loop through again and set everything to this radius.
            // 01/17/17: updated to support centering the 'root' node of the dataset. if this is set we use the size
            // of that node's major axis, plus some padding, as our initial radius.
            for (i = 0; i < elements.length; i++) {
                n = elements[i];
                _super.setPosition(n.id, x + (Math.sin(curDegree) * radius), y + (Math.cos(curDegree) * radius), true);
                curDegree += degreesPerNode;

                if (i > 0) {
                    var n1 = elements[i-1],
                        s1 = _super.getSize(n1.id),
                        p1 = _super.getPosition(n1.id),
                        r1 = {
                            x: p1[0] - parameters.padding,
                            y: p1[1] - parameters.padding,
                            w: s1[0] + (2 * parameters.padding),
                            h: s1[1] + (2 * parameters.padding)
                        },
                        n2 = elements[i],
                        s2 = _super.getSize(n2.id),
                        p2 = _super.getPosition(n2.id),
                        r2 = {
                            x: p2[0] - parameters.padding,
                            y: p2[1] - parameters.padding,
                            w: s2[0] + (2 * parameters.padding),
                            h: s2[1] + (2 * parameters.padding)
                        },
                        adj = FARAHEY.calculateSpacingAdjustment(r1, r2);

                    var c1 = [ p1[0] + (s1[0] / 2), p1[1] + (s1[1] / 2)],
                        c2 = [ p2[0] + adj.left + (s2[0] / 2), p2[1] + adj.top + +(s2[1] / 2)],
                        d = Math.sqrt(Math.pow(c1[0] - c2[0], 2) + Math.pow(c1[1] - c2[1], 2));

                    radius = Math.max(radius, (d / 2) / Math.sin(degreesPerNode / 2));
                }
            }

            for (i = 0; i < elements.length; i++) {
                n = elements[i];
                _super.setPosition(n.id, x + (Math.sin(curDegree) * radius), y + (Math.cos(curDegree) * radius), true);
                curDegree += degreesPerNode;
            }

            _super.setDone(true);
        };
    };
}).call(typeof window !== 'undefined' ? window : this);

/*
 * Hierarchical Layout
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
/**
 * Provides a hierarchical tree layout, oriented either horizontally or vertically.
 * @class Layouts.Hierarchical
 * @constructor
 * @param {Object} params Constructor parameters
 * @param {String} [params.orientation="horizontal"] Orientation of the layout. Valid values are `"vertical"` and `"horizontal"`.
 * @param {Number[]} [params.padding] Array of padding values for x and y axes. Default is `[60, 60]`.
 * @param {Boolean} [compress = false] If true, the layout will use a regular spacing between each node and its parent. Otherwise
 * the layout pushes each node down by the maximum size of some element in that level of the hierarchy. For complex
 * hierarchies in which any given node may have children, that is better. But for simple hierarchies, setting
 * `compress` can give good results.
 */
;
(function () {

    "use strict";

    var root = this;
    var JTK = root.jsPlumbToolkit;
    var exports = JTK.Layouts;
    var JUTIL = root.jsPlumbUtil;

    exports.Hierarchical = function (params) {
        var _super = exports.AbstractHierarchicalLayout.apply(this, arguments),
            orientation, _horizontal, axisIndex, axisDimension, padding,
            maxSizes = [],
            _visitedNodes,
            compress = params.parameters != null ? params.parameters.compress : false,
            _hierarchy = [], _childGroups = [],
            _id = _super.toolkit.getNodeId,
            _getChildEdges,
            _get = function (depth) {
                var h = _hierarchy[depth];
                if (!h) {
                    h = { nodes: [], pointer: 0 };
                    _hierarchy[depth] = h;
                }
                return h;
            },
            _add = function (node, nodeSize, depth, parent, childGroup) {
                // get the info for this level; info contains a list of nodes and a current pointer for position
                // of the next inserted node. this pointer is incremented by the size of each new node plus padding.
                // note that we have derived 'axisIndex' above to tell us whether to use width or height, depending on the
                // layout's orientation.
                var h = _get(depth),
                // make an entry for this node.
                    i = {
                        node: node,
                        parent: parent,
                        childGroup: childGroup,
                        loc: h.pointer,
                        index: h.nodes.length,
                        dimensions: nodeSize,
                        size: nodeSize[axisIndex]
                    };
                var otherAxis = nodeSize[axisIndex == 0 ? 1 : 0];

                if (maxSizes[depth] == null)
                    maxSizes[depth] = otherAxis;
                else
                    maxSizes[depth] = Math.max(maxSizes[depth], otherAxis);

                // increment the pointer by the size of the node plus padding.
                h.pointer += (nodeSize[axisIndex] + padding[axisIndex]);
                // add the new node.
                h.nodes.push(i);
                return i;
            },
        // register a child group at a given depth.
            _addChildGroup = function (cg, depth) {
                var level = _childGroups[depth];
                if (!level) {
                    level = [];
                    _childGroups[depth] = level;
                }
                cg.index = level.length;
                level.push(cg);
            },
            _centerChildGroup = function (cg) {
                if (cg.size > 0) {
                    var idealLoc = (cg.parent.loc + (cg.parent.size / 2)) - ((cg.size - padding[axisIndex]) / 2); // remove last padding from child group in size calc
                    // get the existing groups for this groups level and find the furthest pointer.
                    var groups = _childGroups[cg.depth],
                        lastPointer = -Infinity,
                        delta = 0;

                    if (groups != null && groups.length > 0) {
                        var lg = groups[groups.length - 1],
                            lgn = lg.nodes[lg.nodes.length - 1];
                        lastPointer = lgn.loc + lgn.size + padding[axisIndex];
                    }

                    if (idealLoc >= lastPointer) {
                        cg.loc = idealLoc;
                    }
                    else {
                        delta = lastPointer - idealLoc;
                        cg.loc = lastPointer;
                    }

                    // place the nodes in the child group now.
                    // we may now have to re-center the parent for this group
                    var _l = cg.loc;
                    for (var i = 0; i < cg.nodes.length; i++) {
                        cg.nodes[i].loc = _l;
                        _l += cg.nodes[i].size;
                        _l += padding[axisIndex];
                    }

                    if (delta > 0) {
                        _centerParents(cg);
                    }

                    _addChildGroup(cg, cg.depth);
                }
            },
            _centerParent = function (cg) {
                var min = cg.nodes[0].loc,
                    max = cg.nodes[cg.nodes.length - 1].loc + cg.nodes[cg.nodes.length - 1].size,
                    c = (min + max) / 2,
                    pl = c - (cg.parent.size / 2),
                    pDelta = pl - cg.parent.loc;

                cg.parent.loc = pl;

                if (!cg.parent.root) {
                    // now, find the child group the parent belongs to, and its index in the child group, and adjust the
                    // rest of the nodes to the right of the parent in that child group.
                    var parentChildGroup = cg.parent.childGroup;
                    for (var i = cg.parent.childGroupIndex + 1; i < parentChildGroup.nodes.length; i++)
                        parentChildGroup.nodes[i].loc += pDelta;
                }
            },
            _centerParents = function (cg) {
                var _c = cg;
                while (_c != null) {
                    _centerParent(_c);
                    _c = _c.parent.childGroup;
                }
            },
            _isNodeEdgeSource = function(node, edge) {
                return edge.source === node || (edge.source.getNode && edge.source.getNode() === node);
            },
            _doOne = function (info, level) {
                if (_visitedNodes[info.node.id]) return;
                _visitedNodes[info.node.id] = true;
                var edges = _getChildEdges(info.node, _super.toolkit),
                    childGroup = {
                        nodes: [], loc: 0, size: 0, parent: info, depth: level + 1
                    },
                    childInfoList = [], i,
                    visitedChildNodes = {};

                for (i = 0; i < edges.length; i++) {
                    // for each child node, get the node and its element object and dimensions
                    var childNode = _isNodeEdgeSource(info.node, edges[i]) ? edges[i].target: edges[i].source;
                    if (childNode.getNode) childNode = childNode.getNode();
                    childNode = _super.toolkit.getNode(childNode);
                    if (childNode != null && childNode !== info.node && !visitedChildNodes[childNode.id]) {
                        var s = _super.getSize(_id(childNode)),
                        // add the child node to the appropriate level in the hierarchy
                        childInfo = _add(childNode, s, level + 1, info, childGroup);
                        // and add it to this node's childGroup too.
                        childInfo.childGroupIndex = childGroup.nodes.length;
                        childGroup.nodes.push(childInfo);
                        // calculate how much room this child group takes
                        childGroup.size += (s[axisIndex] + padding[axisIndex]);
                        childInfoList.push(childInfo);
                        visitedChildNodes[childNode.id] = true;//
                    }
                }
                // now try to center this child group, with its computed size. this will place the individual node
                // entries, and adjust parents and their siblings as necessary.
                _centerChildGroup(childGroup);

                for (i = 0; i < childInfoList.length; i++) {
                    _doOne(childInfoList[i], level + 1);
                }
            };

        this.defaultParameters = {
            padding: [60, 60],
            orientation: "horizontal",
            border: 0,
            locationFunction:params.locationFunction
        };

        var sb = this.begin;
        this.begin = function (toolkit, parameters) {
            sb.apply(this, arguments);
            orientation = parameters.orientation;
            _horizontal = (orientation === "horizontal");
            axisIndex = _horizontal ? 0 : 1;
            axisDimension = _horizontal ? "width" : "height";
            padding = parameters.padding;
            _hierarchy.length = 0;
            _childGroups.length = 0;
            _visitedNodes = {};
            _getChildEdges = parameters.getChildEdges;
        };

        this.step = function (toolkit, parameters) {

            var rootNodes = JUTIL.isArray(parameters.rootNode) ? parameters.rootNode : [ parameters.rootNode ],
                currentRoot, i, j;

            for (var r = 0; r < rootNodes.length; r++) {
                currentRoot = rootNodes[r];
                var rs = _super.getSize(currentRoot.id),
                    info = _add(currentRoot, rs, 0, null, null);

                info.root = true;
                // this will recurse down and place everything.
                _doOne(info, 0, null);
                // write positions.
                var otherAxis = 0, x, y, _otherAxis = function (n, oa) {
                    var oai = axisIndex == 0 ? 1 : 0;
                    return compress && n.parent ?
                        _super.getPosition(_id(n.parent.node))[oai] + n.parent.dimensions[oai] + padding[oai]
                        : oa;
                };
                for (i = 0; i < _hierarchy.length; i++) {
                    _hierarchy[i].otherAxis = otherAxis;
                    for (j = 0; j < _hierarchy[i].nodes.length; j++) {
                        x = axisIndex == 0 ? _hierarchy[i].nodes[j].loc : _otherAxis(_hierarchy[i].nodes[j], otherAxis);

                        if (_hierarchy[i].nodes[j].parent) {
                            _super.getPosition(_id(_hierarchy[i].nodes[j].parent.node));
                        }

                        y = axisIndex == 1 ? _hierarchy[i].nodes[j].loc : _otherAxis(_hierarchy[i].nodes[j], otherAxis);
                        // check to see if we will overlap the parent node?
                        _super.setPosition(_id(_hierarchy[i].nodes[j].node), x, y, true);
                    }
                    _hierarchy[i].otherAxisSize = (maxSizes[i] + padding[axisIndex == 0 ? 1 : 0]);
                    otherAxis += _hierarchy[i].otherAxisSize;
                }

            }

            _super.setDone(true);
        };

        /**
         * Gets the computed hierarchy. This is returned as an array of objects, one for each level, inside which
         * there is a `nodes` array.
         * @method getHierarchy
         * @returns {Array}
         */
        this.getHierarchy = function() { return _hierarchy; };

        /**
         * Gets the orientation of the layout - "horizontal" or "vertical".
         * @returns {String} "horizontal" or "vertical"
         */
        this.getOrientation = function() {
            return orientation;
        };

        //override nodeRemoved to clear hierarchy; it must be rebuilt
        var nr = this.nodeRemoved;
        this.nodeRemoved = function () {
            _hierarchy = [];
            nr.apply(this, arguments);
        };

        this.getPadding = function() { return padding; };
    };

    JUTIL.extend(exports.Hierarchical, exports.AbstractHierarchicalLayout);


}).call(typeof window !== 'undefined' ? window : this);

;(function() {
    var root = this;
    var JTK = root.jsPlumbToolkit;

    JTK.Layouts.Decorators["Hierarchy"] = function(options) {
        var els = [], lbl, padding;

        this.reset = function(params) {
            for (var i = 0; i < els.length; i++) {
                params.remove(els[i]);
            }
            if (lbl) params.remove(lbl);
            els.length = 0;
        };

        this.decorate = function(params) {
            if (params.bounds[0] == Infinity) return;
            var hierarchy = params.layout.getHierarchy();
            padding = (params.layout.getPadding() || [60, 60])[o === "horizontal" ? 0 : 1];
            var o = params.layout.getOrientation(),
                axisInfo = o === "horizontal" ? [ "width", "height", params.bounds[2] - params.bounds[0] ] :
                    [ "height", "width", params.bounds[3] - params.bounds[1]];

            for (var i = 0; i < hierarchy.length; i++) {
                var bg = document.createElement("div");
                params.append(bg);
                bg.className = "level " + (i % 2 ? "odd" : "even");
                bg.style[axisInfo[0]] = (axisInfo[2] + (padding * 2 )) + "px";
                bg.style[axisInfo[1]] = hierarchy[i].otherAxisSize + "px";

                var levelBounds = o === "horizontal" ?
                    [params.bounds[0] - padding, hierarchy[i].otherAxis - (padding/2)] :
                    [ hierarchy[i].otherAxis - (padding/2), params.bounds[1] - padding ];

                params.setAbsolutePosition(bg, levelBounds);

            }
        };
    };

}).call(typeof window !== 'undefined' ? window : this);
/*
 * Spring Layout
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */

/**
 * Provides a force directed graph layout in which connections between nodes are modelled as springs. By default, this Layout
 * switches on the magnetizer, to ensure that no nodes overlap.  You can switch it off via the `magnetize:false` argument
 * in the `layout` parameters of a `render` call.
 * @class jsPlumbToolkit.Layouts.Spring
 * @extends jsPlumbToolkit.Layouts.AbstractLayout
 * @constructor
 * @param {Object} params Constructor parameters
 * @param {Boolean} [params.absoluteBacked=true] Whether or not the layout will fall back to absolute positions stored in the data.
 * @param {Number} [params.stiffness=200] A measure of how stiff the springs are modelled to be.
 * @param {Number} [params.repulsion=200] A measure of how much each Node repels every other Node.
 * @param {Number} [params.damping=0.5] A measure of how quickly the system settles. This parameter should always be
 * set to a value less than 1. A higher value for this parameter will cause the layout to take longer to run.
 * @param {Number} [params.limit=1000] The threshold below which the system is assumed to be stable enough for the
 * layout to exit. This value is related to the values you provide for stiffness and repulsion (and damping, of course,
 * but to a lesser extent).
 */
;
(function () {

    "use strict";

    var root = this;
    var JTK = root.jsPlumbToolkit;
    var exports = JTK.Layouts;
    var JUTIL = root.jsPlumbUtil;

    exports.Spring = function (params) {
        this.defaultMagnetized = true;
        var _super = exports.AbsoluteBackedLayout.apply(this, arguments);

        this.defaultParameters = {
            padding: [50, 50],
            iterations: 500,
            maxRepulsiveForceDistance: 6,
            k: 2,
            c: 0.01,
            maxVertexMovement: 0.5,
            locationFunction:params.locationFunction
        };
        var currentParameters = this.defaultParameters;

        var _nodes = {},
            _absoluteBacked = params.absoluteBacked !== false,
            currentIteration = 0,
            minx = Infinity, maxx = -Infinity,
            miny = Infinity, maxy = -Infinity,
            xScale = 1, yScale = 1, /*nodeCount, groupCount, */elements,
            _moveCount = 0,
            _get = function (obj) {

                // get actual Node, if this was a Port.
                if (obj.getNode) {
                    obj = obj.getNode();
                }

                var n = _nodes[obj.id];
                if (!n) {
                    var pos = _super.getRandomPosition(obj.id, 0.5, 0.5);
                    n = _nodes[obj.id] = {
                        id: obj.id,
                        n: obj,
                        // randomize current point.
                        sp: pos,
                        p: [ pos[0], pos[1] ],
                        f: [0, 0]
                    };
                }
                return n;
            },
            _pos = function (node, x, y) {
                minx = Math.min(minx, x);
                miny = Math.min(miny, y);
                maxx = Math.max(maxx, x);
                maxy = Math.max(maxy, y);
                node.p[0] = x;
                node.p[1] = y;
            },
            _repulsion = function (node1, node2) {
                // if both nodes locked, return.
                if (node1.locked && node2.locked) return;

                var dx = node2.p[0] - node1.p[0];
                var dy = node2.p[1] - node1.p[1];
                var d2 = dx * dx + dy * dy;
                if (d2 < 0.01) {
                    dx = 0.1 * Math.random() + 0.1;
                    dy = 0.1 * Math.random() + 0.1;
                    d2 = dx * dx + dy * dy;
                }

                var d = Math.sqrt(d2);
                if (d < currentParameters.maxRepulsiveForceDistance) {
                    _moveCount++;
                    var repulsiveForce = currentParameters.k * currentParameters.k / d,
                        xRepulsive = repulsiveForce * dx / d,
                        yRepulsive = repulsiveForce * dy / d;

                    node2.f[0] += node2.locked ? 0 : (node1.locked ? 2 : 1) * xRepulsive;
                    node2.f[1] += node2.locked ? 0 : (node1.locked ? 2 : 1) * yRepulsive;

                    node1.f[0] -= node1.locked ? 0 : (node2.locked ? 2 : 1) * xRepulsive;
                    node1.f[1] -= node1.locked ? 0 : (node2.locked ? 2 : 1) * yRepulsive;
                }
            },
            _attraction = function (node1, edge) {
                var node2 = _get(edge.target);

                if (node1.locked && node2.locked) return;

                _moveCount++;

                var dx = node2.p[0] - node1.p[0];
                var dy = node2.p[1] - node1.p[1];
                var d2 = dx * dx + dy * dy;
                if (d2 < 0.01) {
                    dx = 0.1 * Math.random() + 0.1;
                    dy = 0.1 * Math.random() + 0.1;
                    d2 = dx * dx + dy * dy;
                }
                var d = Math.sqrt(d2);
                if (d > currentParameters.maxRepulsiveForceDistance) {
                    d = currentParameters.maxRepulsiveForceDistance;
                    d2 = d * d;
                }
                var attractiveForce = (d2 - currentParameters.k * currentParameters.k) / currentParameters.k;
                if (edge.weight == undefined || edge.weight < 1) edge.weight = 1;
                attractiveForce *= Math.log(edge.weight) * 0.5 + 1;
                var afx = attractiveForce * dx / d,
                    afy = attractiveForce * dy / d;

                node2.f[0] -= node2.locked ? 0 : (node1.locked ? 2 : 1) * afx;
                node2.f[1] -= node2.locked ? 0 : (node1.locked ? 2 : 1) * afy;
                node1.f[0] += node1.locked ? 0 : (node2.locked ? 2 : 1) * afx;
                node1.f[1] += node1.locked ? 0 : (node2.locked ? 2 : 1) * afy;

            },
            _translation = function () {
                xScale = _super.width / (maxx - minx) * 0.62;
                yScale = _super.height / (maxy - miny) * 0.62;

                for (var nid in _nodes) {
                    var _n = _nodes[nid];
                    if (!_n.locked) {
                        _n.sp = _toScreen(_n.p);
                        _super.setPosition(_n.id, _n.sp[0], _n.sp[1], true);
                    }
                }
            },
            _fromScreen = function (xy) {
                return [
                        minx + (xy[0] - (0.19 * _super.width)) / xScale,
                        miny + (xy[1] - (0.19 * _super.height)) / yScale,
                ];
            },
            _toScreen = function (xy) {
                return [
                        (0.19 * _super.width) + ((xy[0] - minx) * xScale),
                        (0.19 * _super.height) +  ((xy[1] - miny) * yScale)
                ];
            };

        this._nodeMoved = this._groupMoved = function (id, x, y) {
            var n = _nodes[id];
            if (n) {
                n.sp = [x, y];
                n.p = _fromScreen(n.sp);
            }
        };


        this.canMagnetize = function(id) {
            return _nodes[id] && _nodes[id].locked !== true;
        };

        // provide this for the superclass to call.
        this.reset = function () {
            _nodes = {};
            currentIteration = 0;
            minx = miny = Infinity;
            maxx = maxy = -Infinity;
        };

        this._nodeRemoved = this._groupRemoved = function (nodeId) {
            delete _nodes[nodeId];
        };

        // implement this optional method so that if a Node/Group is added that has eventInfo with a position, we know that we
        // should lock its location and not move it when the layout refreshes.
        this._nodeAdded = this._groupAdded = function (params, eventInfo) {
            if (eventInfo && eventInfo.position) {
                var n = _get(params.node || params.group);
                if (n) {
                    n.locked = true;
                    _super.setPosition(n.id, eventInfo.position.left, eventInfo.position.top, true);
                }
            }
        };


        this.begin = function (toolkit, parameters) {
            currentIteration = 0;
            elements = [];
            Array.prototype.push.apply(elements, _super.adapter.getNodes());
            Array.prototype.push.apply(elements, _super.adapter.getGroups());
        };

        this.step = function (toolkit, parameters) {
            var i, _cache = [], __get = function (idx) {
                return _cache[idx] ? _cache[idx] : (function () {
                    _cache[idx] = _get(elements[idx]);
                    return _cache[idx];
                })();
            };

            // a small perf enhancement: if no repulsion or attraction occurred in this iteration, everything is
            // locked, and we can finish
            _moveCount = 0;
            // Forces on nodes due to node-node repulsions
            for (i = 0; i < elements.length; i++) {
                var node1 = __get(i);
                if (node1.group) continue;

                if (_absoluteBacked && !node1.locked) {
                    var ap = this.getAbsolutePosition(node1.n, parameters);
                    if (ap != null && ap.length == 2 && !isNaN(ap[0]) && !isNaN(ap[1])) {
                        _pos(node1, ap[0], ap[1]);
                        node1.sp = node1.p;
                        _super.setPosition(node1.id, ap[0], ap[1], true);
                        node1.locked = true;
                        continue;
                    }
                }

                for (var j = i + 1; j < elements.length; j++) {
                    var node2 = __get(j);
                    _repulsion(node1, node2);
                }
                var edges = _super.toolkit.getAllEdgesFor(node1.n);
                for (var k = 0; k < edges.length; k++) {
                    _attraction(node1, edges[k]);
                }
            }

            if (_moveCount != 0) {
                // Move by the given force
                for (i = 0; i < elements.length; i++) {
                    var node = __get(i);
                    if (node.group) continue;
                    var xmove = currentParameters.c * node.f[0];
                    var ymove = currentParameters.c * node.f[1];

                    var max = currentParameters.maxVertexMovement;
                    if (xmove > max) xmove = max;
                    if (xmove < -max) xmove = -max;
                    if (ymove > max) ymove = max;
                    if (ymove < -max) ymove = -max;

                    _pos(node, node.p[0] + xmove, node.p[1] + ymove);
                    node.f[0] = 0;
                    node.f[1] = 0;
                }
            }

            currentIteration++;

            if (_moveCount == 0 || currentIteration >= currentParameters.iterations) {
                _translation();
                _super.setDone(true);
            }
        };

        this.end = function() {
            for (var nid in _nodes) {
                _nodes[nid].locked = true;
            }
        };
    };

    JUTIL.extend(exports.Spring, exports.AbsoluteBackedLayout);

}).call(typeof window !== 'undefined' ? window : this);

;(function() {

    "use strict";

    var root = this;
    var JP = root.jsPlumb;
    var JTK = root.jsPlumbToolkit;

    JTK.UI = JTK.UI || {};
    var exports = JTK.UI;

    exports.ActiveDragFilter = function(renderer, _jsPlumb, toolkit) {
        var _stateMap = {};

        _jsPlumb.bind("connectionDrag", function(p) {
            var sourcePort = p.source.jtk.port,
                sourceNode = sourcePort ? sourcePort.getNode() : p.source.jtk.node,
                nc = toolkit.getNodeCount(), c, ports, i, j, fid;

            function _test(_source, _target) {
                c = toolkit.beforeConnect(_source, _target);
                fid = _target.getFullId();
                if (c === false && _stateMap[fid] == null) {
                    _stateMap[fid] = renderer.setTargetEnabled(_target, false);
                }
            }

            // if a port, test the node itself and also other ports on the node
            if (sourcePort) {

                // the port-> node
                _test(sourcePort, sourceNode);

                // the other ports
                ports = sourceNode.getPorts();
                for (i = 0; i < ports.length; i++) {
                    _test(sourcePort, ports[i]);
                }
            }

            // loop through nodes and test both the nodes .
            for (i = 0; i < nc; i++) {
                var otherNode = toolkit.getNodeAt(i);
                // test the other node. this works for either when the source is a port or it is a node.
                _test(sourcePort, otherNode);

                ports = otherNode.getPorts();
                for (j = 0; j < ports.length; j++) {
                    _test(sourcePort, ports[j]);
                }
            }
        });

        _jsPlumb.bind("connectionDragStop", function() {

            function _reset(obj) {
                // test for statemap entries that were actually written and not ignored by the last
                // drag start. so they have to be present and have a value of true.
                if (_stateMap[obj.getFullId()] === true) {
                    renderer.setTargetEnabled(obj, true);
                }
            }

            var nc = toolkit.getNodeCount();
            for (var i = 0; i < nc; i++) {
                var otherNode = toolkit.getNodeAt(i);
                _reset(otherNode);

                var ports = otherNode.getPorts();
                for (var j = 0; j < ports.length; j++) {
                    _reset(ports[j]);
                }
            }

            _stateMap = {};
        });
    }

}).call(typeof window !== 'undefined' ? window : this);
/*
 * Components
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 * This file contains the various UI components offered by the jsPlumb Toolkit.
 *
 * Namespace: jsPlumbToolkit.Renderers
 *
 * Dependencies:
 *
 * jsPlumbToolkit
 * jsPlumbToolkitUtil
 * jsPlumbUtil
 *
 */
;
(function () {

    "use strict";

    var root = this;
    var exports = root.jsPlumbToolkit.Renderers;
    var JTK = root.jsPlumbToolkit;
    var UTIL = root.jsPlumbToolkitUtil;
    var JUTIL = root.jsPlumbUtil;
    var JSP = root.jsPlumb;
    var ROTORS = root.Rotors;

    JTK.UIState = function (id, state, _jsPlumb) {
        for (var type in state) {
            if (state.hasOwnProperty(type)) {
                var pState = type === "*" ? "e-state-" + id : "e-state-" + id + "-" + type;
                var eState = type === "*" ? "c-state-" + id : "c-state-" + id + "-" + type;
                _jsPlumb.registerEndpointType(pState, state[type]);
                _jsPlumb.registerConnectionType(eState, state[type]);
            }
        }

        this.activate = function (target, renderer, toolkit) {

            target.eachEdge(function (i, e) {
                var conn = renderer.getRenderedConnection(e.getId()),
                    t = toolkit.getEdgeType(e.data),
                    s = t ? "c-state-" + id + "-" + t : null;

                if (s) {
                    conn.addType(s, e.data);
                }

                // wildcard
                if (state["*"])
                    conn.addType("c-state-" + id, e.data);

                _portStateOperation(e, conn, e.source, 0, "addType", toolkit);
                _portStateOperation(e, conn, e.target, 1, "addType", toolkit);
            });

            // nodes just offer add/remove class
            target.eachNode(function (i, n) {
                var t = toolkit.getNodeType(n.data), s = t ? state[t] : null,
                    rn = renderer.getRenderedNode(n.id);

                if (s && s.cssClass)
                    _jsPlumb.addClass(rn, s.cssClass);

                if (state["*"])
                    _jsPlumb.addClass(rn, state["*"].cssClass);
            });
        };

        var _portStateOperation = function (edge, conn, obj, idx, op, toolkit) {
            var ep = conn.endpoints[idx],
                t = toolkit.getPortType(obj.data);

            ep[op]("e-state-" + id + "-" + t);
            ep[op]("e-state-" + id);
        };

        this.deactivate = function (target, renderer, toolkit) {

            target.eachEdge(function (i, e) {
                var conn = renderer.getRenderedConnection(e.getId()),
                    t = toolkit.getEdgeType(e.data),
                    s = t ? "c-state-" + id + "-" + t : null;

                if (s)
                    conn.removeType(s, e.data);

                // wildcard
                if (state["*"])
                    conn.removeType("c-state-" + id);

                _portStateOperation(e, conn, e.source, 0, "removeType", toolkit);
                _portStateOperation(e, conn, e.target, 1, "removeType", toolkit);
            });

            target.eachNode(function (i, n) {
                var t = toolkit.getNodeType(n.data), s = t ? state[t] : null,
                    rn = renderer.getRenderedNode(n.id);

                if (s && s.cssClass)
                    _jsPlumb.removeClass(rn, s.cssClass);

                if (state["*"])
                    _jsPlumb.removeClass(rn, state["*"].cssClass);
            });
        };
    };

    var atts = exports.atts = { NODE: "data-jtk-node-id", PORT: "data-jtk-port-id", GROUP:"data-jtk-group-id" },
        els = exports.els = { SOURCE: "JTK-SOURCE", PORT: "JTK-PORT", TARGET: "JTK-TARGET" },
        _cl = JTK.Classes,
        _c = JTK.Constants,
        _e = JTK.Events;

    exports.mouseEvents = [ "click", "dblclick", "contextmenu", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover" ];


    // wrap jsPlumb's createElement method: it will handle the case that we are not operating in a browser.
    exports.createElement = function (params, parent) {
        var style = {
            width:params.width,
            height:params.height,
            position : params.position || _c.absolute
        };
        var atts = {};
        if (params.display) style.display = params.display;
        if (params.id) atts.id = params.id;
        if (params.top) style.top = params.top + "px";
        if (params.left) style.left = params.left + "px";
        if (params.right) style.right  = params.right + "px";
        if (params.bottom) style.bottom = params.bottom + "px";
        var d = JSP.createElement(params.type || _c.div, style, params.clazz, atts);

        if (parent != null) {
            JSP.appendElement(d, parent); // this too will be handled by jsPlumb when not in a browser.
        }
        return d;
    };

// **************** rendering ************



// *********** adapters for positioning - layouts call adapters and dont work directly with offsets. ***************************

    /**
     Adapter for a normal DOM element
     */
    var DOMElementAdapter = exports.DOMElementAdapter = function (params) {
        var _jsPlumb = this.getJsPlumb(),
            _el = _jsPlumb.getElement(params.container);

        this.getWidth = function () {
            return _jsPlumb.getSize(_el)[0];
        };

        this.getHeight = function () {
            return _jsPlumb.getSize(_el)[1];
        };

        this.append = function (e) {
            var _e = _jsPlumb.getElement(e);
            _jsPlumb.appendElement(_e, _el);
        };

        this.remove = function (e) {
            var _e = _jsPlumb.getElement(e);
            _jsPlumb.removeElement(_e);
        };

        this.setAbsolutePosition = JSP.setAbsolutePosition;

        this.getOffset = function (e, relativeToPage) {
            return _jsPlumb.getOffset(e, relativeToPage);
        };
    };

    /**
     * Superclass for renderers
     * @class jsPlumbToolkit.Renderers.AbstractRenderer
     * @constructor
     * @param {Object} params Constructor parameters.
     * @param {Object} [params.view] Parameters for Node, Port and Edge definitions. Although this is not a required parameter, the vast majority of applications will
     * @param {Boolean} [params.elementsDraggable=true] Whether or not elements should be made draggable.
     * @param {Boolean} [params.elementsDroppable=false] If true, elements can be dragged onto other elements and events will be fired.
     * What you choose to do with that event is up to you.
     * @param {String} [params.id] Optional id for this renderer. If you provide this you can then subsequently retrieve it via `toolkit.getRenderer(<id>)`.
     * @param {Boolean} [params.refreshAutomatically=true] Whether or not to automatically refresh the associated layout whenever a Node is added or deleted.
     * @param {Boolean} [params.enhancedView=true] If false, there will be no support for preconfigured parameters or functions in the definitions inside a view. You will want to set this for Angular if you use the 2-way data binding.
     * @param {Function} [params.assignPosse] optional function that, given each node, can return the id of the posse to which the node belongs. a Posse is a group of nodes that should all be dragged together.
     * @param {String} [params.modelLeftAttribute="left"] Optional; specifies the name of the attribute by which to store the x position of a dragged node of `storePositionsInModel` is true.
     * @param {String} [params.modelTopAttribute="top"] Optional; specifies the name of the attribute by which to store the y position of a dragged node of `storePositionsInModel` is true.
     * @param {Boolean} [params.relayoutOnGroupUpdate=false] If true, any change to a Group's nodes will cause a relayout.
     */
    var AbstractRenderer = exports.AbstractRenderer = function (params) {
        params = params || {};

        /*
         Function: _defaultNodeRenderFunction
         This is the default that the jsPlumb toolkit will use if you do not supply either a render function or a template id.
         It draws a div with a basic 1px solid border.
         */
        var _defaultNodeRenderFunction = function (data, id) {

                var d = JSP.createElement("div", {
                    border:"1px solid #456",
                    position:"absolute"
                }, _cl.NODE);
                d.innerHTML = data.name || data.id;

                return d;
            },
            _defaultTemplate = "<div data-jtk-node-id=\"${id}\" class=\"" + _cl.NODE + "\"></div>",
            _defaultTemplateRenderers = {
                "rotors": {
                    render: function (templateId, data) {
                        return _rotors.template(templateId, data).childNodes[0];
                    }
                }
            },
            _defaultTemplateRendererName = "rotors";

        var _rotors = ROTORS.newInstance({
            defaultTemplate:_defaultTemplate,
            templateResolver:params.templateResolver,
            templates:params.templates
        });

        var self = this,
            _toolkit = params.toolkit,
            _layout = new JTK.Layouts.EmptyLayout(self),
            containerElement = JSP.getElement(params.container),
            draggable = !(params.elementsDraggable === false),
            droppable = params.elementsDroppable === true,
            _suspendRendering = false,
            _refreshAutomatically = params.refreshAutomatically !== false,
            _thisTemplateRenderer = params.templateRenderer ? JUTIL.isString(params.templateRenderer) ? _defaultTemplateRenderers[params.templateRenderer] : { render: params.templateRenderer } : _defaultTemplateRenderers[_defaultTemplateRendererName],
            enhancedView = params.enhancedView !== false,
            posseAssigner = params.assignPosse || function() { return null;},
            _modelLeftAttribute = params.modelLeftAttribute || "left",
            _modelTopAttribute = params.modelTopAttribute || "top",
            _storePositionsInModel = params.storePositionsInModel !== false;

        var jsPlumbParams = JUTIL.merge(params.jsPlumb || {}),
            _jsPlumb = params.jsPlumbInstance || JSP.getInstance(jsPlumbParams, params.overrideFns),
            containerId = _jsPlumb.getId(containerElement);

        // wire up a beforeDrop interceptor for the jsplumb instance to the Toolkit's beforeConnect method
        _jsPlumb.bind("beforeDrop", function(params) {
            var c = params.connection,
                sourceJtk = c.endpoints[0].graph || c.source.jtk,
                targetJtk = c.endpoints[1].graph || c.target.jtk,
                s = sourceJtk.port || sourceJtk.node || sourceJtk.group,
                t = targetJtk.port || targetJtk.node || targetJtk.group,
                e = params.connection.edge;

            if (e == null)
                return _toolkit.beforeConnect(s, t, params.connection.getData());
            else
                return _toolkit.beforeMoveConnection(s, t, e);
        });

        _jsPlumb.bind("beforeDrag", function(params) {
            var jtkSource = params.endpoint.graph || params.source.jtk,
                e = jtkSource.port || jtkSource.node,
                cType = params.endpoint.connectionType,
                toolkitResponse = _toolkit.beforeStartConnect(e, cType);

            // if drag not allowed and this is a temporary endpoint, delete it.
            if (toolkitResponse === false && params.endpoint.isTemporarySource && params.endpoint._deleteOnDetach) {
                _jsPlumb.deleteEndpoint(params.endpoint);
            }

            return toolkitResponse;
        });

        _jsPlumb.bind("beforeDetach", function(connection, isDiscard) {
            var sourceJtk = connection.endpoints[0].graph || connection.source.jtk,
                targetJtk = connection.endpoints[1].graph || connection.target.jtk,
                s = sourceJtk.port || sourceJtk.node,
                t = targetJtk.port || targetJtk.node,
                e = connection.edge;

            return _toolkit.beforeDetach(s, t, e, isDiscard);
        });

        _jsPlumb.bind("beforeStartDetach", function(params) {
            var jtkSource = params.endpoint.graph || params.source.jtk,
                s = jtkSource.port || jtkSource.node,
                e = params.connection.edge;

            return _toolkit.beforeStartDetach(s, e);
        });

        _jsPlumb.bind("connectionEdit", function(conn) {
            if (conn.edge) {
                conn.edge.geometry = conn.getConnector().getGeometry();
            }
        });

        JUTIL.EventGenerator.apply(this, arguments);

        if (params.activeFiltering) {
            new JTK.UI.ActiveDragFilter(self, _jsPlumb, _toolkit);
        }

        // expose jsplumb mostly for testing
        this.getJsPlumb = function () {
            return _jsPlumb;
        };
        this.getToolkit = function () {
            return _toolkit;
        };
        // renderer has some events, but also exposes jsplumb events
        var localEvents = [ _e.canvasClick, _e.canvasDblClick, _e.nodeAdded, _e.nodeDropped,
                _e.nodeRemoved, _e.nodeRendered,
                _e.groupAdded, _e.groupRemoved, _e.groupMoveEnd, _e.groupMemberAdded, _e.groupMemberRemoved,
                _e.groupCollapse, _e.groupExpand,
                _e.nodeMoveStart, _e.nodeMoveEnd, _e.portAdded,
                _e.portRemoved, _e.edgeAdded, _e.edgeRemoved,
                _e.edgeTypeChanged, _e.nodeTypeChanged, _e.portTypeChanged,
                _e.dataLoadEnd, _e.anchorChanged, _e.objectRepainted,
                _e.modeChanged, _e.lassoEnd,
                _e.pan, _e.zoom, _e.relayout, _e.click, _e.tap, _e.stateRestored, _e.startOverlayAnimation, _e.endOverlayAnimation ],
            _bind = self.bind,
            _jbind = _jsPlumb.bind;

        /**
         * Sets/unsets hover suspended state. When hover is suspended, no connections or endpoints repaint themselves
         * on mouse hover.
         * @method setHoverSuspended
         * @param {Boolean} suspended
         */
        this.setHoverSuspended = _jsPlumb.setHoverSuspended;

        /**
         * Gets hover suspended state.
         * @method isHoverSuspended
         * @return {Boolean} Hover suspended state.
         */
        this.isHoverSuspended = _jsPlumb.isHoverSuspended;

        /**
         * Sets the current jsPlumb defaults
         * @method setJsPlumbDefaults
         * @param {Object} defaults Defaults to set.
         */
        this.setJsPlumbDefaults = function (defaults) {
            // cannot set Container this way
            delete defaults.Container;
            _jsPlumb.restoreDefaults();
            _jsPlumb.importDefaults(defaults);
        };

        this.bind = function (evt, fn) {
            if (localEvents.indexOf(evt) == -1)
                _jbind(evt, fn);
            else
                _bind(evt, fn);
        };

        // *************** events ********************************
        if (params.events) {
            for (var evt in params.events) {
                this.bind(evt, params.events[evt]);
            }
        }
        // *************** /events ********************************

        // *************** interceptors ********************************
        if (params.interceptors) {
            for (var int in params.interceptors) {
                this.bind(int, params.interceptors[int]);
            }
        }
        // *************** /events ********************************

        var _ignoreToolkitEvents = false;
        _jbind(_e.connection, function (info) {
            if (info.connection.edge != null) return;
            _ignoreToolkitEvents = true;

            // if nodeId is not set on source endpoint, set it, by doing a lookup from reverseNodeMap
            if (!info.sourceEndpoint.getParameter("nodeId"))
                info.sourceEndpoint.setParameter("nodeId", reverseNodeMap[info.sourceEndpoint.elementId].id);

            if (!info.targetEndpoint.getParameter("nodeId"))
                info.targetEndpoint.setParameter("nodeId", reverseNodeMap[info.targetEndpoint.elementId].id);

            var sourcePortTypeId = info.sourceEndpoint.getParameter("portType"),
                sourcePortType = view.getPortDefinition(sourcePortTypeId),
                edgeType = sourcePortType != null && sourcePortType.edgeType ? sourcePortType.edgeType : info.sourceEndpoint.getParameter("edgeType") || "default",
                sourceNodeId = info.sourceEndpoint.getParameter("nodeId"),
                sourcePortId = info.sourceEndpoint.getParameter("portId"),
                targetNodeId = info.targetEndpoint.getParameter("nodeId"),
                targetPortId = info.targetEndpoint.getParameter("portId"),
                sourceId = sourceNodeId + (sourcePortId ? "." + sourcePortId : ""),
                targetId = targetNodeId + (targetPortId ? "." + targetPortId : ""),
                params = {
                    sourceNodeId: sourceNodeId,
                    sourcePortId: sourcePortId,
                    targetNodeId: targetNodeId,
                    targetPortId: targetPortId,
                    type: edgeType,
                    source: _toolkit.getNode(sourceId),
                    target: _toolkit.getNode(targetId),
                    sourceId: sourceId,
                    targetId: targetId
                };

            var doAbort = _toolkit.getEdgeFactory()(edgeType, info.connection.getData() || {}, function (data) {
                params.edge = _toolkit.addEdge({
                    source: sourceId,
                    target: targetId,
                    cost: info.connection.getCost(),
                    directed: info.connection.isDirected(),
                    data: data,
                    addedByMouse: true
                }, self);
                connMap[params.edge.getId()] = info.connection;
                info.connection.edge = params.edge;
                _maybeAttachEdgeEvents(edgeType, params.edge, info.connection);
                params.addedByMouse = true;
                self.fire(_e.edgeAdded, params);
            });
            // if edge factory explicitly returned false, delete the connection.
            if (doAbort === false) {
                _jsPlumb.detach(info.connection);
            }
            _ignoreToolkitEvents = false;
        });

        // fired when the user moves a connection with the mouse. we advise the toolkit and it takes action.
        _jbind(_e.connectionMoved, function(info) {
            var o = info.index == 0 ? info.newSourceEndpoint : info.newTargetEndpoint;
            _ignoreToolkitEvents = true;
            _toolkit.edgeMoved(info.connection.edge, (o.element.jtk.port || o.element.jtk.node), info.index);
            _ignoreToolkitEvents = false;
        });

        // fired only when an edge was removed via the UI.
        _jbind(_e.connectionDetached, function (info) {
            _ignoreToolkitEvents = true;
            _toolkit.removeEdge(info.connection.edge);
            _ignoreToolkitEvents = false;
            var sp = info.sourceEndpoint.getParameters(), tp = info.targetEndpoint.getParameters(),
                sourceId = sp.nodeId + (sp.portId ? "." + sp.portId : ""),
                targetId = tp.nodeId + (tp.portId ? "." + tp.portId : "");
            self.fire(_e.edgeRemoved, {
                sourceNodeId: sp.nodeId,
                targetNodeId: tp.nodeId,
                sourcePortId: sp.portId,
                targetPortId: tp.portId,
                sourceId: sourceId,
                targetId: targetId,
                source: _toolkit.getNode(sourceId),
                target: _toolkit.getNode(targetId),
                edge: info.connection.edge
            });
        });

//          group event stuff
        _jbind(_e.groupDragStop, function(info) {
            self.getLayout().setPosition(info.group.id, info.pos[0], info.pos[1], true);
            info.uigroup = info.group;
            self.fire(_e.groupMoveEnd, JSP.extend(info, {group:_toolkit.getGroup(info.uigroup.id)}));
        });

        _jbind(_e.groupMemberAdded, function(info) {
            if (!_suspendRendering && info.el.jtk.node) {
                var tkGroup = _toolkit.addToGroup(info.el.jtk.node, info.group.id);
                if (tkGroup) {
                    self.fire(_e.groupMemberAdded, {node: info.el.jtk.node, group: tkGroup, uigroup: info.group});
                }
                maybeRelayoutOnGroupUpdate();
            }
        });

        _jbind(_e.groupMemberRemoved, function(info) {
            if (!_suspendRendering && info.el.jtk.node) {
                var tkGroup = _toolkit.removeFromGroup(info.el.jtk.node);
                if (tkGroup) {
                    self.nodeRemovedFromGroup(info.el);
                    self.fire(_e.groupMemberRemoved, {node: info.el.jtk.node, ugroup: tkGroup, igroup: info.group});
                }
                maybeRelayoutOnGroupUpdate();
            }
        });

        _jbind(_e.groupCollapse, function(info) {
            var tkGroup = _toolkit.getGroup(info.group.id);
            if (tkGroup)
                self.fire(_e.groupCollapse, {group:tkGroup, uigroup:info.group});
        });

        _jbind(_e.groupExpand, function(info) {
            var tkGroup = _toolkit.getGroup(info.group.id);
            if (tkGroup)
                self.fire(_e.groupExpand, {group:tkGroup, uigroup:info.group});
        });

// ---------- bind to events in the toolkit ---------------------
        var nodeMap = {}, reverseNodeMap = {}, portMap = {}, groupMap = {}, groupList = [], reverseGroupMap = {};
        var nodeList = [], _addNodeToList = function(n) {
                nodeList.push(n);
            },
            _removeNodeFromList = function(n) {
                var idx = nodeList.indexOf(n);
                if (idx != -1) nodeList.splice(idx, 1);
            };

        this.getNodeCount = function() {
            return nodeList.length;
        };
        this.getNodeAt = function(idx) {
            return nodeList[idx];
        };
        this.getNodes = function() { return nodeList; };
        this.getNode = function(id) { return nodeMap[id]; };
        this.getGroupCount = function() { return groupList.length; };
        this.getGroupAt = function(idx) { return groupList[idx]; };
        this.getGroups = function() { return groupList; };

        var connMap = {},
            _getConnectionForEdge = function (edge) {
                return connMap[edge.getId()];
            },
            _getConnectionsForEdges = function (edges) {
                var c = [];
                for (var i = 0; i < edges.length; i++)
                    c.push(connMap[edges[i].getId()]);
                return c;
            },
            _bindAConnectionEvent = function (id, listener, edge, connection) {
                connection.bind(id, function (e, originalEvent) {
                    listener.apply(listener, [
                        {
                            edge: edge,
                            e: originalEvent,
                            connection: connection,
                            toolkit: _toolkit,
                            renderer: self
                        }
                    ]);
                });
            },
            _maybeAttachEdgeEvents = function (type, edge, connection) {
                // if this connection already has an associated edge, do nothing.
                if (connection.getParameter("edge")) return;
                var edgeTypeDefinition = view.getEdgeDefinition(type);
                // set events too, if they were provided in the edge definition
                if (edgeTypeDefinition && edgeTypeDefinition.events) {
                    for (var i in edgeTypeDefinition.events) {
                        _bindAConnectionEvent(i, edgeTypeDefinition.events[i], edge, connection);
                    }
                }
            };
        var _fireEdgeRemoved = function (c, edge) {
            var sp = c.endpoints[0].getParameters(), tp = c.endpoints[1].getParameters(),
                sourceId = sp.nodeId + (sp.portId ? "." + sp.portId : ""),
                targetId = tp.nodeId + (tp.portId ? "." + tp.portId : "");

            self.fire(_e.edgeRemoved, {
                sourceNodeId: sp.nodeId,
                targetNodeId: tp.nodeId,
                sourcePortId: sp.portId,
                targetPortId: tp.portId,
                sourceId: sourceId,
                targetId: targetId,
                source: _toolkit.getNode(sourceId),
                target: _toolkit.getNode(targetId),
                edge: edge
            });
        };

        /**
         * Sets whether or not rendering is suspended. This actually does not mean that new nodes are not
         * added, but it does mean that the panzoom widget is informed not to do any work involving element
         * postions or sizes.
         * @method setSuspendRendering
         * @param val
         */
        this.setSuspendRendering = function (val, thenRefresh) {
            _suspendRendering = val;
            _jsPlumb.setSuspendDrawing(val);
            if (thenRefresh) {
                this.refresh();
            }
        };

        /**
         * Wraps the underlying Toolkit's `batch` function with the added step of first suspending events being
         * fired from this renderer.
         * @method batch
         * @param fn Function to run while rendering and events are both suspended.
         */
        this.batch = function(fn) {
            this.setSuspendEvents(true);
            _toolkit.batch(fn);
            this.setSuspendEvents(false);
        };

        var _doAssignPosse = function(el, node) {
            if (!_suspendRendering) {
                var posse = posseAssigner(node);
                if (posse != null) {
                    // posse assign function can return just a string, giving the name of a posse in which the
                    // element acts as a drag master, or an array of [ name, isMaster ], if you want the element
                    // to belong to a posse but be a drag slave.
                    var args = JUTIL.isArray(posse) ? posse : [ posse ];
                    args.unshift(el);
                    _jsPlumb.addToPosse.apply(_jsPlumb, args);
                }
            }
            else {
                _pendingPosseAssignments.push([ el, node ]);
            }
        };

        var _assignPendingPosses = function() {
            for (var i = 0; i < _pendingPosseAssignments.length; i++) {
                _doAssignPosse.apply(this, _pendingPosseAssignments[i]);
            }
        };

        var _pendingPosseAssignments = []; //  a list of posse assignments that were not done due to rendering
        // being suspended. Calling _assignPendingPosses will get these done.
        if (this.bindToolkitEvents !== false) {
            var _startFn = function () {
                _pendingPosseAssignments.length = 0;
                _jsPlumb.setSuspendDrawing(true);
                this.setSuspendRendering(true);
            }.bind(this);

            _toolkit.bind(_e.dataLoadStart, _startFn);
            _toolkit.bind(_e.dataAppendStart, _startFn);
            _toolkit.bind(_e.dataLoadEnd, function () {
                this.setSuspendRendering(false);
                // assign all posses that were not assigned due to rendering suspended.
                _assignPendingPosses();
                // ensure group child node positions are correctly recorded.
                _jsPlumb.getGroupManager().refreshAllGroups();
                _autoSizeGroups();
                self.relayout();
                _jsPlumb.setSuspendDrawing(false, true);
                if (_layout) self.fire(_e.dataLoadEnd);
            }.bind(this));
            _toolkit.bind(_e.dataAppendEnd, function () {
                this.setSuspendRendering(false);
                // assign all posses that were not assigned due to rendering suspended.
                _assignPendingPosses();
                self.refresh();
                _jsPlumb.setSuspendDrawing(false, true);
                if (_layout) self.fire(_e.dataAppendEnd);
            }.bind(this));

            var _appendNodeToGroup = function(nodeEl, n, group) {
                var groupEl = groupMap[group.id];
                if (groupEl) {
                    var target = groupEl.querySelector("[jtk-group-content]") || groupEl;
                    target.appendChild(nodeEl);
                    _jsPlumb.addToGroup(group.id, nodeEl, true);
                    self.nodeAppendedToGroup(nodeEl, groupEl, group);
                }
            };

            //
            // does the work of rendering a node, stashing it,
            // and checking it for rendered ports.
            var _doRenderNode = function(n, eventInfo) {
                // does an element for this node already exist?
                var nodeEl = nodeMap[n.id];
                if (nodeEl == null) {

                    // check node definition to see if we should ignore it.
                    var nd = view.getNodeDefinition(_toolkit.getNodeType(n.data));
                    if (nd.ignore === true) return false;
                    // return FALSE if so.

                    nodeEl = nodeRenderer(n, n.data, n);
                    if (!nodeEl) throw new Error("Cannot render node");
                    var elId = _jsPlumb.getId(nodeEl);
                    nodeMap[n.id] = nodeEl;
                    reverseNodeMap[elId] = n;
                    _addNodeToList(n);
                    nodeEl.jtk = { node: n };

                    if (n.group == null) {
                        self.append(nodeEl, elId, eventInfo ? eventInfo.position : null);
                    } else {
                        _appendNodeToGroup(nodeEl, n, n.group);
                    }

                    _doAssignPosse(nodeEl, n);

                    _checkForPorts(nodeEl, n);
                    var np = {node: n, el: nodeEl, id: n.id};
                    self.getLayout().nodeAdded(np, eventInfo);
                    self.fire(_e.nodeAdded, np);
                }
                return nodeEl;
            };

            //
            // Notification a new Node was added - this function renders it, and then calls refresh on the layout if there is
            // one.
            //
            _toolkit.bind(_e.nodeAdded, function (params) {
                var n = params.node, i;
                var nodeEl = _doRenderNode(n, params.eventInfo);
                if (nodeEl != null) {
                    var ports = _jsPlumb.getSelector(nodeEl, "[data-port-id]");
                    for (i = 0; i < ports.length; i++) {
                        var portId = ports[i].getAttribute("data-port-id");
                        portMap[n.id + "." + portId] = ports[i];
                        ports[i].jtk = ports[i].jtk || { node: n, port: n.getPort(portId) }; // port may still be null here; that's ok.
                    }

                    self.refresh(true);
                }
            });

            //
            // Notification a Node was removed - this function removes all UI components, and then calls refresh on the layout if there is
            // one.
            //
            _toolkit.bind(_e.nodeRemoved, function (params) {
                // update the layout
                self.getLayout().nodeRemoved(params.nodeId);

                var el = nodeMap[params.nodeId];
                self.fire(_e.nodeRemoved, { node: params.nodeId, el: el });
                var elId = _jsPlumb.getId(el);
                _rotors.remove(el);
                _jsPlumb.remove(el);
                delete nodeMap[params.nodeId];
                delete reverseNodeMap[elId];
                _removeNodeFromList(params.node);
                delete el["jtk"];
                self.refresh(true);

            });

            var maybeRelayoutOnGroupUpdate = function() {
                if (params.relayoutOnGroupUpdate) {
                    self.relayout();
                }
            }

            _toolkit.bind("group:addMember", maybeRelayoutOnGroupUpdate);
            _toolkit.bind("group:removeMember", maybeRelayoutOnGroupUpdate);

// -------------------------------- groups -----------------------------------------------------------

            var _doRenderGroup = function(g, eventInfo) {
                // does a DOM element for this Group already exist?
                var groupEl = groupMap[g.id];
                if (groupEl == null) {

                    // check node definition to see if we should ignore it.
                    var gd = view.getGroupDefinition(_toolkit.getNodeType(g.data));
                    if (gd.ignore === true) return false;
                    // return FALSE if so.

                    groupEl = groupRenderer(g, g.data, g);
                    if (!groupEl) throw new Error("Cannot render Group");
                    var elId = _jsPlumb.getId(groupEl);
                    groupMap[g.id] = groupEl;
                    groupList.push(g);

                    reverseGroupMap[elId] = g;

                    groupEl.jtk = { group: g };
                    self.append(groupEl, elId, eventInfo ? eventInfo.position : null);

                    _doAssignPosse(groupEl, g);

                    _checkForPorts(groupEl, g);

                    var np = {node: g, el: groupEl};

                    // add the group to the jsplumb instance
                    var opts = {
                        el:groupEl,
                        id: g.id
                    };
                    JSP.extend(opts, {dragOptions:params.dragOptions || {}});

                    opts.dragOptions[JSP.dragEvents[_c.stop]] = JUTIL.wrap(opts.dragOptions[JSP.dragEvents[_c.stop]], function(p) {
                        if (p.el.jtk && p.el.jtk.group) {

                            if (opts.dragOptions.magnetize) {
                                p.pos =self.getLayout().setMagnetizedPosition(p.el.jtk.group.id, p.pos[0], p.pos[1], true);
                            } else {
                                self.getLayout().setPosition(p.el.jtk.group.id, p.pos[0], p.pos[1], true);
                            }

                            if (_storePositionsInModel !== false) {
                                self.storePositionInModel({
                                    id:p.el.jtk.group.id,
                                    group:true,
                                    leftAttribute:_modelLeftAttribute,
                                    topAttribute:_modelTopAttribute
                                });
                                _toolkit.fire(_e.groupUpdated, { group: p.el.jtk.group }, null);
                            }

                            self.fire(_e.groupMoveEnd, {
                                el: p.el,
                                group: p.el.jtk.group,
                                pos: p.pos,
                                e:p.e,
                                eventPosition:p.pos
                            });
                        }
                    });

                    _jsPlumb.addGroup(JSP.extend(opts, gd));
                    self.getLayout().groupAdded({group:g, el:groupEl, id: g.id}, eventInfo);

                    self.fire(_e.groupAdded, np);
                }
                return groupEl;
            };

            _toolkit.bind(_e.groupAdded, function (params) {
                var g = params.group;
                var groupEl = _doRenderGroup(g, params.eventInfo);
                if (groupEl != null) {
                    self.refresh(true);
                }
            });

            _toolkit.bind(_e.groupRemoved, function (params) {
                var g = params.group;
                // update the layout
                self.getLayout().groupRemoved(g.id);
                var el = groupMap[g.id], elId = _jsPlumb.getId(el);
                _jsPlumb.removeGroup(g.id, params.removeChildNodes, true, false);
                delete groupMap[g.id];
                delete reverseGroupMap[elId];
                delete el["jtk"];
                self.refresh(true);
            });

            this.expandGroup = function(group) {
                _jsPlumb.expandGroup(typeof group === "string " ? group : group.id);
            };

            this.collapseGroup = function(group) {
                _jsPlumb.collapseGroup(typeof group === "string " ? group : group.id);
            };

            this.toggleGroup = function(group) {
                _jsPlumb.toggleGroup(typeof group === "string " ? group : group.id);
            };

            var _autoSizeAGroup = function(group, def) {
                var n = group.getNodes(),
                    maxx = 0,
                    maxy = 0,
                    layout = self.getLayout(), pos, size,
                    uiGroup = _jsPlumb.getGroup(group.id),
                    groupEl = uiGroup.getDragArea();

                for (var i = 0; i < n.length; i++) {
                    pos = layout.getPosition(n[i].id);
                    if (!isNaN(pos[0]) && !isNaN(pos[1])) {
                        size = layout.getSize(n[i].id);
                        maxx = Math.max(maxx, pos[0] + size[0]);
                        maxy = Math.max(maxy, pos[1] + size[1]);
                    }
                }

                maxx = def.maxSize ? Math.min(def.maxSize[0], maxx) : maxx;
                maxy = def.maxSize ? Math.min(def.maxSize[1], maxy) : maxy;

                groupEl.style.width = maxx + "px";
                groupEl.style.height = maxy + "px";
                layout.setSize(group.id, [maxx, maxy]);

            };

            var _autoSizeGroups = function() {
                for (var groupId in groupMap) {
                    var group = _toolkit.getGroup(groupId);
                    if (group) {
                        var def = view.getGroupDefinition(_toolkit.getNodeType(group.data));
                        if (def.autoSize) {
                            _autoSizeAGroup(group, def);
                        }
                    }
                }
            };

            /**
             * Run the groups auto size routine.
             * @method autoSizeGroups
             */
            self.autoSizeGroups = _autoSizeGroups;

// -------------------------------- / groups -----------------------------------------------------------

            var directEdgeConnector = function (edge, geometry) {
                return function () {
                    var connectionParams = _prepareConnectionParams(edge);
                    connectionParams.doNotFireConnectionEvent = true;
                    if (geometry) connectionParams.geometry = geometry;
                    if (_toolkit.isDebugEnabled()) console.log("Renderer", "adding edge with params", connectionParams);
                    var conn = _jsPlumb.connect(connectionParams);
                    conn.edge = edge;
                    connMap[edge.getId()] = conn;
                    _maybeAttachEdgeEvents(connectionParams.type, edge, conn);
                    self.fire(_e.edgeAdded, {
                        source: edge.source,
                        target: edge.target,
                        connection: conn,
                        edge: edge,
                        geometry:geometry
                    });
                    self.refresh(true);
                };
            };

            //
            // Notification that an Edge was added. We want to create an appropriate connection in the jsPlumb
            // instance we are managing. Note 'connMap' above; we use that to map edges to actual connections.
            //
            _toolkit.bind(_e.edgeAdded, function (data) {
                if (!_ignoreToolkitEvents && data.source !== self) {
                    var edge = data.edge;
                    var def = view.getEdgeDefinition(_toolkit.getEdgeType(edge.data || {}));
                    if (def && def.ignore === true) return;
                    // create a function that will establish the jsplumb connection.  If we've been given a connectionHandler
                    // then we pass the function to it, along with the related edge, expecting that at some point the
                    // handler will execute the connect function (this is used, for instance, in Angular integration, in which
                    // template loading and painting is asynchronous
                    var connectFunction = directEdgeConnector(edge, data.geometry);
                    if (params.connectionHandler)
                        params.connectionHandler(edge, connectFunction);
                    else
                    // otherwise we just execute the connect function directly.
                        connectFunction();
                }
            });

            //
            // Notification that an edge was removed. We want to remove the corresponding connection from our jsPlumb instance.
            //
            _toolkit.bind(_e.edgeRemoved, function (data) {
                if (!_ignoreToolkitEvents && data.source !== self) {
                    var edge = data.edge;
                    var connection = connMap[edge.getId()];
                    if (connection) {
                        if (_toolkit.isDebugEnabled()) console.log("Renderer", "removing edge", edge);
                        _fireEdgeRemoved(connection, edge);
                        _jsPlumb.detach({connection: connMap[edge.getId()], fireEvent: false});
                        delete connMap[edge.getId()];
                    }
                }
            });

            _toolkit.bind(_e.edgeTypeChanged, function(data) {
                if (!_ignoreToolkitEvents && data.source !== self) {
                    var edge = data.obj;
                    var connection = connMap[edge.getId()];
                    if (connection) {
                        var def = view.getEdgeDefinition(data.newType);
                        if (def && def.ignore === true) return;
                        connection.setType(data.newType); // this will set anchors etc. paint styles. endpoints.
                        // but NOT connector.
                        if (def.connector) {
                            connection.setConnector(def.connector);
                        }
                    }
                }
            });

            // Notification that the target of an edge was changed
            _toolkit.bind(_e.edgeTarget, function (data) {
                if (!_ignoreToolkitEvents) {
                    var edge = data.edge;
                    var connection = connMap[edge.getId()];
                    var n = nodeMap[edge.target.getFullId()];
                    if (connection) {
                        _jsPlumb.silently(function() {
                            if (n != null) {
                                if (_toolkit.isDebugEnabled()) console.log("target change", connection);
                                _jsPlumb.setTarget(connection, n);
                            }
                            else {
                                delete connMap[edge.getId()];
                                _jsPlumb.detach({
                                    connection:connection,
                                    forceDetach:true,
                                    fireEvent:false
                                });
                            }
                        });
                    }
                    else {
                        if (n != null) {
                            if (_toolkit.isDebugEnabled()) {
                                JUTIL.log("Target for Edge " + edge.getId() + " changed to Node " + n.id + "; we have no valid connection.");
                            }
                        }
                    }
                }
            });

            // Notification that the source of an edge was changed
            _toolkit.bind(_e.edgeSource, function (data) {
                if (!_ignoreToolkitEvents) {
                    var edge = data.edge;
                    var connection = connMap[edge.getId()];
                    var n = nodeMap[edge.source.getFullId()];
                    if (connection) {
                        _jsPlumb.silently(function() {
                            if (n != null) {
                                _jsPlumb.setSource(connection, n);
                            }
                            else {
                                delete connMap[edge.getId()];
                                _jsPlumb.detach({
                                    connection: connection,
                                    forceDetach: true,
                                    fireEvent: false
                                });
                            }
                        });
                    }
                    else {
                        if (n != null) {
                            if (_toolkit.isDebugEnabled()) {
                                JUTIL.log("Source for Edge " + edge.getId() + " changed to Node " + n.id + "; we have no valid connection.");
                            }
                        }
                    }
                }
            });

            //
            // Notification that the graph was cleared. We remove everything from our jsPlumb instance (but do not
            // unbind any event listeners).
            //
            _toolkit.bind("graphCleared", function () {

                for (var g in groupMap) {
                    if (typeof groupMap[g]._rotors !== "undefined") {
                        _rotors.remove(groupMap[g]);
                    }

                    _jsPlumb.silently(function() {
                        _jsPlumb.getGroupManager().removeGroup(g);
                    });

                    delete groupMap[g]["jtk"];
                }

                // clear nodes
                for (var n in nodeMap) {

                    if (typeof nodeMap[n]._rotors !== "undefined") {
                        _rotors.remove(nodeMap[n]);
                    }

                    _jsPlumb.remove(nodeMap[n], true);
                    delete nodeMap[n]["jtk"];
                }

                _layout && _layout.clear();

                // suspend events, then suspend drawing, then delete every endpoint.
                _jsPlumb.setSuspendEvents(true);
                _jsPlumb.batch(_jsPlumb.deleteEveryEndpoint, true);
                _jsPlumb.setSuspendEvents(false);

                nodeList.length = 0;
                groupList.length = 0;
                connMap = {};
                nodeMap = {};
                groupMap = {};
                reverseNodeMap = {};
                reverseGroupMap = {};
                portMap = {};
                portEndpointMap = {};
            });

            //
            // Notification that a new port was added to some node.  We want to find the corresponding element for the
            // given node, then render the portData using the current rendering mechanism, and finally hand off the node's
            // element and the renderer port element to a helper function (supplied as 'portAdded' to the constructor), for
            // the application to insert the port's UI component at the appropriate location. If no 'portAdded' callback
            // was supplied, we just append the port to the node.
            //
            // For an example of this, consider the database visualizer demo app.  when the user adds a new column it is
            // added as a 'port' to the table node.  We are given the portData and we render it using the column
            // template, but then where does this column get added?  We hand off to the app, and the app knows that it
            // should add the element to the UL that contains the table's columns.
            //
            _toolkit.bind(_e.portAdded, function (params) {
                var nodeEl = nodeMap[params.node.id] || groupMap[params.node.id];
                // get the port element rendered, and then hand it off to the helper, which is responsible for
                // appending it to the appropriate place in the UI.

                var def = view.getPortDefinition(_toolkit.getPortType(params.data));
                if (def.isEndpoint) {
                    configurePort(new ObjectValueExtractor(params.data, nodeEl, params.port), params.node);
                } else {
                    var portEl = portRenderer(params.port, params.data, params.node);
                    portMap[params.node.id + _toolkit.getGraph().getPortSeparator() + params.port.id] = portEl;
                    _checkForPorts(_jsPlumb.getElement(portEl), params.node);
                    self.fire(_e.portAdded, {
                        node: params.node,
                        nodeEl: nodeEl,
                        port: params.port,
                        portEl: portEl
                    });
                }


                _jsPlumb.recalculateOffsets(nodeEl);
                self.refresh(true);
            });

            //
            // Notification that a port was removed from some node.  We want to retrieve the associated node and
            // port elements, then hand off to a helper function (supplied as 'portRemoved' to the constructor) for
            // the application to remove the port's UI component.  If no 'portRemoved' callback was supplied we just
            // attempt to remove the port's element from its parent (which, for many applications, is probably
            // sufficient).
            //
            _toolkit.bind(_e.portRemoved, function (params) {
                var nodeEl = nodeMap[params.node.id] || groupMap[params.node.id],
                    pId = params.node.id + "." + params.port.id,
                    portEl = portMap[pId];

                // remove the port element (suspend events while doing so)
                _jsPlumb.setSuspendEvents(true);
                _jsPlumb.remove(portEl);
                _jsPlumb.setSuspendEvents(false);

                delete portMap[pId];
                self.fire(_e.portRemoved, {
                    node: params.node,
                    port: params.port,
                    portEl: portEl,
                    nodeEl: nodeEl
                });
                _jsPlumb.recalculateOffsets(nodeEl);
                self.refresh(true);
            });

            //
            // Notification that an edge was updated.
            //
            _toolkit.bind(_e.edgeUpdated, function (p) {
                var conn = connMap[p.edge.getId()];
                if (conn) {
                    var newConnectionParameters = _prepareConnectionParams(p.edge);
                    conn.setType(newConnectionParameters.type, newConnectionParameters.data);
                }
            });

            //
            // Notification that a port was updated
            //
            _toolkit.bind(_e.portUpdated, function (p) {
                var portEl = portMap[p.port.getFullId()];
                if (portEl) {
                    _rotors.update(portEl, p.port.data);
                    // repaint the port's node element, not just the port's element.
                    self.repaint(nodeMap[p.node.id]);
                }
            });

            //
            // Notification that a node was updated.
            //
            _toolkit.bind(_e.nodeUpdated, function (p) {
                var nodeEl = nodeMap[p.node.getFullId()];
                if (nodeEl) {
                    _rotors.update(nodeEl, p.node.data);
                    _checkForPorts(nodeEl, p.node);
                    var posse = posseAssigner(p.node);
                    if (posse != null) {
                        var args = JUTIL.isArray(posse) ? posse : [ posse ];
                        args.unshift(nodeEl);
                        _jsPlumb.setPosse.apply(_jsPlumb, args);
                    }
                    else {
                        _jsPlumb.removeFromAllPosses(nodeEl);
                    }

                    self.repaint(nodeEl);
                }
            });

        }

// ----------------------------------------- views    -------------------------------------

        var view;
        /**
         * Sets the current view for this renderer.
         * @method setView
         * @param {Object} p View to set.
         */
        this.setView = function (p) {
            // we merge in the model that has optionally been registered on the toolkit
            // when we do this.  this allows us to register data model stuff on the toolkit (such as max
            // connections etc), and render level stuff on this object.
            var pp = JUTIL.merge(_toolkit.getModel(), p || {});
            view = new JTK.Model(pp, _jsPlumb);
        };

        // create a view.
        this.setView(params.view);

        this.getView = function() { return view; };

// --------------------------- UI states

        var currentStates = [];

        var _getStateTarget = function(target) {
            if (target == null) return _toolkit;
            else if (typeof target === "string") {
                return _toolkit.select(target, true);
            }
            else if (target.jtk) {
                return _toolkit.select(target.jtk.port || target.jtk.node, true);
            }
            else return target;
        };

        /**
         * Activates the UI state with the given ID on the objects contained in the given target. If target is not supplied, the state is
         * activated against the entire dataset.
         * @method activateState
         * @param {String} stateId ID of the state to activate. States are defined inside a `states` member of your `view` definition.
         * @param {Selection|Path|jsPlumbToolkitInstance|Element} [target] Set of objects to activate the state on. If null, the entire dataset (Nodes, Edges and Ports) is used. If you provide an Element here, a Selection is created that consists of the Node representing the element, plus all Edges to and from the given Node.
         */
        this.activateState = function (stateId, target) {
            var s = view.getState(stateId);
            if (s) {
                target = _getStateTarget(target);
                s.activate(target, self, _toolkit);
                currentStates.push(s);
            }
        };

        /**
         * Deactivates the UI state with the given ID on the objects contained in the given target. If target is not supplied, the state is
         * deactivated against the entire dataset.
         * @method deactivateState
         * @param {String} stateId ID of the state to deactivate. States are defined inside a `states` member of your `view` definition.
         * @param {Selection|Path|jsPlumbToolkitInstance} [target] Set of objects to deactivate the state on. If null, the entire dataset (Nodes, Edges and Ports) is used.
         */
        this.deactivateState = function (stateId, target) {
            var s = view.getState(stateId);
            if (s) {
                target = _getStateTarget(target);
                s.deactivate(target, self, _toolkit);
                JUTIL.removeWithFunction(currentStates, function (_s) {
                    return _s == s;
                });
            }
        };

        /**
         * Resets (clears) the UI state of all objects in the current dataset.
         * @method resetState
         */
        this.resetState = function () {
            for (var i = 0; i < currentStates.length; i++) {
                currentStates[i].deactivate(_toolkit, self, _toolkit);
            }
            currentStates.length = 0;
        };

// --------------------------- / UI states


        var _prepareConnectionParams = function (edge) {
            // we use jsPlumb's type system for edge appearance.
            var type = _toolkit.getEdgeType(edge.data),
                p = {
                    type: type,
                    connectionType:type,
                    // pass the 'data' object in; it is used if the edge type is parameterised at all.
                    data: edge.data,
                    cost: edge.getCost(),
                    directed: edge.isDirected()
                },
                td = view.getEdgeDefinition(type);

            // extra properties not supported by jsPlumb's type system: connector and endpoints/endpoint:
            (function(props) {
                if (td) {
                    for (var k = 0; k < props.length; k++) {
                        if (td[props[k]]) p[props[k]] = td[props[k]];
                    }
                }
            })(["connector", "endpoints", "endpoint", "endpointStyles", "endpointStyle"]);

            // expand 'anchor' out to 'anchors', if present (allows easier override below)
            if (p.anchor && !p.anchors) {
                p.anchors = [p.anchor, p.anchor];
                delete p.anchor;
            }

            // expand 'endpoint' out to 'endpoints', if present (allows easier override below)
            if (p.endpoint && !p.endpoints) {
                p.endpoints = [p.endpoint, p.endpoint];
                delete p.endpoint;
            }

            var _substituteParameter = function(toObj, plural, singular, fromObj, idx) {
                if (fromObj && fromObj[singular]) {
                    var prop = toObj[plural] || [ fromObj[singular], fromObj[singular]];
                    prop[idx] = fromObj[singular];
                    toObj[plural] = prop;
                }
            };

            var _one = function (name, idx) {
                if (edge[name].getNode) {
                    var n = edge[name].getNode(),
                        portIdentifier = edge[name].getFullId(),
                        ep = portEndpointMap[portIdentifier] || portMap[portIdentifier];

                    if (ep != null) {
                        p[name] = ep;
                    }
                    else {
                        p[name] = portMap[portIdentifier];
                    }

                    // if still null, just use the node element.
                    if (p[name] == null) {
                        p[name] = nodeMap[_toolkit.getNodeId(n.data)];
                    }

                    var portDef = view.getPortDefinition(edge[name].getType());
                    _substituteParameter(p, "anchors", "anchor", portDef, idx);
                    _substituteParameter(p, "endpoints", "endpoint", portDef, idx);
                }
                else {
                    var uid = _toolkit.getNodeId(edge[name].data);
                    p[name] = nodeMap[uid] || groupMap[uid];
                }
            };

            _one("source", 0);
            _one("target", 1);

            return p;
        };

// ---------------------- create the default node renderer ---------------------------

        var createRenderer = function (objectType, idFunctionToUse, typeFunctionToUse, definitionResolver, defaultRenderFunction, makeDraggableIfRequired, jtkClass, jtkAttributeName) {
            return function (object, data, node) {

                var id = idFunctionToUse(data),
                    obj = null,
                    typeId = typeFunctionToUse(data),
                    def = view[definitionResolver](typeId),
                    _data = data,
                    i;

                // enhanced views are models supporting preconfigured values, and
                // functions as parameter values. This is switched on by default. If you use
                // something that does two-way data binding, such as angular, you will
                // probably want to switch it off, because creating a duplicate of the data here
                // causes the two-way binding to fail.
                if (enhancedView) {
                    _data = JSP.extend({}, def ? def.parameters || {} : {});
                    // then merge node on top, so its values take priority.
                    JSP.extend(_data, data);
                    var mappedData = {};
                    for (i in _data) {
                        if (_data.hasOwnProperty(i)) {
                            if (_data[i] != null) {
                                if (_data[i].constructor == Function)
                                    mappedData[i] = _data[i](data);
                                else
                                    mappedData[i] = _data[i];
                            }
                        }
                    }
                    _data = mappedData;
                }

                if (def) {
                    var tmplId = def.template || ("jtk-template-" + typeId);
                    if (!def.templateRenderer) {
                        obj = _thisTemplateRenderer.render(tmplId, _data, _toolkit, objectType);
                    }
                    else {
                        obj = def.templateRenderer(tmplId, _data, _toolkit, objectType);
                    }
                }
                else obj = defaultRenderFunction(_data, id);

                obj = _jsPlumb.getElement(obj);
                obj.setAttribute(jtkAttributeName, id);
                JSP.addClass(obj, jtkClass);

                // write the data to the element.
                obj.jtk = obj.jtk || {};
                obj.jtk[objectType] = object;
                // always write node.
                obj.jtk.node = node;

                // only for nodes.
                if (makeDraggableIfRequired && draggable && handler.makeDraggable)
                    handler.makeDraggable(obj, def.dragOptions);

                if (droppable && handler.makeDroppable)
                    handler.makeDroppable(obj, def.dropOptions);

                // -------------- events -----------------------

                var _bindOne = function (evt) {
                    _jsPlumb.on(obj, evt, function (e) {
                        def.events[evt]({node: node, el: obj, e: e, toolkit:_toolkit, renderer:self});
                    });
                };

                // EVENTS
                if (def && def.events) {
                    for (i in def.events) {
                        _bindOne(i);
                    }
                }

                return obj;
            };
        };

        var nodeRenderer = createRenderer("node", _toolkit.getNodeId, _toolkit.getNodeType, "getNodeDefinition", _defaultNodeRenderFunction, true, _cl.NODE, atts.NODE);
        var portRenderer = createRenderer("port", _toolkit.getPortId, _toolkit.getPortType, "getPortDefinition", _defaultNodeRenderFunction, false, _cl.PORT, atts.PORT);
        var groupRenderer = createRenderer("group", _toolkit.getNodeId, _toolkit.getNodeType, "getGroupDefinition", _defaultNodeRenderFunction, false, _cl.GROUP, atts.GROUP);

        //
        this.initialize = function () {
            var i, n, j, g, k;

            _toolkit.setSuspendGraph(true);
            // suspend drawing until its all loaded
            _jsPlumb.setSuspendDrawing(true);

            // if a jsPlumb instance was not supplied, we've just created one and it will be empty. we load any
            // data that is in the toolkit.
            if (!params.jsPlumbInstance) {

                // get groups
                for (i = 0, j = _toolkit.getGroupCount(); i < j; i++) {
                    g = _toolkit.getGroupAt(i);
                    _doRenderGroup(g);
                }

                // now add nodes for all vertices
                for (i = 0, j =_toolkit.getNodeCount(); i < j; i++) {
                    n = _toolkit.getNodeAt(i);
                    _doRenderNode(n);
                }

                // next, connect all nodes
                for (i = 0, j = _toolkit.getNodeCount(); i < j; i++) {
                    n = _toolkit.getNodeAt(i);
                    if (nodeMap[n.id]) {
                        var edges = _toolkit.getAllEdgesFor(n);
                        for (k = 0; k < edges.length; k++) {
                            if (edges[k].source == n || edges[k].source.getNode && edges[k].source.getNode() == n) {
                                var def = view.getEdgeDefinition(_toolkit.getNodeType(edges[k].data));
                                if (def && def.ignore === true) continue;
                                var connectionParams = _prepareConnectionParams(edges[k]);
                                connectionParams.doNotFireConnectionEvent = true;
                                var conn = _jsPlumb.connect(connectionParams);
                                if (conn != null) {
                                    conn.edge = edges[k];
                                    connMap[edges[k].getId()] = conn;
                                    _maybeAttachEdgeEvents(connectionParams.type, edges[k], conn);
                                }
                            }
                        }
                    }
                }
            }
            else {
                // otherwise we have to go through all the nodes and edges in the instance and register them as if they had run through
                // our normal rendering process.
                var c = params.jsPlumbInstance.select();
                c.each(function (conn) {
                    connMap[conn.edge.getId()] = conn;
                });
                n = params.jsPlumbInstance.getManagedElements();
                for (var id in n) {
                    var el = n[id].el;
                    nodeMap[el.jtk.node.id] = el;
                    reverseNodeMap[params.jsPlumbInstance.getId(el)] = el.jtk.node;
                }
                if (handler.doImport) handler.doImport(nodeMap, connMap);
            }

            _autoSizeGroups();

            this.relayout();
            _jsPlumb.setSuspendDrawing(false, true);
            _toolkit.setSuspendGraph(false);
        };

        this.getContainer = function () {
            return containerElement;
        };
        this.getContainerId = function () {
            return containerId;
        };

        /**
         * Gets the DOM node that was rendered for the given Node/Port.
         * @method getRenderedElement
         * @param {Node|Port} obj Node or Port for which to retrieve the rendered element.
         * @return {Element} DOM element for the given Node/Port, null if not found.
         */
        this.getRenderedElement = function (obj) {
            if (obj == null) return null;
            var fi = obj.getFullId();
            return obj.objectType === "Port" ? portMap[fi]:
                    obj.objectType === "Group" ? groupMap[fi] :
                    nodeMap[fi];
        };

        /**
         * Gets the DOM node that was rendered for the Node with the given id.
         * @method getRenderedNode
         * @param {String} nodeId Node id for which to retrieve the rendered element.
         * @return {Element} DOM element for the given Node id, null if not found.
         */
        this.getRenderedNode = function (nodeId) {
            return nodeMap[nodeId];
        };

        /**
         * Gets the DOM node that was rendered for the Group with the given id.
         * @method getRenderedGroup
         * @param {String} GroupId Group id for which to retrieve the rendered element.
         * @return {Element} DOM element for the given Group id, null if not found.
         */
        this.getRenderedGroup = function (groupId) {
            return groupMap[groupId];
        };

        /**
         * Gets the DOM node that was rendered for the Port with the given id.
         * @method getRenderedPort
         * @param {String} portId Port id for which to retrieve the rendered element. Note that you must supply the "full" id here, that is in dotted
         * notation with the id of the Node on which the port resides.
         * @return {Element} DOM element for the given Port id, null if not found.
         */
        this.getRenderedPort = function (portId) {
            return portMap[portId];
        };

        /**
         * Gets the underlying jsPlumb connection that was rendered for the Edge with the given id.
         * @method getRenderedConnection
         * @param {String} edgeId ID of the Edge to retrieve the Connection for.
         * @return {Connection} A jsPlumb Connection, null if not found.
         */
        this.getRenderedConnection = function (edgeId) {
            return connMap[edgeId];
        };

        /**
         * Gets the underlying jsPlumb Endpoint that was rendered for the Port with the given ID.
         * @method getRenderedEndpoint
         * @param {String} portId ID of the Port to retrieve the  Endpoint for.
         * @return {Endpoint} a jsPlumb Endpoint, null if not found.
         */
        this.getRenderedEndpoint = function(portId) {
            var info = _getObjectInfo(portId), out = null;
            if (info && info.obj && info.obj.objectType === "Port") {
                _jsPlumb.selectEndpoints({element:info.el}).each(function(ep) {
                    if (ep.graph && ep.graph.port && ep.graph.port === info.obj) {
                        out = ep;
                    }
                });
            }
            return out;
        };

        //
        // helper method to create a layout. used by setLayout and adHocLayout.
        //
        var _createLayout = function(layoutParams) {
            var lp = _jsPlumb.extend({
                container: containerElement,
                getElementForNode: function (id) {
                    return nodeMap[id] || groupMap[id];
                }
            }, layoutParams);
            lp.jsPlumbToolkit = _toolkit;
            lp.adapter = self;

            if (!JTK.Layouts[lp.type]) throw "no such layout [" + lp.type + "]";

            // potentially insert locationFunction, if there isn't one.
            if (!lp.locationFunction) {
                lp.locationFunction = function(node) {
                    return [ ROTORS.data(node.data, _modelLeftAttribute), ROTORS.data(node.data, _modelTopAttribute) ];
                }
            }

            return new JTK.Layouts[lp.type](lp);
        };

        /**
         * Applies the given layout one time to the content.
         * @method adHocLayout
         * @param {Object} layoutParams Parameters for the layout, including type and constructor parameters.
         */
        this.adHocLayout = function(layoutParams) {
            if (layoutParams) {
                var _originalLayout = _layout;
                this.setLayout(layoutParams);
                _layout = _originalLayout; // (but dont refresh)
            }
        };

        /**
         * Sets the current layout.
         * @method setLayout
         * @param {Object} layoutParams Parameters for the layout, including type and constructor parameters.
         * @param {Boolean} [doNotRefresh=false] Do not refresh the UI after setting the new layout.
         */
        this.setLayout = function (layoutParams, doNotRefresh) {
            if (layoutParams) {
                var lp = JSP.extend({jsPlumb : this.getJsPlumb()}, layoutParams);
                _layout = _createLayout(lp);
                if (!doNotRefresh) self.refresh();
            }
        };

        /**
         * Gets the current layout.
         * @method getLayout
         * @return {Layout} The current layout.
         */
        this.getLayout = function () {
            return _layout;
        };

        this.getMagnetizedElements = function() {
            return _layout != null ? _layout.getMagnetizedElements() : [];
        };

        /**
         * Magnetize the display. You must indicate what sort of magnetization you wish to perform: if you provide an event,
         * the event's location will be the magnetization origin. If you provide `origin:{left;xxx, top:xxx}`, that value will be used. If
         * you provide neither, the computed center of all elements will be used. You can also provide an `options:{...}` value, whose
         * values can contain `filter`, `constrain` and `padding` values for the specific run of the magnetizer.
         * @method magnetize
         * @param {Object} [params] Magnetize parameters. If omitted, the origin of magnetization will be the computed center of all the elements.
         * @param {Event} [params.event] If provided, the event location will be used as the origin of magnetization.
         * @param {Object} [params.origin] An object with `left` and `top` properties. If provided, will be used as the origin of magnetization.
         * @param {Object} [params.options] Extra magnetizer options for this run of the magnetizer.
         */
        this.magnetize = function(params) {
            if (_layout != null) _layout.magnetize(params);
        };

        /**
         * Incrementally update the layout, without a reset. If rendering is suspended, this method does nothing.
         * @method refresh
         */
        this.refresh = function (_internal) {
            if (!_suspendRendering && (!_internal || _refreshAutomatically)) {
                if (_layout)
                    _layout.layout(function () {
                        // can this be abstracted?
                        if (typeof window !== "undefined") {
                            window.setTimeout(_jsPlumb.repaintEverything, 0)
                        } else {
                            _jsPlumb.repaintEverything();
                        }
                    });
                else {
                    _jsPlumb.repaintEverything();
                }
            }
        };

        /**
         * Sets whether or not the layout is refreshed automatically after a Node, Port or Group is added or removed.
         * @method setRefreshAutomatically
         * @param {Boolean} refreshAutomatically True to refresh automatically, false otherwise.
         */
        this.setRefreshAutomatically = function (refreshAutomatically) {
            _refreshAutomatically = refreshAutomatically;
        };

        /**
         * Reset the layout and run it again.  This is different to `refresh` in that `refresh` does not reset the layout first.
         * @method relayout
         * @param {Object} [newParameters] Optional new parameters for the layout.
         */
        this.relayout = function (newParameters) {
            if (!_suspendRendering) {
                if (_layout) {
                    _layout.relayout(newParameters, function () {
                        _jsPlumb.repaintEverything();
                        this.fire("relayout", this.getBoundsInfo());
                    }.bind(this));

                }
                else
                    _jsPlumb.repaintEverything();
            }
        };

        /**
         * Gets a Path from some source Node/Port to some target Node/Port. This method is a wrapper around the
         * Toolkit's `getPath` method, adding a `setVisible` function to the result.
         * @method getPath
         * @param {Object} params Path spec params
         * @param {Node|Port|String} params.source Source node or port, or id of source node/port
         * @param {Node|Port|String} params.target Target node or port, or id of target node/port
         * @param {Boolean} [params.strict=true] Sets whether or not paths are searched strictly by the given source/target. If, for instance, you supply a node as the source, but there are only edges connected to ports on that node, by default these edges will be ignored. Switching `strict` to false will mean these edges are considered.
         * @param {Function} [params.nodeFilter] Optional function that is given each Node's backing data and asked to return true or false - true means include the Node, false means exclude it.
         * @param {Function} [params.edgeFilter] Optional function that is given each Edge's backing data and asked to return true or false - true means include the Edge, false means exclude it.
         * @return {Path} a Path object. Even if no path exists you will get a return value - but it will just be empty.
         */
        this.getPath = function (params) {
            var p = _toolkit.getPath(params);
            if (p) {
                p.setVisible = function (val) {
                    self.setVisible(p, val);
                };
                p.addNodeClass = function (clazz) {
                    p.eachNode(function (i, n) {
                        _jsPlumb.addClass(nodeMap[n.id], clazz);
                    });
                };
                p.removeNodeClass = function (clazz) {
                    p.eachNode(function (i, n) {
                        _jsPlumb.removeClass(nodeMap[n.id], clazz);
                    });
                };
                p.addEdgeClass = function (clazz) {
                    p.eachEdge(function (i, e) {
                        connMap[e.getId()].addClass(clazz);
                    });
                };
                p.removeEdgeClass = function (clazz) {
                    p.eachEdge(function (i, e) {
                        connMap[e.getId()].removeClass(clazz);
                    });
                };

                p.addClass = function (clazz) {
                    this.addNodeClass(clazz);
                    this.addEdgeClass(clazz);
                };

                p.removeClass = function (clazz) {
                    this.removeNodeClass(clazz);
                    this.removeEdgeClass(clazz);
                };
            }
            return p;
        };

        /**
         * Gets the position of an element that is being managed by the Surface.
         * @method getPosition
         * @param {String|Element|Selector|Node} el Element id, element, selector or Node to get position for.
         * @return {Number[]|Null} [left,top] position array if element found, otherwise null.
         */
        this.getPosition = function (el) {
            var l = this.getLayout();
            if (l) {
                var id = _getObjectInfo(el).id;
                return l.getPosition(id);
            }
        };

        /**
         * Gets the size of an element that is being managed by the Surface.
         * @method getSize
         * @param {String|Element|Selector|Node} el Element id, element, selector or Node to get position for.
         * @return {Number[]|Null} [width, height] Array if element found, otherwise null.
         */
        this.getSize = function (el) {
            return _jsPlumb.getSize(_getObjectInfo(el).el);
        };

        /**
         * Gets the origin and size of an element that is being managed by the Surface.
         * @method getCoordinates
         * @param {String|Element|Selector|Node} el Element id, element, selector or Node to get position for.
         * @return {Object} {x:.., y:..., w:..., h:...} if element found, otherwise null.
         */
        this.getCoordinates = function (el) {
            var l = this.getLayout();
            if (l) {
                var info = _getObjectInfo(el),
                    p = l.getPosition(info.id),
                    s = _jsPlumb.getSize(info.el);

                return { x: p[0], y: p[1], w: s[0], h: s[1] };
            }
        };

        var portEndpointMap = {};

        var _getPortParameters = function (valueSource, node, overrides) {

            var portId = valueSource.value("port-id"),
                portType = valueSource.value("port-type") || "default",
                portScope = valueSource.value("scope") || _jsPlumb.getDefaultScope(),

                nodeType = _toolkit.getNodeType(node),
                nodeDefinition = view.getNodeDefinition(nodeType),
                portDefinition = view.getPortDefinition(portId, nodeDefinition),
                portTypeDefinition = view.getPortDefinition(portType, nodeDefinition),
                mergedPortDefinition = JUTIL.merge(portTypeDefinition, portDefinition),
                params = mergedPortDefinition == null ? {} : UTIL.populate(mergedPortDefinition, node.data),

                _curryListener = function (listener) {
                    return function (info) {
                        var port = node.getPort(portId),
                            args = [
                                {
                                    portId: portId,
                                    nodeId: node.id,
                                    port: port,
                                    node: node,
                                    portType: portType,
                                    endpoint: info.endpoint,
                                    anchor: info.anchor
                                }
                            ];
                        listener.apply(listener, args);
                    };
                },
                _curryInterceptor = function (interceptor) {
                    return function (info) {
                        var args = [
                            {
                                connection: info.connection || info,
                                source: _getObjectInfo(info.source),
                                target: _getObjectInfo(info.target),
                                scope: info.scope
                            }
                        ];
                        return interceptor.apply(interceptor, args);
                    };
                };

            // Use 'default' as the edge default if there is not one provided via the port definition,
            // and edge-type was not given in the attributes.
            var edgeType = params.edgeType || valueSource.value("edge-type") || "default";

            // expand out the edge type.
            var mappings = {
                    "paintStyle": "connectorStyle",
                    "hoverPaintStyle": "connectorHoverStyle",
                    "overlays": "connectorOverlays",
                    "endpointStyle": "paintStyle"
                },
                edgeParams = view.getEdgeDefinition(edgeType);

            if (edgeParams) {
                for (var i in edgeParams) {
                    var m = mappings[i] || i;
                    if (params[m] == null) {
                        params[m] = edgeParams[i];
                    }
                }
            }
            params.connectionType = edgeType;

            params.portId = portId;
            params.portType = portType;
            params.scope = portScope;

            // set jsplumb parameters
            params.parameters = params.parameters || {};
            params.parameters.portId = portId;
            params.parameters.portType = portType;
            params.parameters.edgeType = edgeType;
            params.parameters.scope = portScope;
            params.parameters.nodeId = node.id;

            params.events = {};
            if (mergedPortDefinition.events) {
                for (i in mergedPortDefinition.events) {
                    params.events[i] = _curryListener(mergedPortDefinition.events[i]);
                }
            }

            // interceptors are eg beforeDrop, beforeDetach. They go straight onto the endpoint definition.
            if (mergedPortDefinition.interceptors) {
                for (i in mergedPortDefinition.interceptors)
                    params[i] = _curryInterceptor(mergedPortDefinition.interceptors[i]);
            }

            // optionally override anchor-x and anchor-y
            var ax = valueSource.value("anchor-x"),
                ay = valueSource.value("anchor-y"),
                ox = valueSource.value("orientation-x"),
                oy = valueSource.value("orientation-y"),
                offx = valueSource.value("offset-x"),
                offy = valueSource.value("offset-y");

            if (ax != null && ay != null) {
                params.anchor = [
                    parseFloat(ax),
                    parseFloat(ay),
                    parseInt(ox || "0", 10),
                    parseInt(oy || "0", 10),
                    parseFloat(offx || "0"),
                    parseFloat(offy || "0")
                ]
            }

            JSP.extend(params, overrides || {});

            // event capture
            params.events.anchorChanged = function (info) {
                self.fire("anchorChanged", {
                    portId: portId,
                    nodeId: node.id,
                    portType: portType,
                    node: node,
                    port: node.getPort(portId),
                    endpoint: info.endpoint,
                    anchor: info.anchor
                });
            };

            return params;
        };

        var AttributeExtractor = function(el) {
            this.element = el.parentNode;
            this.value = function(name, _default) {
                var v = el.getAttribute(name);
                return v == null ? _default : v;
            };
            this.setValue = function(name, value) { el.setAttribute(name, value); };

            this.findDataValues = function(portValues) {
                for (var n = 0; n < el.attributes.length; n++) {
                    var att = el.attributes[n];
                    if (att.name.indexOf("data-") === 0) {
                        portValues[att.value] = att.name.split("-")[1];
                    }
                }
            }
        };
        var ObjectValueExtractor = function(obj, el, existingPort) {
            this.element = el;
            this.port = existingPort;
            this.value = function(name, _default) {
                var v = obj[name.replace(/(\-\w)/g, function(m){return m[1].toUpperCase();})];
                return v == null ? _default : v;
            };
            this.findDataValues = function(portValues) {
                for (var key in obj) {
                    if (key.indexOf("data-") === 0) {
                        portValues[obj[key]] = key.split("-")[1];
                    }
                }
            };

            this.setValue = function(name, value) { el.setAttribute(name, value); };
        };

        function configurePort(valueSource, node, overrides) {
            if (valueSource.value("jtk-processed") == null) {
                valueSource.setValue("jtk-processed", true);

                var portParameters = _getPortParameters(valueSource, node, overrides);

                var ep = _jsPlumb.addEndpoint(valueSource.element, portParameters);
                // store the mapping from node.port to endpoint
                portEndpointMap[node.id + "." + portParameters.portId] = ep;
                // add a port to the node.
                var port = valueSource.port || node.addPort({id: portParameters.portId});

                ep.graph = {
                    node: node,
                    port: port
                };

                _rotors.onUpdate(valueSource.element, function () { });
            }
        }

        function configureSource(valueSource, node, overrides) {
            if (valueSource.value("jtk-processed") == null) {
                valueSource.setValue("jtk-processed", true);
                var portParameters = _getPortParameters(valueSource, node, overrides);

                if (portParameters.portId != null) {
                    // if  port id was provided, add a port to the node and save the mapping
                    // to the element.
                    portMap[node.id + "." + portParameters.portId] = valueSource.element;
                    valueSource.element.jtk = valueSource.element.jtk || {};
                    // add a port to the node.
                    valueSource.element.jtk.port = _toolkit.addPort(node, {
                        id: portParameters.portId,
                        type:portParameters.portType || "default"
                    }, true);
                }

                // if the user supplied a selector to the filter attribute, pass it over.
                // by default the filter is _inclusive_, meaning anything it identifies is a valid
                // drag point. You can set `filter-exclude` to be true to negate this behaviour.
                var filter = valueSource.value("filter");
                if (filter) {
                    var filterExclude = valueSource.value("filter-exclude"), fn = filterExclude === "true";
                    portParameters.filter = filter;
                    portParameters.filterExclude = fn;
                }

                // 'is-source="true"' means the endpoint can be dragged from.
                if (valueSource.value("is-source") === "true") {
                    portParameters.isSource = true;
                }

                // do not support uniqueEndpoint in toolkit. use beforeStartConnect in toolkit
                // instead.
                delete portParameters.uniqueEndpoint;

                // grab any data-*** attributes and provide them to the makeSource call: they indicate
                // attributes we want to read off the source element when drag starts, and whose values
                // will be written into the edge data.
                portParameters.extract = {};
                valueSource.findDataValues(portParameters.extract);

                var sourceDropHandler, curDropCount = valueSource.element._katavorioDrop ? valueSource.element._katavorioDrop.length : 0;
                _jsPlumb.makeSource(valueSource.element, portParameters);
                var newDropCount = valueSource.element._katavorioDrop ? valueSource.element._katavorioDrop.length : 0;
                if (newDropCount > curDropCount) {
                    sourceDropHandler = valueSource.element._katavorioDrop[valueSource.element._katavorioDrop.length - 1];
                }

                _rotors.onUpdate(valueSource.element, function (el, newData) {
                    var portEl = JSP.getSelector(el, "jtk-source");
                    if (portEl.length == 1) {
                        // get port type and scope
                        var newPortParams = _getPortParameters(portEl[0], node);
                        if (newPortParams.scope) {
                            _jsPlumb.setSourceScope(el, newPortParams.scope, newPortParams.edgeType);

                            if (sourceDropHandler) {
                                sourceDropHandler.k.setDropScope(sourceDropHandler, newPortParams.scope);
                            }
                        }
                    }
                });
            }
        }

        function configureTarget(valueSource, node, overrides) {
            if (valueSource.value("jtk-processed") == null) {
                valueSource.setValue("jtk-processed", true);

                var portParameters = _getPortParameters(valueSource, node, overrides);

                if (portParameters.portId != null) {
                    // save target port mapping for element
                    portMap[node.id + "." + portParameters.portId] = valueSource.element;
                    valueSource.element.jtk = valueSource.element.jtk || {};
                    // add a port to the node (it might already exist, in which case this is ignored).
                    valueSource.element.jtk.port = _toolkit.addPort(node, {
                        id: portParameters.portId,
                        type:portParameters.portType || "default"
                    }, true);
                }

                // 'is-target="true"' means the endpoint can be dragged onto.
                if (valueSource.value("is-target") === "true") {
                    portParameters.isTarget = true;
                }

                _jsPlumb.makeTarget(valueSource.element, portParameters);

                // get the Katavorio Drop registration. if/when we change target scope below,
                // we only want to change this particular Drop instance.
                var dropHandler = valueSource.element._katavorioDrop[valueSource.element._katavorioDrop.length - 1];
                _rotors.onUpdate(valueSource.element, function (el, newData) {
                    var portEl = JSP.getSelector(el, "jtk-target");
                    if (portEl.length == 1) {
                        // get port type and scope
                        var newPortParams = _getPortParameters(portEl[0], node);
                        if (newPortParams.scope) {
                            dropHandler.targetDef.def.scope = newPortParams.scope;
                            dropHandler.k.setDropScope(dropHandler, newPortParams.scope);
                        }
                    }
                });
            }
        }

        var _checkForPorts = function (el, node) {

            var i, valueSource;

            var portEls = JSP.getSelector(el, els.PORT);
            var sourceEls = JSP.getSelector(el, els.SOURCE);
            var targetEls = JSP.getSelector(el, els.TARGET);

            for (i = 0;i < sourceEls.length; i++) {
                valueSource = new AttributeExtractor(sourceEls[i]);
                configureSource(valueSource, node);
            }

            for (i = 0;i < targetEls.length; i++) {
                valueSource = new AttributeExtractor(targetEls[i]);
                configureTarget(valueSource, node);
            }

            for (i = 0;i < portEls.length; i++) {
                valueSource = new AttributeExtractor(portEls[i]);
                configurePort(valueSource, node);
            }
        };

        this.setLayout(params.layout, true);

        /**
         * Writes the current left/top for each node into the data model. A common use case is to run an auto layout the first time
         * some dataset is seen, and then to save the locations of all the nodes once a human being has moved things around.
         * @method storePositionsInModel
         * @param {Object} params Parameters
         * @param {String} [params.leftAttribute] Name of the attribute to use for the left position. Default is 'left'
         * @param {String} [params.topAttribute] Name of the attribute to use for the top position. Default is 'top'
         */
        this.storePositionsInModel = function (params) {
            params = params || {};
            var la = params.leftAttribute || "left",
                ta = params.topAttribute || "top";

            var p = _layout.getPositions();
            for (var i in p) {
                var obj = _toolkit.getNode(i) || _toolkit.getGroup(i);
                if (obj) {
                    ROTORS.data(obj.data, la, p[i][0]);
                    ROTORS.data(obj.data, ta, p[i][1]);
                }
            }
        };

        /**
         * Writes the current left/top for some Node or Group into the data model. A common use case is to run an auto layout the first time
         * some dataset is seen, and then to save the locations of all the Nodes/Groups once a human being has moved things around. Note that this method
         * takes either a String, representing the Node or Group's ID, and uses the default values for left/top attribute names, or an Object, in which
         * you provide the id and the left/top attribute names.
         * @method storePositionInModel
         * @param {String} id ID of the Node or Group for which to store the position. Either supply this, or an object containing id and values for the left/top attribute names.
         * @param {Object} params Parameters. An object containing id and values for the left/top attribute names. Supply this or just supply the node id as a string.
         * @param {Integer} params.id Node or Group id
         * @param {Boolean} [params.group=false] If true, the ID given is for a Group, not a Node.
         * @param {String} [params.leftAttribute] Name of the attribute to use for the left position. Default is 'left'.
         * @param {String} [params.topAttribute] Name of the attribute to use for the top position. Default is 'top'.
         * @return {Integer[]} The current position as [left, top].
         */
        this.storePositionInModel = function (params) {
            var id = typeof params == "string" ? params : params.id;

            var la = typeof params == "string" ? "left" : (params.leftAttribute || "left"),
                ta = typeof params == "string" ? "top" : (params.topAttribute || "top"),
                np = _layout.getPosition(id),
                obj = _toolkit[params.group ? "getGroup" : "getNode"](id);

            if (obj) {
                ROTORS.data(obj.data, la, np[0]);
                ROTORS.data(obj.data, ta, np[1]);
            }
            return np;
        };

        var _doSetPosition = function(info, node, x, y, doNotUpdateElement, animateFrom, animateOptions) {
            info = info || _getObjectInfo(node);
            if (info) {
                _layout.setPosition(info.id, x, y);
                if (!doNotUpdateElement) {
                    _jsPlumb.setAbsolutePosition(info.el, [x, y], animateFrom, animateOptions);
                    _jsPlumb.revalidate(info.el);
                }
            }
            return info;
        };

        /**
         * Sets the position of the given Node or Group.
         * @method setPosition
         * @param {String|Node|Element} node Either a Node/Group id, a DOM element representing a Node/Group, or a Node/Group.
         * @param {Integer} x left position for the element.
         * @param {Integer} y top position for the element.
         * @param {Boolean} [doNotUpdateElement=false] If true, the DOM element will not be moved. This flag is used internally by various Toolkit methods; most external calls to this method will want the element to be moved.
         */
        this.setPosition = function (node, x, y, doNotUpdateElement) {
            return _doSetPosition(null, node, x, y, doNotUpdateElement);
        };

        /**
         * Sets the position of the given Node/Group, animating the element to that position.
         * @param {String|Node|Element} node Either a Node/Group id, a DOM element representing a Node/Group, or a Node/Group.
         * @param {Integer} x left position for the element.
         * @param {Integer} y top position for the element.
         * @param {Object} [animateOptions] Options for the animation.
         */
        this.animateToPosition = function(node, x, y, animateOptions) {
            var info =_getObjectInfo(node);
            if (info) {
                var p = _layout.getPosition(info.id);
                _doSetPosition(info, node, x, y, false, [p[0], p[1]], animateOptions);
            }
        };

        /**
         * Sets the visibility of some Node/Port or Edge.
         * @method setVisible
         * @param {Selection|Path|Edge|Node|Port|String|Node[]|Port[]|Edge[]|String[]} obj An Edge, Port, Node or - in the case of String - a  Node/Port id.
         * @param {Boolean} state Whether the object should be visible or not.
         * @param {Boolean} [doNotCascade=false] If true, the method does not cascade visibility changes down from a Node to its connected Edges, or from an Edge to its Ports. The default is for this to happen.
         */
        this.setVisible = function (obj, state, doNotCascade) {
            if (obj == null) return;

            function bothEndpointsVisible(connection) {
                return connection.endpoints[0].element._jtkVisible !== false && connection.endpoints[1].element._jtkVisible !== false;
            }

            var _toggleEdge = function (edge) {
                var c = _getConnectionForEdge(edge);
                if (c) {
                    var doContinue = !state || bothEndpointsVisible(c);
                    if (doContinue) {
                        c.setVisible(state);
                        if (!doNotCascade) {
                            c.endpoints[0].setVisible(state);
                            c.endpoints[1].setVisible(state);
                        }
                    }
                }

            };
            var _toggleNode = function (node, el) {
                if (el) {
                    el.style.display = state ? "block" : "none";
                    el._jtkVisible = state;
                    if (!doNotCascade) {
                        var edges = _toolkit.getAllEdgesFor(node);
                        for (var i = 0; i < edges.length; i++)
                            _toggleEdge(edges[i]);
                    }
                }
            };

            var _togglePort = function (port) {
                var id = port.getFullId(),
                    ep = portEndpointMap[id];

                ep.setVisible(state);
            };

            var _one = function (_obj) {
                var info = _getObjectInfo(_obj);
                switch (info.type) {
                    case "Edge":
                        _toggleEdge(info.obj);
                        break;
                    case "Node":
                        _toggleNode(info.obj, info.el);
                        break;
                    case "Port":
                        _togglePort(info.obj);
                        break;
                }
            };

            // if a Selection or Path (or a Toolkit instance), iterate.
            if (obj.eachNode && obj.eachEdge) {
                obj.eachNode(function (i, n) {
                    _one(n);
                });
                obj.eachEdge(function (i, e) {
                    _one(e);
                });
            }
            else if (obj.length && typeof(obj) !== "string") {
                for (var i = 0; i < obj.length; i++)
                    _one(obj[i]);
            }
            else {
                // otherwise its just a single object.
                _one(obj);
            }
        };

        var _getObjectInfo = function (obj) {
            if (obj instanceof _jsPlumb.getDefaultConnectionType())
                obj = obj.edge;

            // we provide an element resolver here, to augment the toolkit response with DOM elements.
            // for Ports, if the Port has no DOM element of its own, we return the Node's element.
            return _toolkit.getObjectInfo(obj, function (obj) {
                return obj.getNode ? (portMap[obj.getFullId()] || nodeMap[obj.getNode().id]) : (nodeMap[obj.id] || groupMap[obj.id]);
            });
        };

        /**
         * Add the given Node to the posse with the given name
         * @method addToPosse
         * @param {Element|String|Node} obj A DOM element representing a Node, or a Node id, or a Node.
         * @param {String} posse ID of the posse to add the Node to.
         * @param {Boolean} [active=true] If true (which is the default), the Node causes all other Nodes in the Posse
         * to be dragged. If false, this Node drags independently but is dragged whenever an _active_ member of the Posse
         * is dragged,
         */
        this.addToPosse = function(obj, posse, active) {
            UTIL.each(obj, function(_obj) {
                var info = _getObjectInfo(_obj);
                if (info.el) _jsPlumb.addToPosse(info.el, {id:posse, active:active !== false});
            });
        };

        /**
         * Sets the posse(s) for the element with the given id, creating those that do not yet exist, and removing from
         * the element any current Posses that are not specified by this method call. This method will not change the
         * active/passive state if it is given a posse in which the element is already a member.
         * @method setPosse
         * @param {Element} el Element to set posse(s) on.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         */
        this.setPosse = function(obj, posse) {
            UTIL.each(obj, function(_obj) {
                var info = _getObjectInfo(_obj);
                if (info.el) _jsPlumb.setPosse(info.el, posse);
            });
        };

        /**
         * Remove the given Node from the given Posse.
         * @method removeFromPosse
         * @param {Element|String|Node} obj A DOM element representing a Node, or a Node id, or a Node.
         * @param {String} posse ID of the posse from which to remove the Node from.
         */
         this.removeFromPosse = function(obj, posseId) {
            UTIL.each(obj, function(_obj) {
                var info = _getObjectInfo(_obj);
                if (info.el) _jsPlumb.removeFromPosse(info.el, posseId);
            });
        };

        /**
         * Remove the given Node from all Posses to which it belongs.
         * @method removeFromAllPosses
         * @param {Element|String|Node} obj A DOM element representing a Node, or a Node id, or a Node.
         */
        this.removeFromAllPosses = function(obj) {
            UTIL.each(obj, function(_obj) {
                var info = _getObjectInfo(_obj);
                if (info.el) _jsPlumb.removeFromAllPosses(info.el);
            });
        };

        /**
         * Changes the participation state for the given Node in the Posse with the given ID.
         * @param {Element|String|Node} obj A DOM element, node ID or Node to change state for.
         * @param {String} posseId ID of the Posse to change element state for.
         * @param {Boolean} active True to make active, false to make passive.
         */
        this.setPosseState = function(obj, posseId, active) {
            UTIL.each(obj, function(_obj) {
                var info = _getObjectInfo(_obj);
                if (info.el) _jsPlumb.setPosseState(info.el, posseId, active);
            });
        };

        var handler = {
            jsPlumb: _jsPlumb,
            toolkit: _toolkit,
            container: containerElement,
            containerId: containerId,
            getConnectionsForEdges: _getConnectionsForEdges,
            getConnectionForEdge: _getConnectionForEdge,
            getElement: function (nodeId) {
                return nodeMap[nodeId] || groupMap[nodeId];
            },
            getNodeForElementId: function (elementId) {
                return reverseNodeMap[elementId];
            },
            getGroupForElementId: function (elementId) {
                return reverseGroupMap[elementId];
            },
            getObjectInfo: _getObjectInfo,
            nodeMap: function() { return nodeMap; },
            portMap: function() { return portMap; },
            groupMap:function() { return groupMap; },
            reverseNodeMap: function() { return reverseNodeMap; }
        };
        return handler;
    };

    /*
     * DOMElementRenderer
     *
     * A basic Renderer that can have a Layout applied but offers no extra functionality such as zoom/pan etc. This
     * Renderer simply drops elements onto the DOM.
     */
    exports.DOM = function (params) {
        AbstractRenderer.apply(this, arguments);
        DOMElementAdapter.apply(this, arguments);
    };

}).call(typeof window !== 'undefined' ? window : this);

/*
 * SVG Export
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
/**
 * SVG exported. as of 1.0.13 - Jan 11 2016 - this is not yet released. a toSvg method is added to both jsPlumbInstance
 * and Surface.  By default it will use RudimentaryNodeRenderer to draw nodes, but you can supply your own.
 *
 * To test this out, add this to a demo:
 *
 * <script src="../../src/svg-export.js"></script>
 *
 * and then in the console:
 *
  var d = document.createElement("div");
  d.innerHTML = renderer.toSvg();
  d.style.position="fixed";
  d.style.left="0";
  d.style.right="0";
  d.style.top="0";
  d.style.bottom="0";
  d.style.zIndex = 50000;
  document.body.appendChild(d);
 *
 */

;(function() {

    "use strict";

    var root = this,
        _jpi = root.jsPlumbInstance,
        JSPLUMB = root.jsPlumb,
        _jtk = root.jsPlumbToolkit,
        JUTIL = root.jsPlumbUtil;

    // SVG only
    // TODO export for other node renderers to use
    function _writeEl(tag, atts) {
        atts = atts || {};
        var out = "<" + tag;
        for (var a in atts) {
            out += " " + a + "=\"" + atts[a] + "\"";
        }
        return out + "/>";
    }

    //
    // basic node renderer. doesnt actually label nodes. just draws a box that is the same size as the
    // incoming element, and in the same position.
    //
    // Note the return value of this method. 'xml' has the serialized svg. 'bounds' is needed in case
    // the renderer draws outside of the node bounds, which it is entirely allowed to do (consider a large
    // label, for example).
    //

    // SVG only
    var RudimentaryNodeRenderer = function() {
        this.render = function(el, x, y, w, h, data, _jsPlumb) {
            return {
                xml: _writeEl("rect", {
                    x: x,
                    y: y,
                    width: w,
                    height: h,
                    stroke: "black",
                    "stroke-width": 1,
                    fill: "transparent"
                }),
                bounds:[ x, y, x+w, y + h ]
            };
        };
    };


    var jsPlumbSerializer = function(params, handlers) {
        params = params || {};

        var _jsPlumb = params.jsPlumb || this,
            nodes = _jsPlumb.getManagedElements(),
            edges = _jsPlumb.select(),
            endpoints = _jsPlumb.selectEndpoints(),
            entries = { nodes:[], edges:[], endpoints:[] },
            extents = [ Infinity, Infinity, -Infinity, -Infinity ],
            i, p, s, x, y, conn,
            padding = params.padding ||10;

        function _updateExtents(bounds) {
            extents[0] = Math.min(extents[0], bounds.x);
            extents[1] = Math.min(extents[1], bounds.y);
            extents[2] = Math.max(extents[2], bounds.x + bounds.w);
            extents[3] = Math.max(extents[3], bounds.y + bounds.h);
        }

        var NodeEntry = function(el, x, y, w, h) {
            this.el = el;
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        };

        var EdgeEntry = function(conn, x, y) {
            this.x = x;
            this.y = y;
            this.conn= conn;
        };

        var EndpointEntry = function(endpoint, x, y) {
            this.x = x;
            this.y = y;
            this.endpoint = endpoint;
        };

        for (i in nodes) {
            p = _jsPlumb.getPosition(nodes[i].el);
            s = _jsPlumb.getSize(nodes[i].el);
            x = parseInt(p.left);
            y = parseInt(p.top);
            _updateExtents({x:x, y:y, w:s[0]+padding, h:s[1]+padding});
            entries.nodes.push(new NodeEntry(nodes[i].el, x, y, s[0], s[1]));
        }

        // process edges
        for (i = 0; i < edges.length; i++) {
            conn = edges.get(i);
            var cn = conn.getConnector();
            x = cn.x;
            y = cn.y;
            _updateExtents({x:x, y:y, w:0, h:0});
            entries.edges.push(new EdgeEntry(conn, x, y));
            // the connector publishes its bounds in order, originally, for the containing DOM element to be sized
            // appropriately. But the connector is actually DOM agnostic and we can use these numbers here too.
            _updateExtents({x:x + cn.bounds.minX, y:y + cn.bounds.minY, w:cn.bounds.maxX-cn.bounds.minX, h:cn.bounds.maxY-cn.bounds.minY});
        }

        for (i = 0; i < endpoints.length; i++) {
            var ep = endpoints.get(i);
            p = _jsPlumb.getPosition(ep.canvas);
            x = parseInt(p.left);
            y = parseInt(p.top);
            entries.endpoints.push(new EndpointEntry(ep, x, y));
        }

        // ----------------------- shift everything to have origin of 0,0 (with some padding) ------------------------

        var xshift = extents[0] < 0 ? (-extents[0] + padding) : (-extents[0] + padding),
            yshift = extents[1] < 0 ? (-extents[1] + padding) : (-extents[1] + padding);

        for (i = 0; i < entries.nodes.length; i++) {
            entries.nodes[i].x += xshift;
            entries.nodes[i].y += yshift;
        }

        for (i = 0; i < entries.edges.length; i++) {
            entries.edges[i].x += xshift;
            entries.edges[i].y += yshift;
        }

        for (i = 0; i < entries.endpoints.length; i++) {
            entries.endpoints[i].x += xshift;
            entries.endpoints[i].y += yshift;
        }

        // -------------------------- render. -----------------------------------------

        var w = extents[0] < 0 && extents[2] < 0 ? (extents[2] - extents[0]) : extents[0] < 0 && extents[2] > 0 ? extents[2] - extents[0] : extents[2];
        var h = extents[1] < 0 && extents[3] < 0 ? (extents[3] - extents[1]) : extents[1] < 0 && extents[3] > 0 ? extents[3] - extents[1] : extents[3];


        var renderHandle = handlers.start(extents, w, h, _jsPlumb);

        for (i = 0; i < entries.nodes.length; i++) {
            var nodeBounds = handlers.renderNode(entries.nodes[i], renderHandle, extents, _jsPlumb);
            // a node renderer may have drawn outside of the immediate node bounds
            _updateExtents.apply(null, [nodeBounds]);
        }

        for (i = 0; i < entries.edges.length; i++) {
            handlers.renderEdge(entries.edges[i], renderHandle, extents, _jsPlumb);
        }

        for (i = 0; i < entries.endpoints.length; i++) {
            handlers.renderEndpoint(entries.endpoints[i], renderHandle, extents, _jsPlumb);
        }

        return handlers.end(renderHandle);

    };

    var DEFAULT_GET_ENDPOINT_STYLE = function() {
        return {
            "stroke-width":2,
            stroke:"none",
            fill:"#CCC"
        };
    };

    var DEFAULT_GET_CONNECTOR_STYLE = function(connection, connector) {
        return {
            "stroke-width":2,
            stroke:"#CCC",
            fill:"none"
        };
    };

    var DEFAULT_GET_OVERLAY_STYLE = function(connection, connector, overlay) {
        return {
            "stroke-width":2,
            stroke:"#CCC",
            fill:"#CCC"
        };
    }


    /**
     * Serialize an instance of jsPlumb to a single SVG element. This is added to the prototype
     * of jsPlumbInstance as `toSvg`.
     * @method jsPlumbSvgSerializer
     * @param {Object} params Method parameters
     * @param {jsPlumbInstance} [params.jsPlumb]
     * @param {Function} [params.nodeRenderer]
     * @param {Function} [params.getEndpointStyle] If present, will be used to get the style attributes
     * (stroke-width, stroke and fill) for each Endpoint. Otherwise defaults of black fill style and no
     * stroke will be used.
     * @param {Function} [params.getConnectorStyle] If present, will be used to get the style attributes for each
     * Connector.
     * @param {Function} [params.getOverlayStyle] If present, will be used to the get the style attributes for
     * each overlay.
     * @param {String} [params.css] If present, will be rendered in a style block.
     * @param {Object} [params.paintStyle]
     */
    var jsPlumbSvgSerializer = function(params) {

        params = params || {};
        var nodeRenderer = params.nodeRenderer || new RudimentaryNodeRenderer(),
            padding = params.padding || 10,
            viewBox, childNodes = "", childEdges = "", childEndpoints = "",
            getEndpointStyle = params.getEndpointStyle || DEFAULT_GET_ENDPOINT_STYLE,
            getConnectorStyle = params.getConnectorStyle || DEFAULT_GET_CONNECTOR_STYLE,
            getOverlayStyle = params.getOverlayStyle || DEFAULT_GET_OVERLAY_STYLE;

        var endpointHandlers = {
            "Dot":function(ep, x, y) {
                return _writeEl("circle", JSPLUMB.extend({
                    cx: ep.endpoint.radius + x,
                    cy: ep.endpoint.radius + y,
                    r: ep.endpoint.radius
                }, getEndpointStyle(ep)));
            },
            "Rectangle":function(ep, x, y) {
                return _writeEl("rect", JSPLUMB.extend({
                    x: x,
                    y: y,
                    width: ep.endpoint.width,
                    height: ep.endpoint.height
                }, getEndpointStyle(ep)));
            }
        };

        function _renderEdge(entry, renderHandle, extents, _jsPlumb) {
            var connector = entry.conn.getConnector();
            var pathData = connector.getPathData();
            if (pathData) {
                childEdges += _writeEl("path", JSPLUMB.extend({
                    d: pathData,
                    transform: "translate(" + [entry.x, entry.y].join(",") + ")"
                }, getConnectorStyle(entry.conn, connector)));
            }

            // overlays (arrows only for now)
            var overlays = entry.conn.getOverlays(), overlay;
            for (var o in overlays) {
                overlay = overlays[o];
                if (overlay.path) {
                    var style = getOverlayStyle(entry.conn, connector, overlay);
                    childEdges += _writeEl("path", JSPLUMB.extend({
                        d: overlay.path.getAttribute("d") + " Z",
                        transform: "translate(" + [entry.x, entry.y].join(",") + ")"
                    }, style));
                }
            }
        }

        function _renderEndpoint(entry) {
            var o = "";
            if (endpointHandlers[entry.endpoint.type]) {
                o = endpointHandlers[entry.endpoint.type](entry.endpoint, entry.x, entry.y);
            }

            childEndpoints += o;
        }

        function _renderNode(entry, renderHandle, extents, _jsPlumb) {
            var bounds = {x:entry.x, y:entry.y, w:entry.w, h:entry.h};
            var thisEntry = nodeRenderer.render(entry.el, bounds, entry.el.jtk.node.data, _jsPlumb);
            childNodes += thisEntry.xml || thisEntry;
            return thisEntry.bounds || bounds;
        }

// --------------------- calculate view box ----------------------------------------------

        function _start(extents, w, h, _jsPlumb) {
            viewBox = "0 0 " + (w + (2*padding)) + " " + (h + (2*padding));
            return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="' + viewBox + '">';
        }

        function _end(renderHandle) {
            return renderHandle
                + childNodes
                + childEdges
                + childEndpoints
                + "</svg>";
        }

        return jsPlumbSerializer.apply(this, [params, {
            defaultRenderer:RudimentaryNodeRenderer,
            start:_start,
            renderNode:_renderNode,
            renderEdge:_renderEdge,
            renderEndpoint:_renderEndpoint,
            end:_end
        }]);
    };

    //
    // Attach toSvg method to jsPlumb prototype
    //
    _jpi.prototype.toSvg = jsPlumbSvgSerializer;

    //
    // Attach toSvg method to AbstractRenderer prototype
    //
    _jtk.Renderers.AbstractRenderer.prototype.toSvg = function(params) {
        var tk = this.getToolkit(), view = this.getView();
        params = params || {};
        var stroke = params.stroke || "#CCC";
        var fill = params.fill || "#CCC";
        var strokeWidth = params.strokeWidth  || "2";
        var lineJoin = params.lineJoin || "round";
        return this.getJsPlumb().toSvg({
            getConnectorStyle:params.getConnectorStyle || function(connection, connector) {
                var type = tk.getEdgeType(connection.edge.data);
                var def = view.getEdgeDefinition(type);
                return JSPLUMB.extend({
                    stroke:stroke,
                    fill:"none",
                    "stroke-width":strokeWidth
                }, def.paintStyle || {})
            },
            getEndpointStyle:params.getEndpointStyle || function() {
                return {
                    fill:stroke,
                    stroke:"none"
                }
            },
            getOverlayStyle:params.getOverlayStyle || function(connection, connector, overlay) {
                return {
                    fill:fill,
                    stroke:stroke,
                    "stroke-width":strokeWidth,
                    "stroke-linejoin":lineJoin
                };
            },
            nodeRenderer:params.nodeRenderer
        });
    };


    var jsPlumbCanvasSerializer = function(params) {

        params = params || {};

        var ctx, canvas,
            fillStyle = params.fill || "#CCCCCC",
            strokeStyle = params.stroke || "#CCCCCC",
            backgroundColor = params.backgroundColor || "wheat",
            padding = params.padding || 10,
            lineWidth = params.strokeWidth || 1,
            getEndpointStyle = params.getEndpointStyle || DEFAULT_GET_ENDPOINT_STYLE,
            getConnectorStyle = params.getConnectorStyle || DEFAULT_GET_CONNECTOR_STYLE;

        function start(extents, w, h, _jsPlumb) {
            canvas = document.createElement("canvas");
            canvas.width = w + padding;
            canvas.height = h + padding;

            ctx = canvas.getContext("2d");

            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0,0, w + padding, h + padding);
            ctx.restore();

            canvas.style.position = "fixed";
            canvas.style.left = "0";
            canvas.style.width = extents[2] + "px";
            canvas.style.top = "0";
            canvas.style.height = extents[3] + "px";
            canvas.style.zIndex = 50000;

            document.body.appendChild(canvas);
        }

        var endpointHandlers = {
            "Dot":function(ep, x, y) {
                ctx.save();
                var fs = getEndpointStyle(ep);
                ctx.fillStyle = fs.fill;
                ctx.strokeStyle = fs.stroke;
                ctx.lineWidth = fs.strokeWidth;
                ctx.beginPath();
                ctx.arc(x + ep.endpoint.radius / 2, y + ep.endpoint.radius / 2, ep.endpoint.radius, 0, 2 * Math.PI, false);
                ctx.fill();
                ctx.restore();

            },
            "Rectangle":function(ep, x, y) {
                ctx.save();
                var fs = getEndpointStyle(ep);
                ctx.fillStyle = fs.fill;
                ctx.strokeStyle = fs.stroke;
                ctx.lineWidth = fs.strokeWidth;
                ctx.fillRect(x, y, ep.endpoint.width, ep.endpoint.height);
                ctx.restore();
            }
        };

        function renderNode(entry, renderHandle, extents, _jsPlumb) {
            ctx.save();
            ctx.fillStyle = fillStyle;
            ctx.fillRect(entry.x, entry.y, entry.w, entry.h);
            ctx.restore();
        }

        function renderEdge(entry) {
            ctx.save();
            var connector = entry.conn.getConnector();
            var fs = getConnectorStyle(connector);
            ctx.fillStyle = fs.fill;
            ctx.strokeStyle = fs.stroke;
            ctx.lineWidth = fs.strokeWidth;
            var  pathTranslate = connector.pathTranslate || [0,0];
            ctx.translate(entry.x + pathTranslate[0], entry.y + pathTranslate[1]);
            var p = new Path2D(connector.pathData);
            ctx.stroke(p);
            ctx.restore();
        }

        function renderEndpoint(entry) {
            if (endpointHandlers[entry.endpoint.type]) {
                ctx.save();
                endpointHandlers[entry.endpoint.type](entry.endpoint, entry.x, entry.y);
                ctx.restore();
            }
        }

        function end() {
            return canvas;
        }

        return jsPlumbSerializer.apply(this, [ params, {
            start:start,
            end:end,
            renderNode:renderNode,
            renderEdge:renderEdge,
            renderEndpoint:renderEndpoint
        }]);

    };


    //
    // also provide a Headless view
    //
    _jtk.Renderers.Headless = function(params) {
        params = params || {};

        var DEFAULT_CONTAINER_SIZE = [params.width || 500, params.height || 500];
        var _toolkit = params.toolkit;

        var container = params.container;
        if (!container) {
            container = JSPLUMB.createElement();
            container.dim = DEFAULT_CONTAINER_SIZE;
        }

        var p = JSPLUMB.extend(params, {
            templateRenderer:function(templateId, data, toolkit) {
                var d = JSPLUMB.createElement();
                d.data = data;
                return d;
            },
            container:container,
            overrideFns:params.getSize ? {
                getSize:function(el) {
                    var p = { el:el };
                    if (el.jtk) {
                        p.obj =  el.jtk.node || el.jtk.port;
                        p.id = p.obj.getFullId();
                        return params.getSize(p);
                    }
                    else {
                        return this.Defaults.NodeSize;
                    }
                }
            } : null
        });

        var nodes = {};

        var _super = _jtk.Renderers.AbstractRenderer.apply(this, [p]);

        this.getWidth = function () { return container.dim[0]; };
        this.getHeight = function () { return container.dim[1]; };
        this.append = function (el, id) { nodes[id] = el; };
        this.remove = function (e) { delete nodes[e.id]; };
        this.setAbsolutePosition = function(el, pos) { el.pos = pos; };

        this.getOffset = function (e, relativeToPage) {
            return this.getJsPlumb().getOffset(e, relativeToPage);
        };

        // TODO does this need to be implemented?
        this.getBoundsInfo = function() {
            return {
                w: 0,
                h: 0,
                x: 0,
                y: 0,
                vw: container.dim[0],
                vh: container.dim[1],
                padding: 0,
                z: 1,
                zoom: 1
            }
        };

    };

    JUTIL.extend(_jtk.Renderers.Headless, _jtk.Renderers.AbstractRenderer);


    // tODO move this stuff.

    if (typeof window !== 'undefined') {

        window.s = function () {
            var d = document.createElement("div");
            d.innerHTML = renderer.toSvg({css: "*{fill:#7591a0;}"});
            d.style.position = "fixed";
            d.style.left = "0";
            d.style.width = "400px";
            d.style.top = "0";
            d.style.height = "400px";
            d.style.zIndex = 50000;
            d.style.backgroundColor = "wheat";
            document.body.appendChild(d);
        };

        window.c = function () {

            var canvas = new jsPlumbCanvasSerializer({
                jsPlumb: renderer.getJsPlumb(),
                fillStyle: "#89bcde",
                backgroundColor: "wheat"
            });

            var e = document.createElement("a");
            e.setAttribute("href", canvas.toDataURL());
            e.setAttribute("download", "jsplumb.png");
            e.setAttribute("target", "_blank");
            renderer.getJsPlumb().trigger(e, "click");

        }

    }

}).call(typeof window !== 'undefined' ? window : this);



/*
 // The original code that copes the styles form the SVG. not dependable in headless situations; not desirable
 //  in others.

 var sep = ep.canvas;
 var c = sep.querySelector("rect");
 if (c) {
 "stroke-width":getIntStyle(c,  "stroke-width", 2),
 stroke:getStringStyle(c, "stroke", "none"),
 fill:getStringStyle(c, "fill", "black")
 }


 Original path style code. see note above about dependability and desirability.

 "stroke-width":getIntStyle(path,  "stroke-width", 2),
 stroke:getStringStyle(path, "stroke", "black"),
 fill:getStringStyle(path, "fill", "none")


 function _getStyle(typeConverter, el, att, def) {
 var v = el.getAttribute(att) || def;
 return v ? typeConverter(v) : v;
 }


 var getIntStyle = _getStyle.bind(null, function(s) { return parseInt(s); });
 var getFloatStyle = _getStyle.bind(null, function(s) { return parseFloat(s); });
 var getStringStyle = _getStyle.bind(null, function(s) { return s; });

 */
/**
 * Wheel Listener
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
;
/**
 * Wheel listener. Normalises wheel events across browsers.
 *
 */
(function () {

    "use strict";
    var root = this;

    var profiles = {
            "webkit": {
                "mac": function (e) {
                    return e.deltaY / 120;
                },
                "win": function (e) {
                    return e.deltaY / 100;
                }
            },
            "safari": function (e) {
                return e.wheelDeltaY / 120;
            },
            "firefox": {
                "mac": function (e) {
                    return -1 * (e.deltaY * ( e.deltaMode == 1 ? 25 : 1)) / 120;
                },
                "win": function (e) {
                    return -1 * e.deltaY / 3;
                }
            },
            "ie": function (e) {
                return e.wheelDelta / 120;
            },
            "default": function (e) {
                return e.deltaY || e.wheelDelta;
            }
        },
        _os = /Mac/.test(navigator.userAgent) ? "mac" : "win",   // linux?
        _browser = navigator.userAgent.indexOf("Firefox") != -1 ? "firefox" :
            /Chrome/.test(navigator.userAgent) ? "webkit" :
            /Safari/.test(navigator.userAgent) ? "safari" :
                /WebKit/.test(navigator.userAgent) ? "webkit" :
                    /Trident/.test(navigator.userAgent) ? "ie" :
                        "default",
        _profile = typeof profiles[_browser] === "function" ? profiles[_browser] : profiles[_browser][_os],
        _distance = function (evt) {
            return _profile(evt || event);
        },
        _wrap = function (callback, ignoreTouchWheelEvents, requireMetaKey) {

            return function (e) {
                // Firefox posts wheel events for a single touch moving on an element. we may not want that;
                // so if the user set the flag, here we test for the existence of the mozInputSource member, and
                // if it is not 1 (mouse device) then we return.
                if (ignoreTouchWheelEvents && e.mozInputSource != null && e.mozInputSource !== 1) return;

                e.normalizedWheelDelta = _distance(e);
                if (!requireMetaKey || (e.metaKey || e.ctrlKey)) {
                    callback(e);
                }
            };
        },
        supportedEvent = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
                document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
            "DOMMouseScroll"; // let's assume that remaining browsers are older Firefox

    root.addWheelListener = function (el, callback, ignoreTouchWheelEvents, requireMetaKey) {
        var _cb = _wrap(callback, ignoreTouchWheelEvents, requireMetaKey);
        if (el.addEventListener) {
            el.addEventListener(supportedEvent, _cb, false);     // Chrome/Safari/Opera
        }
        else if (el.attachEvent) {
            el.attachEvent('onmousewheel', _cb);                  // IE
        }
    };

}).call(typeof window !== 'undefined' ? window : this);

/*
 * Pinch Listener
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */

/**
 * Pinch listener for all touch browsers - ipad, android, and windows laptops/surfaces. Needless to say,
 * every browser does it differently. IE10+ uses PointerEvents; ipad safari/windows chrome/ipad chrome/
 * android chrome use TouchEvents.  The listener posts pinchstart, pinch happening, and pinch end events.
 */
;(function() {

    var exports = this;

    exports.PinchListener= function(params) {

        var isPointerDevice = "onpointerdown" in document.documentElement,
            isTouchDevice = "ontouchstart" in document.documentElement,
            center = [0,0],
            radius = 0,
            startRadius = 0,
            _fire = function(evt) {
                params[evt](center, startRadius, radius, radius / startRadius);
            },
            _fireEnd = function() { params.onPinchEnd();},
            ON_PINCH_START = "onPinchStart",
            ON_PINCH = "onPinch",
            POINTER_DOWN = "pointerdown", POINTER_MOVE = "pointermove", POINTER_UP = "pointerup",
            TOUCH_START = "touchstart", TOUCH_MOVE = "touchmove", TOUCH_END = "touchend";

        //
        // calc distance between two points
        //
        var _d = function (x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };

        var listenerTypes = {
            "pointer":function() {
                var anchorMap = {},
                    anchors = [],
                    downCount = 0,
                    needsReset = false;

                var _compute = function() {
                    if (downCount == 2) {
                        center = [
                            (anchors[1].p[0] + anchors[0].p[0]) / 2,
                            (anchors[1].p[1] + anchors[0].p[1]) / 2
                        ];
                        radius = _d(anchors[1].p[0], anchors[1].p[1], anchors[0].p[0], anchors[0].p[1]);
                    }
                };

                var _down = function(e) {
                    // we ignore anything more than 2 anchors, or if a pointer was released and we are
                    // awaiting reset.
                    if (downCount >= 2 || needsReset) return;
                    anchors[downCount] = {e:e, p:[e.pageX, e.pageY] };
                    anchorMap["" + e.pointerId] = downCount;
                    downCount++;
                    _compute();
                    if (downCount == 2) {
                        startRadius = radius;
                        _fire(ON_PINCH_START);
                    }
                };

                var _up = function(e) {
                    var idx = anchorMap["" + e.pointerId];
                    if (idx != null) {
                        delete anchorMap["" + e.pointerId];
                        downCount--;
                        // once a finger is removed, we bail until all fingers have been removed and we can start over.
                        needsReset = downCount !== 0;
                        _fireEnd();
                    }
                };

                var _move = function(e) {
                    if (needsReset || downCount != 2) return;
                    var idx = anchorMap[e.pointerId];
                    if (idx != null) {
                        anchors[idx].p = [e.pageX, e.pageY]; // update this pointer's position.
                        _compute();  // recomputer and fire event.
                        _fire(ON_PINCH);
                    }
                };

                params.bind(params.el, POINTER_DOWN, _down);
                params.bind(document, POINTER_UP, _up);
                params.bind(document, POINTER_MOVE, _move);
            },
            "touch":function(params) {
                // for ipad/android and chrome on touch devices.
                var _touches = function(e) {
                    return e.touches || [];
                };

                //
                // extracts the touch with the given index from the list of touches
                //
                var _getTouch = function (touches, idx) {
                    return touches.item ? touches.item(idx) : touches[idx];
                };

                //
                // calculates the distance between the first two touches in the list
                //
                var distance = function (touches) {
                    var t1 = _getTouch(touches, 0), t2 = _getTouch(touches, 1);
                    return _d(t1.pageX, t1.pageY, t2.pageX, t2.pageY);
                };

                //
                // calculates the center point of the first two touches in the list.
                //
                var _center = function (touches) {
                    var t1 = _getTouch(touches, 0), t2 = _getTouch(touches, 1);
                    return [ ( t1.pageX + t2.pageX) / 2, (t1.pageY + t2.pageY) / 2 ];
                };

                var down = false;

                var _down = function(e) {
                    var touches= _touches(e);
                    if (touches.length == 2 && params.enableWheelZoom !== false) {
                        center = _center(touches);
                        radius = startRadius = distance(touches);
                        down = true;
                        params.bind(document, TOUCH_MOVE, _move);
                        params.bind(document, TOUCH_END, _up);
                        _fire(ON_PINCH_START);
                    }
                };

                var _up = function(e) {
                    down = false;
                    params.unbind(document, TOUCH_MOVE, _move);
                    params.unbind(document, TOUCH_END, _up);
                    _fireEnd();
                };

                var _move = function(e) {
                    if (down) {
                        var touches = _touches(e);
                        if (touches.length == 2) {
                            radius = distance(touches);
                            center = _center(touches);
                            _fire(ON_PINCH);
                        }
                    }
                };

                params.bind(params.el, TOUCH_START, _down);

            }
        };

        if (isPointerDevice) listenerTypes.pointer(params);
        else if (isTouchDevice) listenerTypes.touch(params);
    };

}).call(typeof window !== 'undefined' ? window : this);
/*
 * Pan/Zoom Widget
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
;
(function () {

    "use strict";
    var root = this;
    var JSP = root.jsPlumb;

    /**
     * Provides Pan/Zoom functionality.
     * @class ZoomWidget
     * @constructor
     * @param {Object} params Constructor parameters
     * @param {Selector|Element} params.canvas The element to apply pan/zoom to.
     * @param {Selector|Element} params.viewport The element that will act as the viewport for the canvas.
     * @param {Function} params.bind Function that can bind to an event on an element.
     * @param {Function} params.unbind Function that can unbind from an event on an element.
     * @param {Function} params.height A function that can return the height for some element.
     * @param {Function} params.width A function that can return the width for some element.
     * @param {Function} params.offset A function that can return {left:.., top:..} for some element
     * @param {Function} params.id A function that can return an id for some element.
     * @param {Function} [params.domElement] A function that can translate between objects referenced by the widget and DOM elements. It might be
     * the case that no tranlation is required - you deal only in DOM elements. But also you might use this with jQuery,
     * and pass around jQuery selectors. So this function just normalises elements. If not supplied, the default function
     * assumes elements are already DOM elements.
     * @param {Object} [params.events] Optional map of event handlers
     * @param {Function} [params.events.zoom] Optional function callback for when zoom changes.
     * @param {Function} [params.events.pan] Optional function callback for when pan changes.
     * @param {Function} [params.events.mousedown] Optional function callback for mousedown event.
     * @param {Function} [params.events.mouseup] Optional function callback for mouseup event.
     * @param {Function} [params.events.mousemove] Optional function callback for mousemove event.
     * @param {Function} [params.events.maybeZoom] Optional interceptor for zoom. Returning false prevents zoom from occurring.
     * @param {Function} [params.events.transformOrigin] Optional function callback for transform origin change. This is given the [x,y] (in percent) of the new origin, and the [left, top] (in absolute values) of the canvas.
     * @param {Boolean} [params.clamp=true] Whether to clamp when panning such that there is always content visible.
     * @param {Boolean} [params.clampZoom=true] Whether to clamp when zooming such that there is always content visible.
     * @param {Boolean} [params.clampToBackground=false] Whether or not to clamp to the background image. This flag means the widget will always ensure at least some of the background is visible. See `clampToBackgroundExtents` for a variant of this.
     * @param {Boolean} [params.clampToBackgroundExtents=false] Clamps movement so that when zoomed out, the background image always fills the viewport.
     * @param {Function} [params.onBackgroundReady] Optional callback to hit when the background image has loaded.
     * @param {Number} [params.panDistance=50] How far, in pixels, to pan on pan nudge.
     * @param {Number} [params.zoom=1] Initial zoom for the widget.
     * @param {Number[]} [params.zoomRange=[0.05, 3] ] Zoom range for the widget.
     * @param {Boolean} [params.enableWheelZoom=true] Whether or not wheel zoom is enabled.
     * @param {Function} [params.wheelFilter] Optional function to call to check if wheel zooming should be enabled for the current event target.
     * @param {Boolean} [params.wheelZoomMetaKey=false] If true, the "meta" key (CMD on Mac, Ctrl on windows/linux) must
     * be pressed in order for wheel zoom to operate. This can be useful if your UI fills the screen in one or more axes and
     * your users would not be able to scroll past the Surface widget.
     * @param {Boolean} [params.enablePan=true] Whether or not pan is enabled.
     * @param {Boolean} [params.enablePanButtons=true] Whether or not wheel pan buttons are drawn and enabled.
     * @param {Boolean} [params.enableAnimation=true] Enable animations for panning. Defaults to true.
     * @param {Boolean} [params.enabled=true] Whether or not the widget is enabled, ie. responding to mouse input.
     * @param {Object} [params.background] Optional background image parameters
     * @param {String} [params.background.url] URL for the background. Required for both single images and tiled backgrounds.
     * @param {String} [params.background.type="simple"] "simple" or "tiled" - the type of background.
     * @param {Number[]} [params.background.tileSize] For tiled backgrounds, provides the width and height of tiles. Every tile is assumed to have these dimensions, even if the tile has whitespace in it.
     * @param {Number} [params.background.width] Required for tiled backgrounds. Indicates the width of the full image.
     * @param {Number} [params.background.height] Required for tiled backgrounds. Indicates the height of the full image.
     * @param {Number} [params.background.maxZoom] Required for tiled backgrounds. Indicates the maximum zoom level. Zoom starts at 0 - fully zoomed out - and increases in integer values from there. Eash successive zoom level is twice the zoom of the previous level, meaning two times as many tiles in each direction.
     * @param {Function} [params.filter] Optional filter that will be called on down event, with the event target and the event. Returning true from this function means the widget should respond to the event.
     * @param {Number[]} [params.padding] Optional values for padding in the x/y axes to leave around the content. This is only of any use if you have disabled panning via mouse drag,
     * since in that case the user sees only scroll bars and has no way of navigating beyond the content. Some padding makes the UI nicer to use. Default is [0,0].
     * @param {Boolean} [params.consumeRightClick=true] Useful for development: set this to false if you don't want the widget to consume context menu clicks.
     * @param {Boolean} [params.smartMinimumZoom=false] Means that the lower zoom bound refers to a multiple of the content bounds, not the viewport.
     */
    this.ZoomWidget = function (params) {

        params.events = params.events || {};

        var self = this,
            devNull = function () { },
            canvas = params.canvas,
            domElement = params.domElement || function (e) {
                return e;
            },
            canvasElement = domElement(canvas),
            viewport = params.viewport,
            viewportElement = domElement(viewport),
            onZoom = params.events.zoom || devNull,
            onMaybeZoom = params.events.maybeZoom || function () {
                return true;
            },
            onPan = params.events.pan || devNull,
            onMouseDown = params.events.mousedown || devNull,
            onMouseUp = params.events.mouseup || devNull,
            onMouseMove = params.events.mousemove || devNull,
            onSetTransformOrigin = params.events.transformOrigin || devNull,
            clamp = !(params.clamp === false),
            clampZoom = params.clampZoom !== false,
            panDistance = params.panDistance || 50,
            enablePan = params.enablePan !== false,
            enableWheelZoom = params.enableWheelZoom !== false,
            enableAnimation = params.enableAnimation !== false,
            wheelFilter = params.wheelFilter || function () {
                return true;
            },
            wheelZoomRequiresMetaKey = params.wheelZoomMetaKey === true,
            wheelSensitivity = params.wheelSensitivity || 10,
            enablePanButtons = params.enablePanButtons !== false,
            padding = params.padding || [0, 0],
            consumeRightClick = params.consumeRightClick !== false,
            smartMinimumZoom = params.smartMinimumZoom,
            _renderingSuspended = false,
            downEvent = "mousedown",
            upEvent = "mouseup",
            moveEvent = "mousemove",
            transformPrefixes = [ "webkit", "Moz", "ms"],
            bind = params.bind,
            unbind = params.unbind,
            enabled = !(params.enabled === false),
            clampToBackground = params.clampToBackground,
            clampToBackgroundExtents = params.clampToBackgroundExtents,
            filter = params.filter || function (_) {
                return false;
            },
            widthFn = params.width,
            heightFn = params.height,
            backgroundLayer;

// ------------------------  these are the variables required to keep track of the pan/zoom state -----------
        var left = 0,
            top = 0,
            zoom = params.zoom || 1,    // the current zoom level
            transformOrigin = [ 0, 0 ],	// current transform origin values (as percentages)
            panning = false, 			// whether or not we are currently panning
            pinchZooming = false,// whether or not we are currently pinch zooming
            zooming = false,			// whether or not we are currently zooming with right-click mouse
            zoomingWithWheel = false,   // whether or not we are currently mouse wheel zooming
            downAt,                         // the pagex/pagey of either a mousedown or single touchstart, or the center point of a 2 touch touchstart
            zoomRange = params.zoomRange || [0.05, 3],		// allowed range of zoom.
            zoomAtZoomStart,            // the zoom level when zooming began
            maximumZoomTravel = 150,    // the maximum distance in Y that a right-click and drag
        // zoom will respond to. this effectively sets the
        // sensitivity of zooming in that way
            distanceAtZoomStart,        // the distance between touches when zooming began
            lastDistance,
            canvasAtPanStart,           // the location of the canvas when zooming or panning starts.
            lastMouseX = -1,            // last x pos from a mouse move (reset to -1 on mousedown)
            lastMouseY = -1,            // last y pos from a mouse move (reset to -1 on mousedown)

            lastMovedAt = null,
            lastVelocity = 0,
            lastAcceleration = 0;

// ------------------------ these are the variables/functions used to keep track of the content bounds --------------------

        var _canvasBounds = { // bounds of the content
                minx: [],
                maxx: [],
                miny: [],
                maxy: []
            },
            _elementPositions = {},
            _nodeMap = {},
            _suspendMap = {},
            _sortDirtyFlag = false,
            _sortBounds = function () {
                _canvasBounds.minx.sort(function (a, b) {
                    return a[0][0] < b[0][0] ? -1 : 1;
                });
                _canvasBounds.miny.sort(function (a, b) {
                    return a[0][1] < b[0][1] ? -1 : 1;
                });
                _canvasBounds.maxx.sort(function (a, b) {
                    return a[0][0] + a[1] > b[0][0] + b[1] ? -1 : 1;
                });
                _canvasBounds.maxy.sort(function (a, b) {
                    return a[0][1] + a[2] > b[0][1] + b[2] ? -1 : 1;
                });
            },
            _updateBounds = function (id, pos, w, h) {
                if (_elementPositions[id] == null) {
                    _elementPositions[id] = [];
                    _canvasBounds.minx.push(_elementPositions[id]);
                    _canvasBounds.miny.push(_elementPositions[id]);
                    _canvasBounds.maxx.push(_elementPositions[id]);
                    _canvasBounds.maxy.push(_elementPositions[id]);
                }
                _elementPositions[id][0] = pos;
                _elementPositions[id][1] = w;
                _elementPositions[id][2] = h;
                _elementPositions[id][3] = id;

                if (!_renderingSuspended)
                    _sortBounds();
                else
                    _sortDirtyFlag = true;
            },
            _debugBounds = function () {
                console.log("minx:", _canvasBounds.minx[0][0][0], _canvasBounds.minx[0][3], "maxx:", _canvasBounds.maxx[0][0][0], _canvasBounds.maxx[0][3], "miny:", _canvasBounds.miny[0][0][1], _canvasBounds.miny[0][3], "maxy:", _canvasBounds.maxy[0][0][1], _canvasBounds.maxy[0][3]);
            };

        /**
         * Manually set the bounds (position, and x/y) for some element, by id.
         * @method setBoundsFor
         * @param {String} id ID of the element to set bounds for.
         * @param {Number[]} pos Origin of the element
         * @param {Number} w Width of the element
         * @param {Number} h Height of the element
         */
        this.setBoundsFor = _updateBounds;

        /**
         * Sets whether or not rendering is suspended, which for the moment means that when updateBounds is
         * called, the widget doesn't sort the bounds, since we know there will be more changes to the
         * positions and/or sizes of elements.
         * @method setSuspendRendering
         * @param val True to suspend rendering, false to re-enable rendering. If an update was called during the
         * time that rendering was suspended, the positions are sorted once rendering is re-enabled.
         */
        this.setSuspendRendering = function (val) {
            _renderingSuspended = val;
            if (!val && _sortDirtyFlag) _sortBounds();
            _sortDirtyFlag = false;
        };

// ----------------------------- pan buttons ---------------------------------------------------------------

        var curryPanButton = function (dx, dy) {
                return function (e) {
                    _posDelta(canvasElement, dx * panDistance, dy * panDistance, null, true, function (m) {
                        onPan(m[0], m[1], zoom, zoom, e);
                        backgroundLayer && backgroundLayer.pan();
                        fixedLayer.pan();
                    });
                };
            },
            startPanTimeout = 150, // milliseconds
            panRepeatInterval = 60, // milliseconds
            panRepeatDistance = 10,
            _startTimer = null, _repeatTimer = null, currentPanButton = null,
            startPanTimer = function (dx, dy, btn) {
                return function () {
                    currentPanButton = btn;
                    params.addClass(currentPanButton, "jtk-surface-pan-active");
                    params.bind(document, "mouseup", clearPanTimer);
                    _startTimer = window.setTimeout(function () {
                        params.bind(document, upEvent, endPanRepeat);
                        _repeatTimer = window.setInterval(panRepeat(dx, dy), panRepeatInterval);
                    }, startPanTimeout);
                };
            },
            clearPanTimer = function () {
                window.clearTimeout(_startTimer);
                if (currentPanButton) {
                    params.removeClass(currentPanButton, "jtk-surface-pan-active");
                }
                currentPanButton = null;
            },
            panRepeat = function (dx, dy) {
                return function (e) {
                    var m = _posDelta(canvasElement, dx * panRepeatDistance, dy * panRepeatDistance, null);
                    onPan(m[0], m[1], zoom, zoom, e);
                    backgroundLayer && backgroundLayer.pan();
                    fixedLayer.pan();
                };
            },
            endPanRepeat = function () {
                window.clearTimeout(_repeatTimer);
            },
            makePanButton = function (face, props, dx, dy, content) {
                var d = document.createElement("div");
                d.innerHTML = content || "";
                d.style.position = "absolute";
                for (var i in props)
                    d.style[i] = props[i];

                d.className = "jtk-surface-pan jtk-surface-pan-" + face;
                viewportElement.appendChild(d);
                params.bind(d, "click", curryPanButton(dx, dy));
                params.bind(d, "mousedown", startPanTimer(dx, dy, d));
                return d;
            };

        if (enablePanButtons) {
            makePanButton("top", {left: "0px", top: "0px"}, 0, -1, "&#8593;");
            makePanButton("bottom", {left: "0px", bottom: "0px" }, 0, 1, "&#8595;");
            makePanButton("left", {left: "0px", top: "0px" }, -1, 0, "&#8592;");
            makePanButton("right", {right: "0px", top: "0px" }, 1, 0, "&#8594;");
        }

// ----------------------------- /pan buttons --------------------------------------------------------------

        //
        // applies a transform property, by writing the property itself and also all of the
        // vendor-prefixed versions
        //
        var _applyTransformProperty = function (property, value, el) {
            el = el || canvasElement;
            for (var i = 0; i < transformPrefixes.length; i++) {
                var prefixedProp = property.replace(/([a-z]){1}/, function (a) {
                    return transformPrefixes[i] + a.toUpperCase();
                });
                el.style[prefixedProp] = value;
            }
            el.style[property] = value;
        };

        //
        // writes the current transform origin into the canvas' style.
        //
        var _writeTransformOrigin = function (el) {
            _applyTransformProperty("transformOrigin", transformOrigin[0] + "% " + transformOrigin[1] + "%", el);
        };

        //  document.
        var _originHelper = function (x, y) {
            var ap = _apparentOffset(),
                vo = params.offset(viewportElement, true),
                p = _pos(canvasElement),
                w = params.width(canvas),
                h = params.height(canvas),
                xy = [
                        ((x - (vo.left + p[0])) - ap[0]) / zoom,
                        ((y - (vo.top + p[1])) - ap[1]) / zoom
                ];
            return {
                w: w, h: h, xy: xy,
                xScale: xy[0] / w,
                yScale: xy[1] / h,
                o: [
                    xy[0] / w * 100,
                    xy[1] / h * 100
                ]
            };
        };

        var _setTransformHelper = function(xy, w, h, e) {
            var dx1, dy1, dx2, dy2,
                xloc = transformOrigin[0] / 100 * w,
                yloc = transformOrigin[1] / 100 * h;

            // first, store the location of the canvas top/left corner
            dx1 = -(xloc * (1 - zoom));
            dy1 = -(yloc * (1 - zoom));
            // now set the new transform origin
            transformOrigin = xy;
            // and write it to the element
            _writeTransformOrigin();
            xloc = transformOrigin[0] / 100 * w;
            yloc = transformOrigin[1] / 100 * h;
            // now get the new location of the canvas top/left corner
            dx2 = -(xloc * (1 - zoom));
            dy2 = -(yloc * (1 - zoom));
            // and then adjust the canvas to account for the shift caused by changing the transform origin.
            var newPos = _posDelta(canvasElement, dx2 - dx1, dy2 - dy1, e);

            onSetTransformOrigin && onSetTransformOrigin(transformOrigin, newPos);
        };

        //
        // sets the canvas's transform-origin to the given x,y, which is a page location.
        //
        //
        var _setTransformOriginToPoint = function (x, y, e) {
            var d = _originHelper(x, y);
            _setTransformHelper(d.o, d.w, d.h, e);
        };

        //
        // changes the transformOrigin of the canvas to be the point on the canvas at which the
        // given event occurred, then shifts the canvas to account for this change (the user sees
        // no shift)
        //
        var _setTransformOriginToEvent = function (e) {
            var pl = _pageLocation(e);
            _setTransformOriginToPoint(pl[0], pl[1], e);
        };

        //
        // changes the transformOrigin of the canvas to be the given x,y, which is a point on the canvas.
        //
        var _setTransformOriginToCanvasPoint = function(x, y) {
            var w = params.width(canvas), h = params.height(canvas);
            _setTransformHelper([ x / w * 100, y / h * 100 ], w, h);
        };

        /**
         * Decodes the page location from the given event, taking touch devices into account.
         * @method pageLocation
         * @return {Integer[]} [left, top] of the given event.
         */
        var _pageLocation = this.pageLocation = function (e) {
            if (e.pageX != null)
                return [e.pageX, e.pageY];
            else {
                var t = _getTouch(_touches(e), 0);
                if (t)
                    return [ t.pageX, t.pageY ];
                else
                    return [0, 0];
            }
        };

        //
        // extracts the touch with the given index from the list of touches
        //
        var _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        };

        //
        // gets the touches from the given event, if they exist.
        //
        var _touches = function (e) {
            return e.touches || [];
        };

        //
        // sets the current zoom and adjusts the canvas appropriately.
        //
        var _zoom = function (z, e, wheel, animate, dontFireEvent) {
            if (z == null || isNaN(z) || z < 0) return;
            var minZoom = zoomRange[0];

            // clamp to range. smartMinimumZoom means that the lower zoom range refers to a proportion of
            // content bounds, not of the viewport. So a value of 0.8 would mean that the furthest we
            // would zoom out would be to the point that the visible content is 1.25 (1 / 0.8) times
            // smaller than the viewport.  DISABLED.
            if (false || smartMinimumZoom) {
                minZoom = 0.5;
                var smz = getBoundsInfo().z,
                    zoomToContentRatio = z / smz;

                if (zoomToContentRatio < minZoom)
                    z = smz * minZoom;
            }
            else {
                // standard behaviour is just that the minimum refers to a multiple of the viewport size.
                if (z < minZoom) z = minZoom;
            }

            // test maximum.
            if (z > zoomRange[1]) z = zoomRange[1];

            // the zoom operation can be overridden. miniview uses this to detect a change in zoom
            // and change its related surface instead of zooming itself.

            if (animate) {
                // if animate was set, we just want to fire several zoom calls here to get us from the
                // current zoom to the target zoom, and then exit this method.
                var step = z > zoom ? 0.05 : -0.05, cur = zoom, down = z < zoom;
                var ticktock = window.setInterval(function() {
                    cur = _zoom(cur + step);
                    if (down && cur <= z) window.clearInterval(ticktock);
                    if (!down && cur >= z) window.clearInterval(ticktock);
                });
                return zoom;
            }

            _applyTransformProperty("transform", "scale(" + z + ")");
            var oldZoom = zoom;
            zoom = z;
            if (!dontFireEvent)
                onZoom(left, top, zoom, oldZoom, e, wheel);

            // update tile layer
            if (backgroundLayer != null) {
                backgroundLayer.setZoom(z);
            }

            fixedLayer && fixedLayer.pan();

            // clamp the display
            if (clampZoom) {
                var elPos = _pos(canvasElement);
                var cPos = _clamp(elPos[0], elPos[1]);
                if (cPos[0] != elPos[0] || cPos[1] != elPos[1])
                    _pos(canvasElement, cPos[0], cPos[1], null, !animate);
            }

            return zoom;
        };

        //
        // used for right-click zooming.  It takes the amount
        // of travel in the y direction, clamps it to some maximum, and then uses zoomWithMappedRange
        // to translate that into a new zoom value.
        //
        var _zoomBy = function (dx, dy, e, wheel) {
            if (dy < (-maximumZoomTravel)) dy = (-maximumZoomTravel);
            if (dy > maximumZoomTravel) dy = maximumZoomTravel;
            _zoomWithMappedRange(zoomAtZoomStart, dy, (-maximumZoomTravel), maximumZoomTravel, e, wheel);
        };

        //
        // sets zoom the some value with the current range, by calculating where in the range
        // the given 'value' sits.
        //
        var _zoomWithMappedRange = function (startZoom, value, low, high, e, wheel) {
            var p = value / ((value >= 0) ? high : low),
                idx = value >= 0 ? 1 : 0,
                z = startZoom + (p * (zoomRange[idx] - startZoom));

            _zoom(z, e, wheel);
        };

        //
        // takes a desired x,y for the canvas origin and clamps the values such that at least
        // one managed element is visible. you can suppress this behaviour by setting
        // clamp:false in the constructor, or calling setClamp(false) on the widget.
        //
        var _clamp = function (x, y, padding) {
            if (!clamp && !clampToBackground && !clampToBackgroundExtents) return [ x, y ];
            else {
                var ao = _apparentOffset(),
                    _x = x,
                    _y = y,
                    bi = clamp ? getBoundsInfo() : {
                        x: 0, y: 0, w: 0, h: 0,
                        vw: params.width(viewportElement),
                        vh: params.height(viewportElement),
                        padding: padding, z: 1
                    };

                padding = (padding || 20) * zoom;

                if ((clampToBackground || clampToBackgroundExtents) && backgroundLayer != null) {
                    var bw = backgroundLayer.getWidth(),
                        bh = backgroundLayer.getHeight(),
                        xmax = Math.max(bi.x + bi.w, bw),
                        ymax = Math.max(bi.y + bi.h, bh);

                    bi.w = xmax - bi.w;
                    bi.h = ymax - bi.h;

                    var zx = bi.vw / bi.w,
                        zy = bi.vh / bi.h;

                    bi.z = Math.min(zx, zy);

                    // adjust padding so that the background image never leaves the corners
                    if (clampToBackgroundExtents)
                        padding = (Math.max(bi.vw, bi.vh));
                }

                var boundsMax = [ bi.x + bi.w, bi.y + bi.h ];
                if (backgroundLayer) {
                    boundsMax[0] = Math.max(boundsMax[0], backgroundLayer.getWidth());
                    boundsMax[1] = Math.max(boundsMax[1], backgroundLayer.getHeight());
                }

                var dxmin = (x + ao[0]) + (boundsMax[0] * zoom) - padding,
                    dymin = (y + ao[1]) + (boundsMax[1] * zoom) - padding,
                    dxmax = (x + ao[0]) + (bi.x * zoom) + padding,
                    dymax = (y + ao[1]) + (bi.y * zoom) + padding;

                // x min
                if (dxmin < 0) _x -= dxmin;
                // x max
                if (dxmax > bi.vw) _x -= (dxmax - bi.vw);
                // y min
                if (dymin < 0) _y -= dymin;
                // x max
                if (dymax > bi.vh) _y -= (dymax - bi.vh);

                return [ _x, _y ];
            }
        };

        //
        // either gets an element position, or sets it, depending on how many arguments are given.
        // when setting the position, by default it will try to animate the transition. however you
        // can override that by setting doNotAnimate to true, or by not supplying an animate
        // function to the constructor.
        //
        var _pos = function (el, x, y, e, doNotAnimate, onComplete, onStep) {
            if (arguments.length == 1) {
                return [ parseInt(el.style.left, 10) || 0, parseInt(el.style.top, 10) || 0 ];
            }
            else {
                var c = _clamp(x, y);
                if (enableAnimation && !doNotAnimate && params.animate) {
                    params.animate(el, {
                        left: c[0],
                        top: c[1]
                    }, {
                        step: onStep,
                        complete: function () {
                            onComplete && onComplete(c);
                        }
                    });
                }
                else {
                    el.style.left = c[0] + "px";
                    el.style.top = c[1] + "px";
                    onComplete && onComplete(c);
                }

                return c;
            }
        };

        canvasElement.style.left = "0px";
        canvasElement.style.top = "0px";

        //
        // alters the position of the given element by dx,dy
        // return the distance that was allowed, after clamping.
        //
        var _posDelta = function (el, dx, dy, e, animate, onComplete) {
            var p = _pos(el);
            return _pos(el, p[0] + dx, p[1] + dy, e, !animate, onComplete);
        };

        //
        // gets the apparent offset of the canvas, taking zoom and transform origin
        // into account. This is relative to the [0,0] point of the canvas's parent, and when
        // zoom != 1 this will vary from what the DOM itself will tell you. For instance say you
        // have these conditions:
        // left/top : 50, 50
        // w/h      : 400, 400
        // zoom     : 0.5
        // origin   : 50% 50%
        //
        // the canvas appears to be 200,200 in size, in this case centered around 50% 50%. so the
        // apparent offset from the reported left/top will be 100,100.
        //
        // you can see from this maths that a transform origin of 0% 0% will return [0,0] from
        // this method.
        //
        var _apparentOffset = function () {
            var w = params.width(canvas),
                h = params.height(canvas),
                xloc = (transformOrigin[0] / 100) * w,
                yloc = (transformOrigin[1] / 100) * h;

            return [
                    xloc * ( 1 - zoom ),
                    yloc * ( 1 - zoom )
            ];
        };

        // event handlers. these are the core of the functionality.
        var handlers = {
            "start": function (e, touches) {
                if (pinchZooming) return;
                var target = e.srcElement || e.target;
                if (enabled && (target == canvasElement || target == viewportElement || target._jtkDecoration || (backgroundLayer && backgroundLayer.owns(target)) || filter(target, e) === true)) {
                    zoomingWithWheel = false;
                    lastMouseX = -1;
                    lastMouseY = -1;
                    if (e.which === 3 && params.enableWheelZoom !== false && (e.mozInputSource == null || e.mozInputSource === 1)) {
                        zooming = true;
                        downAt = _pageLocation(e);
                        _setTransformOriginToEvent(e);
                        canvasAtPanStart = _pos(canvasElement);
                        zoomAtZoomStart = zoom;
                    }
                    else if (touches.length <= 1) {
                        panning = true;
                        downAt = _pageLocation(e);
                        canvasAtPanStart = _pos(canvasElement);
                    }
                }
                onMouseDown(e, self);
            },
            "move": function (e, touches) {
                var dx, dy, pl;
                zoomingWithWheel = false;
                if (pinchZooming) return;
                if (zooming) {
                    pl = _pageLocation(e);
                    dx = pl[0] - downAt[0];
                    dy = pl[1] - downAt[1];
                    _zoomBy(dx, dy, e);
                }
                else if (panning && enablePan && downAt != null) {
                    pl = _pageLocation(e);
                    dx = pl[0] - downAt[0];
                    dy = pl[1] - downAt[1];

                    var clampedMovement = _pos(canvasElement, (canvasAtPanStart[0] + dx), (canvasAtPanStart[1] + dy), e, true);

                    onPan(clampedMovement[0], clampedMovement[1], zoom, zoom, e);
                    backgroundLayer && backgroundLayer.pan();
                    fixedLayer && fixedLayer.pan();
                }
                onMouseMove(e, self);
            },
            "end": function (e, touches) {
                if (pinchZooming) return;
                zooming = false;
                downAt = null;
                panning = false;
                zoomingWithWheel = false;
                unbind(document, moveEvent, _curriedMove);
                unbind(document, upEvent, _curriedEnd);
                bind(document, moveEvent, _moveReset);
                onMouseUp(e, self);

            },
            "contextmenu": function (e) {
            }
        };

        var _call = function (type, e) {
                if (type == "contextmenu" && consumeRightClick)
                    e.preventDefault && e.preventDefault();
                var t = _touches(e);
                handlers[type](e, t);
            },
            _curriedMove = function (e) {
                _call("move", e);
            },
            _curriedEnd = function (e) {
                _call("end", e);
            },
            _moveReset = function (e) {
                zoomingWithWheel = false;
            };

        // bind the moveReset function to move; it is unbound on downEvent and re-bound on up event
        bind(document, moveEvent, _moveReset);

        /**
         * Programmatically report a down event in order to kick the widget into action.
         * @method start
         * @param {Event} e Mouse event to use to kick things off.
         */
        var _start = this.start = function (e) {
            if (enabled && e != null) {
                unbind(document, moveEvent, _moveReset);
                bind(document, moveEvent, _curriedMove);
                bind(document, upEvent, _curriedEnd);
                handlers["start"](e, _touches(e));
            }
        };
        // bind start event. it is responsible for attaching move event and end event to the document
        bind(viewport, downEvent, _start);

        bind(viewport, "contextmenu", function (e) {
            _call("contextmenu", e);
        });

        if (enableWheelZoom) {
            var wheelZoom = function (e) {
                if (wheelFilter(e)) {
                    e.preventDefault && e.preventDefault();
                    e.stopPropagation && e.stopPropagation();

                    zoomAtZoomStart = zoom;
                    if (!zoomingWithWheel) {
                        _setTransformOriginToEvent(e);
                        zoomingWithWheel = true;
                    }
                    _zoomBy(0, e.normalizedWheelDelta * wheelSensitivity, e, true);
                }
            };
            // Firefox posts wheel events for a single touch moving on an element. we dont want that.
            // we want pinch to zoom.
            addWheelListener(viewportElement, wheelZoom, true, wheelZoomRequiresMetaKey);
        }

        // pinchlistsner
        new PinchListener({
            el:viewport,
            bind:bind,
            unbind:unbind,
            enableWheelZoom:params.enableWheelZoom,
            onPinch:function(center, startRadius, radius, ratio) {
                _zoom(ratio * zoomAtZoomStart);
                var dx = center[0] - downAt[0], dy = center[1] - downAt[1];
                _pos(canvasElement, canvasAtPanStart[0] + dx, canvasAtPanStart[1] + dy, null, true);
            },
            onPinchStart:function(center, startRadius) {
                pinchZooming = true;
                downAt = center;
                distanceAtZoomStart = lastDistance = startRadius;
                zoomAtZoomStart = zoom;
                _setTransformOriginToPoint(downAt[0], downAt[1]);
                canvasAtPanStart = _pos(canvasElement);
            },
            onPinchEnd:function() {
                pinchZooming = false;
                downAt = null;
            }
        });

        // force transform origin and scale
        _zoom(zoom, null, false, false, true);
        _writeTransformOrigin();

        function getBoundsInfo(padding, paddingRatio) {

            if (isEmpty()) {
                return {
                    w: 0,
                    h: 0,
                    x: 0,
                    y: 0,
                    vw: params.width(viewportElement),
                    vh: params.height(viewportElement),
                    padding: padding,
                    z: 1,
                    zoom: 1
                };
            }

            padding = padding || 0;
            paddingRatio = paddingRatio || 0.9;
            var boundsW = Math.abs((_canvasBounds.maxx[0][0][0] + _canvasBounds.maxx[0][1]) - _canvasBounds.minx[0][0][0]),
                boundsH = Math.abs((_canvasBounds.maxy[0][0][1] + _canvasBounds.maxy[0][2]) - _canvasBounds.miny[0][0][1]),
                viewportW = params.width(viewportElement),
                viewportH = params.height(viewportElement),
                zx = viewportW / ((boundsW + (padding * 2)) / paddingRatio),
                zy = viewportH / ((boundsH + (padding * 2)) / paddingRatio),
                z = Math.min(zx, zy);

            return {
                w: boundsW,
                h: boundsH,
                x: _canvasBounds.minx[0][0][0],
                y: _canvasBounds.miny[0][0][1],
                vw: viewportW,
                vh: viewportH,
                padding: padding,
                z: z,
                zoom: zoom
            };
        }

        function isEmpty() {
            for (var i in _elementPositions)
                return false;
            return true;
        }

// -------------------------   public API -------------------------------------------------------


        /**
         * Registers that an element has changed position, updating bounds info as necessary.
         * @method positionChanged
         * @param {Element} el Element that has just moved.
         * @param {Number[]} [pos] New position. If this is omitted, it will be calculated.
         * @param {String} [id] Optional id of the element. This might be called from a context in which
         * the id is known already, so we can save some work.
         */
        this.positionChanged = function (el, pos, id) {
            id = id || params.id(el);
            var p = pos || _pos(el), w = params.width(el), h = params.height(el);
            _nodeMap[id] = el;
            _updateBounds(id, p, w, h);
        };

        /**
         * Adds the given element to those that this widget is tracking.
         * @method add
         * @param {Element} el Element to begin tracking.
         * @param {String} [id] Optional id of the element. This might be called from a context in which
         * the id is known already, so we can save some work.
         * @param {Number[]} [pos] Optional location for the node.  If not provided, the position will be retrieved from a call to the DOM.
         */
        this.add = function (el, id, pos, isDecoration) {
            this.positionChanged(el, pos, id);
            if (isDecoration) {
                bind(el, downEvent, _start);
                el._jtkDecoration = true;
            }
        };

        this.suspend = function(el) {
            var id = typeof el === "string" ? el : params.id(el);
            _suspendMap[id] = true;
            _removeFromTracking(id);
        };
        this.isSuspended = function(el) {
            var id = typeof el === "string" ? el : params.id(el);
            return _suspendMap[id] === true;
        };

        this.restore = function(el) {
            var id = typeof el === "string" ? el : params.id(el);
            delete _suspendMap[id];
            this.positionChanged(el, null, id);
        };

        /**
         * Removes the given element from the list this widget is tracking. Note that this widget does
         * not remove the element from the DOM.
         * @method remove
         * @param {Selector|Element} el Element to stop tracking.
         */
        this.remove = function (el) {
            el = domElement(el);
            var id = params.id(el);

            delete _elementPositions[id];
            delete _nodeMap[id];
            delete _suspendMap[id];

            _removeFromTracking(id);
        };

        //
        // used by both `remove` and `suspend`
        function _removeFromTracking(id) {
            for (var i in _canvasBounds) {
                if (_canvasBounds.hasOwnProperty(i)) {
                    var idx = -1;
                    for (var j = 0; j < _canvasBounds[i].length; j++) {
                        if (_canvasBounds[i][j][3] === id) {
                            idx = j;
                            break;
                        }
                    }
                    if (idx != -1) _canvasBounds[i].splice(idx, 1);
                }
            }
        }

        /**
         * Removes all tracked elements and resets the widget.
         * @method reset
         */
        this.reset = function () {
            _canvasBounds.minx.length = 0;
            _canvasBounds.miny.length = 0;
            _canvasBounds.maxx.length = 0;
            _canvasBounds.maxy.length = 0;
            _elementPositions = {};
            _nodeMap = {};
            _suspendMap = {};
            _pos(canvasElement, 0, 0, null, true);
        };

        /**
         * Gets the current bounds information.
         * @method getBoundsInfo
         * @return {Object} An object with these fields:
         * w - width of the content
         * h - height of the content
         * x - minimum x value of all nodes in the content
         * y - minimum y value of all nodes in the content
         * vw - width of the viewport
         * vh - height of the viewport
         * padding - padding around the content (an array)
         * z - smallest zoom that could result in all the content being visible inside the viewport
         * zoom - current zoom
         */
        this.getBoundsInfo = getBoundsInfo;

        /**
         * Zooms the display so that all the tracked elements fit inside the viewport. This method will also,
         * by default, increase the zoom if necessary - meaning the default behaviour is to adjust the zoom so that
         * the content fills the viewport. You can suppress zoom increase by setting `doNotZoomIfVisible:true` on the
         * parameters to this method.
         * @method zoomToFit
         * @param {Number} [params.padding=0] Optional padding to leave around all elements.
         * @param {Number} [params.fill=0.9] Amount of the viewport to fill. By default, this method will zoom so that the content is 0.9 times the size of the viewport.
         * Aesthetically this makes for a more pleasing result than filling the viewport entirely.
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotAnimate=true] By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
         * @param {Boolean} [params.doNotZoomIfVisible=false] If true, no action is taken if the content is currently all visible.
         * @param {Boolean} [params.doNotFirePanEvent=false] If true, a pan event will not be fired.
         */
        this.zoomToFit = function (params) {
            params = params || {};
            var bi = getBoundsInfo(params.padding, params.fill);

            if (!(params.doNotZoomIfVisible && bi.z > zoom))
                _zoom(bi.z);

            self.centerContent({
                bounds: bi,
                doNotAnimate: params.doNotAnimate !== false,
                onComplete: params.onComplete,
                onStep: params.onStep,
                doNotFirePanEvent: params.doNotFirePanEvent
            });
        };


        /**
         * Zooms the display so that all the tracked elements fit inside the viewport, but does not make any adjustments
         * to zoom if all the elements are currently visible (it still does center the content though).
         * @method zoomToFitIfNecessary
         * @param {Number} [params.padding = 0] Optional padding to leave around all elements.
         * @param {Number} [params.fill=0.9] Amount of the viewport to fill. By default, this method will zoom so that the content is 0.9 times the size of the viewport.
         * Aesthetically this makes for a more pleasing result than filling the viewport entirely.
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotAnimate=true] By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
         */
        this.zoomToFitIfNecessary = function (params) {
            var p = JSP.extend(params || {});
            p.doNotZoomIfVisible = true;
            this.zoomToFit(p);
        };

        /**
         * Zooms the display so that all the given elements fit inside the viewport.
         * @method zoomToElements
         * @param {Object} zParams
         * @param {Element[]} zParams.elements List of DOM elements to zoom to.
         * @param {Number} [zParams.fill=0.90] A decimal indicating how much of the viewport to fill with the zoomed content.
         * @param {Boolean} [zParams.doNotZoomIfVisible=false] If true and the widget determines the entire selection is already
         * visible, the zoom will not be adjusted.
         */
        this.zoomToElements = function(zParams) {
            var bi = {
                x:Infinity, y:Infinity,
                xMax:-Infinity, yMax:-Infinity,
                z:1,
                vw:params.width(viewportElement),
                vh:params.height(viewportElement)
            };

            for (var i = 0; i < zParams.elements.length; i++) {
                var e = zParams.elements[i];
                var o = params.offset(e), w = params.width(e), h = params.height(e);
                bi.x = Math.min(bi.x, o.left);
                bi.y = Math.min(bi.y, o.top);
                bi.xMax = Math.max(bi.xMax, o.left + w);
                bi.yMax = Math.max(bi.yMax, o.top + h);
            }

            var fill = params.fill || 0.9;

            bi.w = fill * (bi.xMax - bi.x);
            bi.h = fill * (bi.yMax - bi.y);
            bi.z = Math.min(bi.vw / bi.w, bi.vh / bi.h);

            if (!(zParams.doNotZoomIfVisible && bi.z > zoom))
                _zoom(bi.z);

            self.centerContent({
                bounds: bi,
                doNotAnimate: zParams.doNotAnimate !== false,
                onComplete: zParams.onComplete,
                onStep: zParams.onStep,
                doNotFirePanEvent: zParams.doNotFirePanEvent
            });
        };

        /**
         * Zooms the display so that the background fits inside the viewport.
         * @method zoomToBackground
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotAnimate=false] If true, centering content will not use animation.
         */
        this.zoomToBackground = function (params) {
            params = params || {};
            if (backgroundLayer != null) {
                var boundsW = backgroundLayer.getWidth(),
                    boundsH = backgroundLayer.getHeight(),
                    viewportW = widthFn(viewportElement),
                    viewportH = heightFn(viewportElement),
                    zx = viewportW / boundsW,
                    zy = viewportH / boundsH,
                    z = Math.min(zx, zy),
                    bi = { w: boundsW, h: boundsH, x: 0, y: 0, vw: viewportW, vh: viewportH, padding: 0, z: z };

                _zoom(bi.z);
                self.centerContent({
                    bounds: bi,
                    doNotAnimate: params.doNotAnimate,
                    onComplete: params.onComplete,
                    onStep: params.onStep
                });
            }
        };

        /**
         * Sets (or clears) the filter that will be called if the widget needs to know whether to respond to an event that would
         * start a pan. By default, the widget responds to down events on the viewport or the canvas, but not on child nodes. You
         * can supply a function that the widget will call in the event that the down event did not occur on the viewport or the canvas;
         * returning true from this function will cause the pan to begin.
         * @method setFilter
         * @param {Function} filterFn Function to set as the filter; may be null if you wish to clear it. The function should return true if it wants to honour the down event on the given element.
         */
        this.setFilter = function (filterFn) {
            filter = filterFn || function (_) {
                return false;
            };
        };

        /**
         * Position the widget so the background is centered in the viewport, without changing the current zoom.
         * @method centerBackground
         */
        this.centerBackground = function () {
            if (backgroundLayer != null) {
                var bi = JSP.extend({}, getBoundsInfo());
                bi.x = backgroundLayer.getWidth() / 2;
                bi.y = backgroundLayer.getHeight() / 2;
                bi.w = 1;
                bi.h = 1;

                self.centerContent({
                    bounds: bi,
                    doNotAnimate: params.doNotAnimate,
                    onComplete: params.onComplete,
                    onStep: params.onStep,
                    vertical: true,
                    horizontal: true
                });
            }
        };

        /**
         * Positions the widget so that the edges of the background align with the viewport. This method is useful for
         * snapping to a corner of the background.
         * @method alignBackground
         * @param {String} [axes] Spec for the axes to align to. This should be a space-separated string containing a value
         * for the x (allowed values `left` and `right`) and, optionally, y (allowed values `top` and `bottom`) axes. The
         * default value is `"left top"`.
         */
        this.alignBackground = function (axes) {
            if (backgroundLayer != null) {
                var a = axes || "left top",
                    aa = axes.split(" "),
                    ax = aa[0] || "left",
                    ay = aa[1] || "top",
                    bi = getBoundsInfo(),
                    l = ax === "left" ? 0 : bi.vw - (backgroundLayer.getWidth() * zoom),
                    t = ay === "top" ? 0 : bi.vh - (backgroundLayer.getHeight() * zoom),
                    ap = _apparentOffset();

                _pos(canvasElement, l - ap[0], t - ap[1]);
                backgroundLayer.pan();
                fixedLayer && fixedLayer.pan();
            }
        };

        /**
         * Places (using `style.left` and `style.top`) the given element at the given x,y, which is taken to
         * mean an x,y value on the canvas.  At zoom 1, with no panning, this will be the same as the given x,y value
         * relative to the viewport origin.  But once the canvas has been zoomed and panned we have to map
         * to the altered coordinates. This function also takes into account the difference between the offset of the
         * viewport in the page and the offset of the given element. It is assumed, just because of what this method
         * does, that the given element will be positioned `absolute`, but this method does nothing to ensure that.
         * @method positionElementAt
         * @param {Selector|Element|String} el Element to position.
         * @param {Number} x X location on canvas to move element's left edge to.
         * @param {Number} y Y location on canvas to move element's top edge to.
         * @param {Number} [xShift=0] Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
         * @param {Number} [yShift=0] Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
         * @param {Boolean} [ensureOnScreen=false] If true, will ensure that x and y positions are never negative.
         */
        this.positionElementAt = function (el, x, y, xShift, yShift, ensureOnScreen) {
            xShift = xShift || 0;
            yShift = yShift || 0;
            var ao = _apparentOffset(),
                cp = _pos(canvasElement),
                del = domElement(el),
                p = del.parentNode,
                po = params.offset(p),
                vo = params.offset(viewport),
                _x = (vo.left - po.left) + (cp[0] + ao[0]) + (x * zoom) + (xShift),
                _y = (vo.top - po.top) + (cp[1] + ao[1]) + (y * zoom) + (yShift);

            if (ensureOnScreen && _x < 0) _x = 0;
            if (ensureOnScreen && _y < 0) _y = 0;

            del.style.left = _x + "px";
            del.style.top = _y + "px";
        };

        /**
         * Places (using `style.left` and `style.top`) the given element at the given page x,y.  It is assumed, just because of what this method
         * does, that the given element will be positioned `absolute`, but this method does nothing to ensure that.
         * @method positionElementAt
         * @param {Selector|Element|String} el Element to position.
         * @param {Number} x X location on canvas to move element's left edge to.
         * @param {Number} y Y location on canvas to move element's top edge to.
         * @param {Number} [xShift=0] Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
         * @param {Number} [yShift=0] Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
         */
        this.positionElementAtPageLocation = function (el, x, y, xShift, yShift) {
            var lt = this.mapLocation(x, y);
            this.positionElementAt(el, lt.left, lt.top, xShift, yShift);
        };

        /**
         * Places (using `style.left` and `style.top`) the given element at the page x,y corresponding to the given event.  It is assumed, just because of what this method
         * does, that the given element will be positioned `absolute`, but this method does nothing to ensure that.
         * @method positionElementAt
         * @param {Selector|Element|String} el Element to position.
         * @param {Event} evt Event to position element at.
         * @param {Number} [xShift=0] Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
         * @param {Number} [yShift=0] Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
         */
        this.positionElementAtEventLocation = function (el, evt, xShift, yShift) {
            var lt = this.mapEventLocation(evt);
            this.positionElementAt(el, lt.left, lt.top, xShift, yShift);
        };

        /**
         * Zooms the component by the given increment, centered on the location at which the given event occurred.
         * @method zoomToEvent
         * @param {Event} e Browser event
         * @param {Number} increment Amount to zoom by (a positive or negative number). If this takes the component out of the current zoom range, it will be clamped.
         */
        this.zoomToEvent = function (e, increment) {
            _setTransformOriginToEvent(e);
            _zoom(zoom + increment, e);
        };

        /**
         * Tells the widget that a relayout has occurred. If panning is
         * disabled, the widget will move the canvas element so that all
         * content is visible, and adjust the transform origin so that the ui
         * zooms from the apparent top left corner.
         * @method relayout
         * @param {Object} boundsInfo Bounds information, in the same format as the `getBoundsInfo` method returns.
         * @param {Boolean} [doNotAnimate=false] If true, the widget will not animate the change.
         */
        this.relayout = function (boundsInfo, doNotAnimate) {
            if (params.enablePan === false) {
                _pos(canvasElement, -boundsInfo.x + padding[0], -boundsInfo.y + padding[1], null, doNotAnimate);
                // allow for padding - sizing the canvas will give the overflow we need
                var pw = boundsInfo.w + (boundsInfo.x < 0 ? boundsInfo.x : 0) + padding[0],
                    ph = boundsInfo.h + (boundsInfo.y < 0 ? boundsInfo.y : 0) + padding[1];
                canvasElement.style.width = pw + "px";
                canvasElement.style.height = ph + "px";
                var tox = pw == 0 ? 0 : (boundsInfo.x - padding[0]) / pw * 100,
                    toy = ph == 0 ? 0 : (boundsInfo.y - padding[1]) / ph * 100;
                // transformOrigin
                this.setTransformOrigin(tox, toy);
            }
        };

        /**
         * Nudges the zoom by the given amount. Zoom will be clamped to the current zoom range in effect and the
         * value that was ultimately set is returned from this function.
         * @method nudgeZoom
         * @param {Number} delta Amount to change zoom by. The value you pass in here is multiplied by
         * 100 to give a percentage value: 1 is 100%, for instance, 0.05 is 5%. You can pass in negative numbers to
         * zoom out.
         * @param {Event} [e] Original event that caused the nudge. May be null.
         * @return {Number} The zoom that was set. Zoom will be clamped to the allowed range.
         */
        this.nudgeZoom = function (delta, e) {

            // first set transform origin to be center of viewport
            var vo = params.offset(viewportElement, true),
                mx = vo.left + (params.width(viewportElement) / 2),
                my = vo.top + (params.height(viewportElement) / 2);

            _setTransformOriginToPoint(mx, my);

            return _zoom(zoom + delta, e);
        };

        /**
         * Nudges the wheel zoom by the given amount. This function is intended for use by components that control
         * zoom via the mouse wheel, and not for general usage. See `nudgeZoom` for a more general version of this.
         * @method nudgeWheelZoom
         * @param {Number} delta Amount to change zoom by.
         * @param {Event} [e] Original event that caused the nudge. May be null.
         */
        this.nudgeWheelZoom = function (delta, e) {
            zoomAtZoomStart = zoom;
            _zoomBy(0, delta, e, true);
        };

        /**
         * Centers the tracked content inside the viewport, but does not adjust the current zoom.
         * @method centerContent
         * @param {Object} params Method parameters.
         * @param {Object} [params.bounds] Bounds info. This is in an internal format and only used when this method is called by the widget itself. Otherwise it is calculated.
         * @param {Boolean} [params.doNotAnimate=false] If true, don't animate while centering.
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotFirePanEvent=false] If true, a pan event will not be fired.
         */
        this.centerContent = function (params) {
            params = params || {};
            var bi = params.bounds || getBoundsInfo();
            var ao = _apparentOffset(),
                midBoundsX = (bi.x * zoom) + (bi.w * zoom / 2),
                midBoundsY = (bi.y * zoom) + (bi.h * zoom / 2),
                l = (bi.vw / 2) - midBoundsX,
                t = (bi.vh / 2) - midBoundsY,
                cp = _pos(canvasElement);

            _pos(canvasElement,
                    params.horizontal !== false ? l - ao[0] : cp[0],
                    params.vertical !== false ? t - ao[1] : cp[1],
                null,
                params.doNotAnimate,
                function() {
                    if (!params.doNotFirePanEvent)
                        onPan(params.horizontal !== false ? l - cp[0] : 0, params.vertical !== false ? t - cp[1] : 0, zoom, zoom);

                    backgroundLayer && backgroundLayer.pan();
                    fixedLayer && fixedLayer.pan();

                    if (params.onComplete) params.onComplete();
                },
                params.onStep
            );
        };

        /**
         * Centers the tracked content inside the viewport horizontally, but does not adjust the current zoom.
         * @method centerContentHorizontally
         * @param {Object} params Method parameters.
         * @param {Object} [params.bounds] Bounds info. This is in an internal format and only used when this method is called by the widget itself. Otherwise it is calculated.
         * @param {Boolean} [params.doNotAnimate=false] If true, don't animate while centering.
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotFirePanEvent=false] If true, a pan event will not be fired.
         */
        this.centerContentHorizontally = function (params) {
            this.centerContent(JSP.extend({horizontal:true, vertical:false}, params));
        };

        /**
         * Centers the tracked content inside the viewport vertically, but does not adjust the current zoom.
         * @method centerContentVertically
         * @param {Object} params Method parameters.
         * @param {Object} [params.bounds] Bounds info. This is in an internal format and only used when this method is called by the widget itself. Otherwise it is calculated.
         * @param {Boolean} [params.doNotAnimate=false] If true, don't animate while centering.
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotFirePanEvent=false] If true, a pan event will not be fired.
         */
        this.centerContentVertically = function (params) {
            this.centerContent(JSP.extend({vertical:true, horizontal:false}, params));
        };

        /**
         * Centers the given element in the viewport, vertically and/or horizontally.
         * @method centerOn
         * @param {Element|String} element Element, or element id, to center.
         * @param {Object} [params] Optional extra parameters.
         * @param {Boolean} [params.horizontal=true] Whether or not to center horizontally
         * @param {Boolean} [params.vertical=true] Whether or not to center vertically
         * @param {Boolean} [params.doNotAnimate=false] If true, animation will not be switched on for the operation.
         * @param {Boolean} [params.onComplete] Optional on complete callback
         * @param {Boolean} [params.onStep] Optional on animation step callback.
         * @param {Number} [params.fillRatio=0.4]
         */
        this.centerOn = function (element, cparams) {
            cparams = cparams || {};
            var bi = JSP.extend({}, getBoundsInfo()),
                p = _pos(element),
                w = widthFn(element),
                h = heightFn(element),
                self = this;

            bi.x = p[0];
            bi.y = p[1];
            bi.w = w;
            bi.h = h;

            var onComplete = function() {
                _setTransformOriginToCanvasPoint(p[0] + (w/2), p[1] + (h/2));
                cparams.onComplete && cparams.onComplete();
            };

            this.centerContent({
                bounds: bi,
                doNotAnimate: cparams.doNotAnimate,
                onComplete: onComplete,
                onStep: cparams.onStep,
                vertical: cparams.vertical !== false,
                horizontal: cparams.horizontal !== false
            });
        };

        /**
         * Centers the given element in the viewport, horizontally only.
         * @method centerOnHorizontally
         * @param {Element|String} element Element, or element id, to center.
         */
        this.centerOnHorizontally = function (element) {
            this.centerOn(element, { vertical:false });
        };

        /**
         * Centers the given element in the viewport, vertically only.
         * @method centerOnHorizontally
         * @param {Element|String} element Element, or element id, to center.
         */
        this.centerOnVertically = function (element) {
            this.centerOn(element, { horizontal: false });
        };

        /**
         * Centers on the given element and then adjusts the zoom of the widget so that the short axis of the viewport
         * is [1 / fillRatio] larger than its corresponding axis on the centered node. `fillRatio` is basically
         * a measure of how much context you want to see around the node on which you centered.
         * @method centerOnAndZoom
         * @param {Element|String} element Element, or element id, to center.
         * @param {Number} [fillRatio=0.6] Proportional ratio of the corresponding node's edge to the viewport's short edge.
         */
        this.centerOnAndZoom = function (element, fillRatio) {
            fillRatio = fillRatio || 0.6;
            var dim = { w : widthFn(element), h : heightFn(element) },
                p = _pos(element),
                bi = getBoundsInfo(),
                shortAxis = bi.vw < bi.vh ? [bi.vw, "w"] : [bi.vh, "h"],
                shortAxisApparentLength = fillRatio * shortAxis[0],
                desiredZoom = shortAxisApparentLength / dim[shortAxis[1]];

            if (desiredZoom < zoomRange[0]) desiredZoom = zoomRange[0];
            if (desiredZoom > zoomRange[1]) desiredZoom = zoomRange[1];

            var curZoom = zoom, zoomDelta = desiredZoom - zoom;

            _setTransformOriginToCanvasPoint(p[0] + (dim.w/2), p[1] + (dim.h/2));

            this.centerOn(element, {
                onStep:function(step, steps) {
                    _zoom(curZoom + (step / steps * zoomDelta));
                },
                onComplete:function() {
                    _zoom(desiredZoom);
                }
            });
        };

        /**
         * Gets the canvas location that corresponds to the center of the viewport.  Note that this may describe
         * a point outside of the content bounds.
         * @method getViewportCenter
         * @return {Number[]} left,top location of the logical position on the canvas corresponding to the center of the viewport.
         */
        this.getViewportCenter = function () {
            var bi = JSP.extend({}, getBoundsInfo()),
                ao = _apparentOffset(),
                cp = _pos(canvasElement),
                p = [ bi.vw / 2, bi.vh / 2 ];

            return [
                    (p[0] - (cp[0] + ao[0])) / zoom,
                    (p[1] - (cp[1] + ao[1])) / zoom
            ];
        };

        /**
         * Sets the location of the canvas such that the given point appears at the center of the viewport.
         * @method setViewportCenter
         * @param {Number[]} xy left, top location of the point on the canvas to position in the center of the viewport.
         */
        this.setViewportCenter = function (xy) {
            var bi = JSP.extend({}, getBoundsInfo()),
                ao = _apparentOffset(),
                p = [ bi.vw / 2, bi.vh / 2 ];

            var _ = [
                ao[0] + (( zoom * xy[0] ) + p[0] ),
                ao[1] + (( zoom * xy[1] ) + p[1] )
            ];

            _pos(canvasElement, _[0], _[1]);
        };

        /**
         * Sets whether or not the widget clamps the movement of the canvas during pan/zoom
         * to ensure that the managed content never disappears from view.
         * @method setClamping
         * @param {Boolean} clamp Whether or not to clamp movement.
         */
        this.setClamping = function (c) {
            clamp = c;
        };

        /**
         * Sets the current zoom, clamping it to the allowed range.
         * @method setZoom
         * @param {Number} z Zoom value. If this is outside the allowed bounds it will be clamped.
         * @param {Boolean} [dontFireEvent=false] If true, a zoom event will not be fired.
         * @return {Number} Current zoom. This may or may not be the value you asked for - it might have been clamped to the current allowed zoom range.
         */
        this.setZoom = function (z, animate, dontFireEvent) {
            return _zoom(z, null, null, animate, dontFireEvent);
        };

        /**
         * Sets the current zoom range. By default, this method checks if the current zoom is within
         * the new range, and if it is not then `setZoom` is called, which will cause the zoom to be clamped
         * to an allowed value in the new range. You can disable this by passing `true` for `doNotClamp`.
         *
         * @method setZoomRange
         * @param {Number[]} zr New range, as an array consisting of [lower, upper] values. Lower must be less than upper.
         * @param {Boolean} [doNotClamp] If true, will not check the current zoom to ensure it falls within the new range.
         */
        this.setZoomRange = function (zr, doNotClamp) {
            if (zr != null && zr.length == 2 && zr[0] < zr[1] && zr[0] != null && zr[1] != null && zr[0] > 0 && zr[1] > 0) {
                zoomRange = zr;
                if (!doNotClamp) {
                    if (zoom < zoomRange[0] || zoom > zoomRange[1])
                        _zoom(zoom);
                }
            }
            return this;
        };

        /**
         * Gets the current zoom range.
         * @method getZoomRange
         * @return {Number[]} Array of [min, max] zoom values.
         */
        this.getZoomRange = function () {
            return zoomRange;
        };

        /**
         * Gets the current zoom.
         * @method getZoom
         * @return {Number} Current zoom value
         */
        this.getZoom = function () {
            return zoom;
        };

        /**
         * Gets the current [left,top] of the panned content.
         * @method getPan
         * @return {Number[]} [left,top], in pixels, of the panned content, where [0,0] is the origin of the viewport.
         */
        this.getPan = function () {
            return _pos(canvasElement);
        };

        /**
         * Pans the content by dx and dy.
         * @method pan
         * @param {Number} dx Amount to pan in X direction
         * @param {Number} dy Amount to pan in Y direction
         * @param {Boolean} [animate = false] Whether or not to animate the pan.
         */
        this.pan = function (dx, dy, animate) {
            _posDelta(canvasElement, dx, dy, null, animate, function (m) {
                onPan(m[0], m[1], zoom, zoom);
                backgroundLayer && backgroundLayer.pan();
                fixedLayer && fixedLayer.pan();
            });
        };

        /**
         * Sets the position of the panned content's origin.
         * @method setPan
         * @param {Number} left Position in pixels of the left edge of the panned content.
         * @param {Number} top Position in pixels of the top edge of the panned content.
         * @param {Boolean} [animate = false] Whether or not to animate the pan.
         * @param {Function} [onComplete] If `animate` is set to true, an optional callback for the end of the pan.
         * @param {Function} [onStep] If `animate` is set to true, an optional callback for each frame in the pan.
         */
        this.setPan = function (left, top, animate, onComplete, onStep) {
            return _pos(canvasElement, left, top, null, !animate, onComplete, onStep);
        };

        /**
         * Sets the current transform origin, in pixels. Used mainly to support save/restore state.
         * @method setTransformOrigin
         * @param {Number} left Position of the X coordinate of the transform origin.
         * @param {Number} top Position of the Y coordinate of the transform origin.
         */

        this.setTransformOrigin = function (left, top) {
            transformOrigin = [left, top];
            _writeTransformOrigin();
        };

        /**
         * Maps the given page location to a value relative to the viewport origin, allowing for
         * zoom and pan of the canvas. This takes into account the offset of the viewport in the page so that what
         * you get back is the mapped position relative to the target element's [left,top] corner. If
         * you wish, you can supply true for 'doNotAdjustForOffset', to suppress that behavior.
         * @method mapLocation
         * @param {Number} left X location
         * @param {Number} top Y location
         * @param {Boolean} [doNotAdjustForOffset=false] Whether or not to adjust for the offset of the viewport in the page.
         */
        this.mapLocation = function (left, top, doNotAdjustForOffset) {
            var ao = _apparentOffset(),
                cp = _pos(canvasElement),
                sl = viewportElement.scrollLeft,
                st = viewportElement.scrollTop,
                viewportOffset = doNotAdjustForOffset ? { left: 0, top: 0 } : params.offset(viewportElement);

            return {
                left: (left - (cp[0] + ao[0]) - viewportOffset.left + sl) / zoom,
                top: (top - (cp[1] + ao[1]) - viewportOffset.top + st) / zoom
            };
        };


        /**
         * Maps the page location of the given event to a value relative to the viewport origin, allowing for
         * zoom and pan of the canvas. This takes into account the offset of the viewport in the page so that what
         * you get back is the mapped position relative to the target element's [left,top] corner. If
         * you wish, you can supply true for 'doNotAdjustForOffset', to suppress that behavior.
         * @method mapEventLocation
         * @param {Event} event Browser event
         * @param {Boolean} [doNotAdjustForOffset=false] Whether or not to adjust for the offset of the viewport in the page.
         */
        this.mapEventLocation = function (event, doNotAdjustForOffset) {
            var pl = _pageLocation(event);
            return this.mapLocation(pl[0], pl[1], doNotAdjustForOffset)
        };

        /**
         * Sets whether or not the component should respond to mouse events.
         * @method setEnabled
         * @param {Boolean} state Whether or not to respond to mouse events.
         */
        this.setEnabled = function (state) {
            enabled = state;
        };

        /**
         * Takes some element that is in the DOM and moves it so that it appears at the given x,y over the canvas,
         * allowing for the current zoom and pan.  It is expected that the element is not one that is currently
         * managed by the widget - a common use case for this is some dialog, which you do not want to append to
         * the canvas since it would have the zoom effect applied.
         * @method showElementAt
         * @param {Selector|Element|String} el Selector, DOM element or element id representing the element to move.
         * @param {Number} x X location to move to.
         * @param {Number} y Y location to move to.
         */
        this.showElementAt = function (el, x, y) {
            var de = domElement(el),
                dep = de.parentNode,
                depo = params.offset(dep),
                vpo = params.offset(viewport),
                _ao = _apparentOffset(),
                _x = (depo.left - vpo.left) + _ao[0] + x,
                _y = (depo.top - vpo.top) + _ao[1] + y;

            params.offset(el, {left: _x, top: _y});
        };

        /**
         * Returns the apparent [left,top] of the canvas inside the viewport - the coordinates, in real pixel
         * values, of where the origin of the canvas appears to be. This apparent origin is not necessarily the
         * same as the [left,top] values of the canvas, because the transform origin and zoom values change
         * things.  This function can be used in conjunction with the content bounds by widgets such as the miniview, to calculate what is actually visible in the
         * viewport at some point in time.
         * @method getApparentCanvasLocation
         * @return [Integer[]] [left,top] of the canvas, relative to the viewport's 0,0.
         */
        this.getApparentCanvasLocation = function () {
            var ao = _apparentOffset(),
                cp = _pos(canvasElement);

            return [ (cp[0] + ao[0]), (cp[1] + ao[1])];
        };

        /**
         * Sets the apparent canvas location - see the notes for getApparentCanvasLocation.
         * @method setApparentCanvasLocation
         * @param {Number} left Value in pixels for left edge of canvas.
         * @param {Number} top Value in pixels for top edge of canvas.
         * @return {Number[]} [left,top] of the actual origin set, after clamping.
         */
        this.setApparentCanvasLocation = function (left, top) {
            var ao = _apparentOffset();
            var actual = _pos(canvasElement, left - ao[0], top - ao[1], null, true);
            backgroundLayer && backgroundLayer.pan();
            fixedLayer && fixedLayer.pan();
            return actual;
        };

        /**
         * Applies either the widget's current zoom to the given element, or some supplied zoom.
         * @method applyZoomToElement
         * @param {Element} el Element to set zoom on.
         * @param {Number} [zoomToSet] Optional zoom value; if omitted we use the widget's current zoom.
         */
        this.applyZoomToElement = function (el, zoomToSet) {
            zoomToSet = zoomToSet || zoom;
            _applyTransformProperty("transform", "scale(" + zoomToSet + ")", el);
        };

        /**
         * Sets the transform origin for some element. This is really just exposed as a helper, since
         * there seems little point in reinventing the wheel if you have this widget in your codebase and you
         * need to perform this operation.  The Miniview uses this, for instance.
         * @method setTransFormOriginForElement
         * @param {Element} el Element to set transform origin for.
         * @param {Number[]} xy Transform origin for element.
         */
        this.setTransformOriginForElement = function (el, xy) {
            _applyTransformProperty("transformOrigin", xy[0] + " " + xy[1], el);
        };

        /**
         * Gets the current transform origin, in an object of the form `[ left, top ]`. The coordinate space is pixels.
         * @method getTransformOrigin
         * @return {Number[]} [left,top] values for the transform origin.
         */
        this.getTransformOrigin = function () {
            return transformOrigin;
        };

        /**
         * Appends an element to the viewport so that it floats above the content that is being zoomed and panned.
         * The element will have `position:absolute` set on it. You can float any element you like, but note that the
         * responsibility for setting an appropriate z index is yours.
         * @param {Element} el Element to float.
         * @param {Number[]} pos Array of [x,y] positions.
         */
        this.floatElement = function(el, pos) {
            if (el == null) return;
            el.style.position = "absolute";
            el.style.left = pos[0] + "px";
            el.style.top = pos[1] + "px";
            viewportElement.appendChild(el);
        };

        var fixedElements = {};
        var _fixElements = function(elId) {
            var acl = self.getApparentCanvasLocation();
            for (var fe in fixedElements) {
                if (fixedElements.hasOwnProperty(fe)) {
                    if (elId != null && elId != fe) continue;
                    var ce = fixedElements[fe];
                    var _one = function (prop, idx) {
                        if (ce[prop]) {
                            if ((acl[idx] / zoom) + ce.pos[idx] < 0) {
                                ce.el.style[prop] = -(acl[idx] / zoom) + "px";
                            }
                            else {
                                ce.el.style[prop] = ce.pos[idx] + "px";
                            }
                        }
                    };
                    _one("left", 0);
                    _one("top", 1);
                }
            }
        };
        var fixedLayer = {
            pan:_fixElements
        };
        /**
         * Appends an element to the content such that it is zoomed with everything else, but constrains pan
         * in one or both axes so that the element remains fixed with respect to the viewport origin.
         * @method fixElement
         * @param {Element} el The DOM element to append.
         * @param {Object} constraints Flags to indicate optional constraint to each axis.
         * @param {Number[]} pos [left,top] location of the element's origin.
         */
        this.fixElement = function(el, constraints, pos) {
            if (el == null) return;
            var elId = params.id(el);
            fixedElements[elId] = {
                el:el,
                left:constraints.left,
                top:constraints.top,
                pos:pos
            };
            el.style.position = "absolute";
            el.style.left = pos[0] + "px";
            el.style.top = pos[1] + "px";
            canvasElement.appendChild(el);
            _fixElements(elId);
        };

        /**
         * Finds all nodes that intersect to any extent the rectangle defined by the given origin
         * and dimensions. This rectangle is taken to be in the coordinate space of the page, ie. a value
         * of [0,0] for the origin means the page's top/left corner. A future version could take an optional
         * third argument specifying the element whose origin to use.
         * @method findIntersectingNodes
         * @param {Number[]} origin [x,y] location for center of search. IMPORTANT: This is relative to the page origin.
         * @param {Number[]} dimensions Width and height of search area.
         * @param {Boolean} [enclosed=false] If true, returns only nodes that are enclosed by the given search area. Otherwise returns nodes that both intersect and are enclosed.
         * @param {Function} [filter] Optional filter function. This is passed the (id, node, boundingRect) of some element and should return true for elements that should be included in results.
         * @return {Object[]} A list of objects containing {id:id, el:element, r:bounding rect} that either intersect or are enclosed by the search area.
         */
        this.findIntersectingNodes = function (origin, dimensions, enclosed, filter) {
            var cl = this.getApparentCanvasLocation(),
                vo = params.offset(viewportElement),
                sl = viewportElement.scrollLeft,
                st = viewportElement.scrollTop,
                n = [],
                r = { x: origin[0], y: origin[1], w: dimensions[0], h: dimensions[1] },
                compFn = enclosed ? Biltong.encloses : Biltong.intersects;

            // cl gives us the apparent origin of the canvas relative to the viewport,
            // and vo is the origin's viewport, so acl will give us the adjusted origin:
            var acl = [ vo.left + cl[0] - sl, vo.top + cl[1] - st ];

            for (var i in _elementPositions) {
                if (!_suspendMap[i]) {
                    var p = _elementPositions[i],
                        r1 = { x: acl[0] + (p[0][0] * zoom), y: acl[1] + (p[0][1] * zoom), w: p[1] * zoom, h: p[2] * zoom };

                    if (compFn(r, r1) && ( filter == null || filter(i, _nodeMap[i], r1) )) {
                        n.push({ id: i, el: _nodeMap[i], r: r1 });
                    }
                }
            }

            return n;
        };

        /**
         * Finds all nodes whose centers are within a rectangle with `origin` as its center, and
         * a width and height of `radius / 2`.
         * @method findNearbyNodes
         * @param {Number[]} origin [x,y] location for center of search. IMPORTANT: This is relative to the page origin.
         * @param {Number} radius Radius of search.
         * @param {Boolean} [mustBeInViewport=false] If true, first check that the given origin is within the viewport.
         * @param {Function} [filter] Optional filter function. Should return true for elements that should be included in results.
         * @return {Object[]} A list of objects containing {id:id, el:element, r:bounding rect}, sorted in ascending order of distance of the center of the bounding rectangle from the given origin.
         */
        this.findNearbyNodes = function (origin, radius, mustBeInViewport, filter) {
            var nodes = [];
            if (!mustBeInViewport || this.isInViewport(origin[0], origin[1])) {
                nodes = this.findIntersectingNodes(
                    [ origin[0] - radius, origin[1] - radius ],
                    [ radius * 2, radius * 2 ],
                    false,
                    filter);

                // map the origin to one that is in the same coord space as the nodes.
                var mappedOrigin = this.mapLocation(origin[0], origin[1]);
                nodes.sort(function (n1, n2) {
                    var c1 = [ n1.x + (n1.w / 2), n1.y + (n1.h / 2) ],
                        c2 = [ n2.x + (n2.w / 2), n2.y + (n2.h / 2) ],
                        d1 = Biltong.lineLength(mappedOrigin, c1),
                        d2 = Biltong.lineLength(mappedOrigin, c2);

                    return d1 < d2 ? -1 : d1 > d2 ? 1 : 0;
                });
            }

            return nodes;
        };

        /**
         * Returns whether or not the given point (relative to page origin) is within the viewport for the widget.
         * @method isInViewport
         * @param {Number} x X location of point to test
         * @param {Number} y Y location of point to test
         * @return {Boolean} True if the point is within the viewport, false if not.
         */
        this.isInViewport = function (x, y) {
            var o = params.offset(viewportElement),
                w = params.width(viewportElement),
                h = params.height(viewportElement);

            return (o.left <= x && x <= o.left + w) && (o.top <= y && y <= o.top + h);
        };

        /**
         * Returns the current map of element ids -> positions.
         * @method getElementPositions
         * @return {Object} Map of { id->[x,y]} positions.
         */
        this.getElementPositions = function () {
            return _elementPositions;
        };

        /**
         * Sets the filter used to determine whether or not a given event should begin a pan.
         * @method setFilter
         * @param {Function} f A function that will be given the current mouse event. You must return true from the function if you wish for a pan to begin.
         */
        this.setFilter = function (f) {
            filter = f || function (_) {
                return false;
            };
        };

        /**
         * Sets the filter used to determine whether or not a given wheel event should be responded to.
         * @method setWheelFilter
         * @param {Function} f A function that will be given the current mouse event. You must return false from the function if you wish for the wheel event to be responded to.
         */
        this.setWheelFilter = function (f) {
            wheelFilter = f || function (_) {
                return true;
            };
        };

        /**
         * Sets the background for the canvas element.
         * @method setBackground
         * @param {Object} params Method parameters
         * @param {Image} [params.img] Image to use. Optional; you can also supply an image url
         * @param {String} [params.url] Image URL.
         * @param {String} [params.type="simple"] "tiled" or "simple": whether to use a single background image or to tile it.
         * @param {String} [params.tiling="logarithmic"] Default is "logarithmic": each layer is assumed to have a maximum of
         * (2^level+1) tiles in each axis (for instance at level 0, 2 tiles in each axis.  Alternatively you can
         * set this to be "absolute", which means that at the maximum zoom level the number of tiles in each axis
         * is computed as the size of the image in that axis divided by the tile size in that axis (rounded up of course).
         * Then at subsequent levels below, the
         * @param {Function} [params.onBackgroundReady] Optional function to call when the image has loaded.
         */
        this.setBackground = function (params) {
            var type = params.type || "simple",
                clazz = {
                    "simple": SimpleBackground,
                    "tiled": params.tiling == "absolute" ? AbsoluteTiledBackground : LogarithmicTiledBackground
                };

            backgroundLayer = new clazz[type]({
                canvas: canvasElement,
                viewport: viewportElement,
                getWidth: widthFn,
                getHeight: heightFn,
                url: params.url,
                zoomWidget: self,
                onBackgroundReady: params.onBackgroundReady,
                options: params,
                img: params.img,
                resolver: params.resolver
            });
        };
        if (params.background) {
            this.setBackground(params.background);
        }

        /**
         * Gets the current background layer.
         * @return {Object} current background layer. you can use the `getWidth` and `getHeight` methods on this object to find out the background size.
         */
        this.getBackground = function () {
            return backgroundLayer;
        };

    };

    var SimpleBackground = function (params) {
        var canvas = params.canvas;
        var onBackgroundReady = params.onBackgroundReady || function () {
        };
        var backgroundImage = new Image();
        backgroundImage.onload = function () {
            canvas.style.backgroundImage = "url('" + backgroundImage.src + "')";
            canvas.style.backgroundRepeat = "no-repeat";
            canvas.style.width = backgroundImage.width + "px";
            canvas.style.height = backgroundImage.height + "px";
            onBackgroundReady(this);
        };
        backgroundImage.src = params.img ? params.img.src : params.url;

        this.owns = function (el) {
            return el == canvas;
        };

        this.getWidth = function () {
            return backgroundImage.width || 0;
        };
        this.getHeight = function () {
            return backgroundImage.height || 0;
        };

        this.setZoom = this.pan = function (_) {
        };
    };

    var TiledBackground = function (params) {
        var self = this;
        var canvas = params.canvas;
        var viewport = params.viewport;
        if (params.options.maxZoom == null) throw new TypeError("Parameter `maxZoom` not set; cannot initialize TiledBackground");
        if (!params.options.tileSize) throw new TypeError("Parameter `tileSize not set; cannot initialize TiledBackground. It should be an array of [x,y] values.");
        if (!params.options.width || !params.options.height) throw new TypeError("Parameters `width` and `height` must be set");
        // otherwise we create a Layer for each level. The assumption is that zoom levels start at 0.
        var Layer = function (zoom) {
            var container = document.createElement("div");
            container.style.position = "relative";
            container.style.height = "100%";
            container.style.width = "100%";
            container.style.display = "none";
            params.canvas.appendChild(container);
            this.zoom = zoom;

            var specs = self.getTileSpecs(zoom),
                _images = [],
                _url = function (z, x, y) {
                    return params.url.replace("{z}", z)
                        .replace("{x}", x)
                        .replace("{y}", y);
                },
                _resolver = function (z, x, y) {
                    if (params.resolver == null) {
                        return _url(z, x, y)
                    }
                    else {
                        return params.resolver(z, x, y);
                    }
                };

            this.apparentZoom = Math.min(specs[2], specs[3]);
            this.setActive = function (a) {
                container.style.display = a ? "block" : "none";
            };
            this.xTiles = specs[0];
            this.yTiles = specs[1];

            // initialize backing image store.
            for (var i = 0; i < this.xTiles; i++) {
                _images[i] = _images[i] || [];
                for (var j = 0; j < this.yTiles; j++) {
                    var img = document.createElement("img");
                    img._tiledBg = true;
                    img.className = "jtk-surface-tile";
                    img.ondragstart = function () {
                        return false;
                    };
                    container.appendChild(img);
                    img.style.position = "absolute";
                    img.style.opacity = 0;
                    _images[i][j] = [ img, new Image(), false ];
                }
            }

            var iwh = Math.pow(2, params.options.maxZoom - zoom) * params.options.tileSize[0];
            var iwhh = Math.pow(2, params.options.maxZoom - zoom) * params.options.tileSize[1];
            this.scaledImageSize = iwh;
            this.scaledImageSizeH = iwhh;

            var _load = function (imgEl, img, x, y) {
                imgEl.style.left = (x * iwh) + "px";
                imgEl.style.top = (y * iwhh) + "px";
                imgEl.style.width = iwh + "px";
                imgEl.style.height = iwhh + "px";
                img.onload = function () {
                    imgEl.setAttribute("src", img.src);
                    imgEl.style.opacity = 1;
                };
                img.src = _resolver(zoom, x, y);
            };

            this.ensureLoaded = function (xo, yo, xf, yf) {
                for (var i = xo; i <= xf; i++) {
                    for (var j = yo; j <= yf; j++) {
                        if (_images[i] != null && _images[i][j] != null) {
                            if (!_images[i][j][2]) {
                                _load(_images[i][j][0], _images[i][j][1], i, j);
                                _images[i][j][2] = true;
                            }
                        }
                    }
                }
            };
        }.bind(this);

        var layers = [], currentLayer = null;
        for (var i = 0; i <= params.options.maxZoom; i++) {
            layers.push(new Layer(i));
        }

        canvas.style.width = params.options.width + "px";
        canvas.style.height = params.options.height + "px";

        var widgetZoom;

        // maps the current widget zoom to a zoom layer from our set. Returns the layer index.
        var _mapZoomToLayer = function () {
            if (widgetZoom <= layers[0].apparentZoom) return 0;
            else if (widgetZoom >= layers[layers.length - 1].apparentZoom) return layers.length - 1;
            else {
                for (var i = layers.length - 1; i > 0; i--) {
                    if (layers[i].apparentZoom >= widgetZoom && widgetZoom >= layers[i - 1].apparentZoom) {
                        return i;
                    }
                }
            }
        };

        //
        // calculates the current scale for the given layer, relative to the widget's zoom.
        // then performs a relayout of the images, resizing and repositioning as necessary
        //
        var _calculateScale = function (layerIndex) {
            var l = layers[layerIndex];
            if (currentLayer != null && currentLayer != l) currentLayer.setActive(false);
            l.setActive(true);
            currentLayer = l;
        };

        //
        // for currentLayer, ensures that all of the required tiles are loaded. This means calculating the overlap
        // between the viewport and the tile layer, taking into account the current origin of the canvas and the
        // zoom level (as well as, of course, the size of the viewport).
        //
        var _ensureVisibleTiles = function () {
            var loc = params.zoomWidget.getApparentCanvasLocation(),
                vw = params.getWidth(viewport),
                vh = params.getHeight(viewport),
                tileW = currentLayer.scaledImageSize * widgetZoom,
                tileH = currentLayer.scaledImageSizeH * widgetZoom,
                xo = loc[0] < 0 ? Math.floor(-loc[0] / tileW) : loc[0] < vw ? 0 : null,
                yo = loc[1] < 0 ? Math.floor(-loc[1] / tileH) : loc[1] < vh ? 0 : null,
                xf = Math.min(currentLayer.xTiles, Math.floor((vw - loc[0]) / tileW)),
                yf = Math.min(currentLayer.yTiles, Math.floor((vh - loc[1]) / tileH));

            // if either axis outside of the viewport, exit.
            if (xo == null || yo == null) return;

            currentLayer.ensureLoaded(xo, yo, xf, yf);
        };

        // for testing.
        this.getCurrentLayer = function () {
            return currentLayer;
        };

        this.getWidth = function () {
            return params.options.width;
        };
        this.getHeight = function () {
            return params.options.height;
        };

        var panDebounceTimeout = params.options.panDebounceTimeout || 50,
            zoomDebounceTimeout = params.options.zoomDebounceTimeout || 120,
            debounce = function (fn, timeout) {
                timeout = timeout || 150;
                var _t = null;
                return function () {
                    window.clearTimeout(_t);
                    _t = window.setTimeout(fn, timeout);
                };
            },
            _doUpdateZoom = function () {
                _calculateScale(_mapZoomToLayer());
                _ensureVisibleTiles();
            },
            _debounceUpdateZoom = debounce(_doUpdateZoom, zoomDebounceTimeout),
            _doEnsureVisibleTiles = debounce(_ensureVisibleTiles, panDebounceTimeout);

        this.setZoom = function (z, doNotDebounce) {
            widgetZoom = z;
            doNotDebounce ? _doUpdateZoom() : _debounceUpdateZoom();
        };

        this.pan = _doEnsureVisibleTiles;

        this.owns = function (el) {
            return el == canvas || el._tiledBg == true;
        };

        this.setZoom(params.zoomWidget.getZoom(), true);

        // finally, execute the onBackgroundReady callback immediately, if it was provided, since there is
        // no specific time at which you can say the tiled layer is completely done.
        if (params.onBackgroundReady != null)
            setTimeout(params.onBackgroundReady, 0);
    };

    var LogarithmicTiledBackground = function (params) {

        var width = params.options.width,
            height = params.options.height,
            tileSize = params.options.tileSize;

        this.getTileSpecs = function (zoom) {
            var arx = width > height ? 1 : width / height,
                ary = height > width ? 1 : height / width;

            var _w = Math.pow(2, zoom + 1) * tileSize[0] * arx,
                _h = Math.pow(2, zoom + 1) * tileSize[1] * ary,
                _xTiles = Math.ceil(_w / tileSize[0]),
                _yTiles = Math.ceil(_h / tileSize[1]);

            return [ _xTiles, _yTiles, _w / width, _h / height ];
        };

        TiledBackground.apply(this, arguments);
    };

    var AbsoluteTiledBackground = function (params) {

        var maxZoom = params.options.maxZoom,
            width = params.options.width,
            height = params.options.height,
            tileSize = params.options.tileSize;

        this.getTileSpecs = function (zoom) {
            var divisor = Math.pow(2, maxZoom - zoom); // how much to divide the dimensions by when calculating image dimensions
            var xTiles = Math.ceil((width / divisor) / tileSize[0]),  // tiles in x axis
                yTiles = Math.ceil((height / divisor) / tileSize[1]);  // tiles in y axis

            return [
                xTiles,
                yTiles,
                    (xTiles * tileSize[0]) / width,
                    (yTiles * tileSize[1]) / height
            ];
        };

        TiledBackground.apply(this, arguments);
    };


}).call(typeof window !== 'undefined' ? window : this);

/*
 * Surface Widget
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */
;
(function () {

    "use strict";
    var root = this,
        JTK = root.jsPlumbToolkit,
        exports = JTK.Renderers,
        JP = root.jsPlumb,
        JUTIL = root.jsPlumbUtil,
        $j = JP.getSelector,
        _cl = JTK.Classes,
        _c = JTK.Constants,
        _e = JTK.Events;

    /**
     * A widget that provides pan/zoom functionality, as well as the ability to load/store state in the browser.
     * You do not construct an instance of this class manually: you obtain an instance of Surface via a call to the `render`
     * method on a `jsPlumbToolkitInstance`. But the supported parameters to that `render` method are whatever is supported by
     * the Surface constructor, as documented here.
     * @class Surface
     * @extends AbstractRenderer
     * @constructor
     * @param {Object} params Constructor parameters
     * @param {Element|Selector} params.container Element to convert into a Surface.
     * @param {Boolean} [params.elementsDraggable=true] Whether or not elements in the Surface should be draggable.
     * @param {Object} [params.dragOptions] Options for draggable nodes.
     * @param {Object} [params.events] Optional event bindings. See documentation.
     * @param {Object} [params.miniview] Optional miniview configuration.
     * @param {Element|String|Selector} [params.miniview.container] Container for the miniview.  An Element, an element id, or a selector.
     * @param {Boolean} [params.miniview.initiallyVisible=true] Whether or not the miniview should be invisible until some data is loaded.
     * @param {String} [params.mode="Pan"] Mode to initialize the Surface in.
     * @param {Number} [params.panDistance=50] How far a pan nudge should move the UI (in pixels).
     * @param {Number} [params.zoom=1] Initial zoom for the widget.
     * @param {Number[]} [params.zoomRange=[0.05, 3] ] Zoom range for the widget.
     * @param {Boolean} [params.enablePan=true] Whether or not panning (via mouse drag) is enabled.
     * @param {Boolean} [params.enableWheelZoom=true] Whether or not zooming with the mouse wheel is enabled.
     * @param {Boolean} [params.enableAnimation=true] Enable animations for panning. Defaults to true.
     * @param {String} [params.wheelFilter] Optional CSS selector representing elements that should not respond to wheel zoom.
     * @param {String|Function} [params.panFilter] Optional; either a CSS selector representing elements that should allow a pan event to begin, or a function that will be
     *                          called with the event target. Returning true from this function means the widget should respond to the event.
     * @param {Number} [params.wheelSensitivity=10] How many pixels each click of the mouse wheel represents when zooming. Note that this value, while expressed in pixels, is mapped in a variety of ways depending on the browser.
     * @param {Boolean} [params.wheelZoomMetaKey=false] If true, the "meta" key (CMD on Mac, Ctrl on windows/linux) must
     * be pressed in order for wheel zoom to operate. This can be useful if your UI fills the screen in one or more axes and
     * your users would not be able to scroll past the Surface widget.
     * @param {Boolean} [params.enablePanButtons=true] Whether or not to show the pan nudge buttons on the borders of the widgets.
     * @param {Number[]} [params.padding] Optional values for padding in the x/y axes to leave around the content. This is only of any use if you have disabled panning via mouse drag,
     * since in that case the user sees only scroll bars and has no way of navigating beyond the content. Some padding makes the UI nicer to use. Default is [0,0].
     * @param {String} [params.lassoFilter] Optional selector for elements on which a mousedown should not cause the lasso to activate.
     * @param {Boolean} [params.lassoInvert=false] If true, the lasso operates by masking the unselected parts of the display.
     * @param {Function} [params.lassoSelectionFilter] Optional function that can be used to filter the set of nodes a lasso drag is selecting. The function is given each candidate Node in turn; returning false indicates the Node should not be selected.
     * @param {Boolean} [params.consumeRightClick=true] Useful for development: set this to false if you don't want the widget to consume context menu clicks.
     * @param {String} [params.stateHandle] If supplied, this will be used as the default handle for state save/restore operations.
     * @param {Boolean} [params.clamp=true] Whether to clamp when panning such that there is always content visible.
     * @param {Boolean} [params.clampZoom=true] Whether to clamp when zooming such that there is always content visible.
     * @param {Boolean} [params.clampToBackground=false] If a background is set, whether to clamp movement such that some part of the background is always visible.
     * @param {Boolean} [params.clampToBackgroundExtents=false] If a background is set, whether to clamp movement such that the background fills as much of the viewport as it can.
     * @param {Object} [params.background] Optional background image parameters
     * @param {String} [params.background.url] URL for the background. Required for both single images and tiled backgrounds.
     * @param {String} [params.background.type="simple"] "simple" or "tiled" - the type of background.
     * @param {Number[]} [params.background.tileSize] For tiled backgrounds, provides the width and height of tiles. Every tile is assumed to have these dimensions, even if the tile has whitespace in it.
     * @param {Number} [params.background.width] Required for tiled backgrounds. Indicates the width of the full image.
     * @param {Number} [params.background.height] Required for tiled backgrounds. Indicates the height of the full image.
     * @param {Number} [params.background.maxZoom] Required for tiled backgrounds. Indicates the maximum zoom level. Zoom starts at 0 - fully zoomed out - and increases in integer values from there. Eash successive zoom level is twice the zoom of the previous level, meaning two times as many tiles in each direction.
     * @param {Object} [params.jsPlumb] Optional set of jsPlumb Defaults to use for this renderer. The format and allowed properties is that of
     * the Defaults object in jsPlumb. You can also set display properties in the view.
     * @param {Boolean} [params.autoExitSelectMode=true] When true (which is the default), the Surface will automatically jump back into Pan mode after some nodes have been selected.
     * @param {Boolean} [params.zoomToFit=false] If true, content will be zoomed to fit the viewport when a dataLoadEnd event is received.
     * @param {Boolean} [params.zoomToFitIfNecessary=false] If true, content will be zoomed to fit the viewport, if necessary (meaning if it fits inside the viewport already it wont be zoomed, which is different from how `zoomToFit` works) when a dataLoadEnd event is received. If this and `zoomToFit` are both set, this takes precedence.
     * @param {Boolean} [params.storePositionsInModel=true] By default, the left/top positions of nodes that have been dragged will be written into the data for each node after drag stops. You can set this to false to disable that behaviour.
     * @param {String} [params.modelLeftAttribute="left"] Optional; specifies the name of the attribute by which to store the x position of a dragged node of `storePositionsInModel` is true.
     * @param {String} [params.modelTopAttribute="top"] Optional; specifies the name of the attribute by which to store the y position of a dragged node of `storePositionsInModel` is true.
     * @param {Function} [params.assignPosse] optional function that, given each node, can return the id of the posse to which the node belongs. a Posse is a group of nodes that should all be dragged together.
     * @param {Boolean} [params.relayoutOnGroupUpdate=false] If true, any change to a Group's nodes will cause a relayout.
     */
    exports.Surface = function (params) {
        var self = this;
        /**
         * Constant for the Select mode.
         * @property SELECT
         * @type {String}
         */
        exports.Surface.SELECT = _c.select;
        /**
         * Constant for the Pan mode.
         * @property PAN
         * @type {String}
         */
        exports.Surface.PAN = _c.pan;
        /**
         * Constant for the Disabled mode.
         * @property DISABLED
         * @type {String}
         */
        exports.Surface.DISABLED = _c.disabled;

        var _super = exports.AbstractRenderer.apply(this, arguments);
        exports.DOMElementAdapter.apply(this, arguments);
        this.getObjectInfo = _super.getObjectInfo;

        params = params || {};
        var containerElement = JP.getElement(params.container),
            canvasElement = exports.createElement({ position: _c.relative, width: _c.nominalSize, height: _c.nominalSize, left: 0, top: 0, clazz: _cl.SURFACE_CANVAS }, containerElement),
            elementsDraggable = !(params.elementsDraggable === false),
            elementsDroppable = params.elementsDroppable === true,
            dragOptions = params.dragOptions || {},
            dropOptions = params.dropOptions || {},
            stateHandle = params.stateHandle,
            _storePositionsInModel = params.storePositionsInModel !== false,
            _modelLeftAttribute = params.modelLeftAttribute,
            _modelTopAttribute = params.modelTopAttribute,
            panzoom = new ZoomWidget({
                viewport: containerElement,
                canvas: canvasElement,
                domElement: _super.jsPlumb.getElement,
                addClass: _super.jsPlumb.addClass,
                removeClass: _super.jsPlumb.removeClass,
                offset: this.getOffset,
                consumeRightClick: params.consumeRightClick,
                bind: function () {
                    _super.jsPlumb.on.apply(_super.jsPlumb, arguments);
                },
                unbind: function () {
                    _super.jsPlumb.off.apply(_super.jsPlumb, arguments);
                },
                width: function (el) {
                    return _super.jsPlumb.getWidth(_super.jsPlumb.getElement(el))
                },
                height: function (el) {
                    return _super.jsPlumb.getHeight(_super.jsPlumb.getElement(el))
                },
                id: _super.jsPlumb.getId,
                animate: function() { _super.jsPlumb.animate.apply(_super.jsPlumb, arguments) },
                dragEvents: {
                    "stop": JP.dragEvents[_c.stop],
                    "start": JP.dragEvents[_c.start],       // map drag concepts to event names.
                    "drag": JP.dragEvents[_c.drag]
                },
                background:params.background,
                padding: params.padding,
                panDistance: params.panDistance,
                enablePan: params.enablePan,
                enableWheelZoom: params.enableWheelZoom,
                wheelSensitivity: params.wheelSensitivity,
                wheelZoomMetaKey:params.wheelZoomMetaKey,
                enablePanButtons: params.enablePanButtons,
                enableAnimation:params.enableAnimation,
                clamp: params.clamp,
                clampZoom: params.clampZoom,
                clampToBackground: params.clampToBackground,
                clampToBackgroundExtents: params.clampToBackgroundExtents,
                zoom:params.zoom,
                zoomRange:params.zoomRange,
                extend: _super.jsPlumb.extend,          // provide an 'extend' function to use
                events: {
                    pan: function (x, y, z, oldZoom, e) {
                        self.fire(_e.pan, {
                            x: x,
                            y: y,
                            zoom: z,
                            oldZoom: oldZoom,
                            event: e
                        });
                    },
                    zoom: function (x, y, z, oldZoom, e) {
                        _super.jsPlumb.setZoom(z);
                        self.fire(_e.zoom, {
                            x: x,
                            y: y,
                            zoom: z,
                            oldZoom: oldZoom,
                            event: e
                        });
                    },
                    mousedown: function () {
                        JP.addClass(containerElement, _cl.SURFACE_PANNING);
                        JP.addClass(document.body, _cl.SELECT_DEFEAT);
                    },
                    mouseup: function () {
                        JP.removeClass(containerElement, _cl.SURFACE_PANNING);
                        JP.removeClass(document.body, _cl.SELECT_DEFEAT);
                    }
                }
            }),
            lassoSelections = [],
            lassoSelectionFilter = params.lassoSelectionFilter,
            autoExitSelectMode = params.autoExitSelectMode !== false,
            lasso = new JTK.Widgets.Lasso({
                on: function () {
                    _super.jsPlumb.on.apply(_super.jsPlumb, arguments);
                },
                off: function () {
                    _super.jsPlumb.off.apply(_super.jsPlumb, arguments);
                },
                invert:params.lassoInvert,
                pageLocation: panzoom.pageLocation,
                canvas: containerElement,
                onStart: function () {
                    self.setHoverSuspended(true);
                    lassoSelections.length = 0;
                },
                onSelect: function (origin, size, directions, shiftDown) {
                    var n = [], nodes = panzoom.findIntersectingNodes(origin, size, !directions[0]);
                    _super.jsPlumb.clearDragSelection && _super.jsPlumb.clearDragSelection();
                    _super.toolkit.clearSelection();
                    if (shiftDown && lassoSelections.length > 0) {
                        // clear last lasso selections if shift down.
                        _super.toolkit.removeFromSelection(lassoSelections);
                    }
                    function _obj(o) { return o.el.jtk.node || o.el.jtk.group; }

                    for (var i = 0; i < nodes.length; i++) {
                        if (lassoSelectionFilter == null || lassoSelectionFilter(_obj(nodes[i])) !== false) {
                            n.push(_obj(nodes[i]));
                            _super.jsPlumb.addToDragSelection && _super.jsPlumb.addToDragSelection(nodes[i].el);
                        }
                    }
                    lassoSelections = n;
                    _super.toolkit.addToSelection(n, shiftDown);
                },
                onEnd: function () {
                    self.setHoverSuspended(false);
                    if (autoExitSelectMode) {
                        self.setMode(_c.pan);
                    }
                    self.fire("lasso:end");
                },
                filter: params.lassoFilter
            }),
            modes = {
                "pan": function () {
                    lasso.setEnabled(false);
                    panzoom.setEnabled(true);
                },
                "select": function () {
                    _super.jsPlumb.clearDragSelection && _super.jsPlumb.clearDragSelection();
                    lasso.setEnabled(true);
                    panzoom.setEnabled(false);
                },
                "disabled": function () {
                    _super.jsPlumb.clearDragSelection && _super.jsPlumb.clearDragSelection();
                    lasso.setEnabled(true);
                    panzoom.setEnabled(false);
                }
            },
            _mode = params.mode || _c.pan,
            miniview;

        // bind to relayout and tell the panzoom
        self.bind(_e.relayout, function (boundsInfo) {
            panzoom.relayout(boundsInfo, true);
        });

        // bind to noderemoved and tell the panzoom
        self.bind(_e.nodeRemoved, function (p) {
            panzoom.remove(p.el);
        });

        // on graph clear, reset panzoom
        _super.toolkit.bind(_e.graphCleared, function () {
            panzoom.reset();
        });

        _super.toolkit.bind(_e.dataLoadStart, function () {
            panzoom.setSuspendRendering(true);
        });

        _super.toolkit.bind(_e.dataLoadEnd, function () {
            panzoom.setSuspendRendering(false);
            miniview && miniview.setVisible(true);
            if (params.zoomToFit)
                self.zoomToFit();
        });

        _super.toolkit.bind(_e.groupMemberAdded, function(info) {
            var nodeEl = _super.nodeMap()[info.node.id];
            if (nodeEl) {
                var uiGroup = self.getJsPlumb().getGroup(info.group.id),
                    groupSize = self.getSize(uiGroup.getDragArea()),
                    nodeSize = self.getSize(nodeEl);

                panzoom.suspend(nodeEl);

                self.fire(_e.groupMemberAdded, info);
                _super.jsPlumb.addToGroup(info.group.id, nodeEl, true);

                // place node in the middle of the group if data not provided for location. if it was added by the user dropping it with their mouse,
                // that code will subsequently change this position. otherwise this gives us a sane default (in the
                // current absence of a magnetize inside group function).
                var left = info.node.data.left == null ? (groupSize[0] - nodeSize[0]) / 2 : info.node.data.left,
                    top = info.node.data.top == null ? (groupSize[1] - nodeSize[1]) / 2 : info.node.data.top;

                self.setPosition(info.node.id, left, top);
            }
        });

        _super.toolkit.bind(_e.groupMemberRemoved, function(info) {
            var nodeEl = _super.nodeMap()[info.node.id];
            if (nodeEl) {

                panzoom.restore(nodeEl);

                self.fire(_e.groupMemberRemoved, info);
                _super.jsPlumb.removeFromGroup(info.group.id, nodeEl, true);
                // notify the layout of the new position.
                var newOffset = _super.jsPlumb.getOffset(nodeEl);
                self.getLayout().setPosition(info.node.id, newOffset.left, newOffset.top);
            }
        });

        // set our canvas as the root element for everything the associated jsPlumb instance adds to the UI.
        _super.jsPlumb.setContainer(canvasElement);

        // set the jtk-surface class on the container
        JP.addClass(containerElement, _cl.SURFACE);

        // optionally set the jtk-surface-nopan class
        if (params.enablePan === false)
            JP.addClass(containerElement, _cl.SURFACE_NO_PAN);

        // support for canvasClick and canvasDblClick listener
        var _canvasBind = function (evt, alias) {
            var cc = function (e) {
                var t = e.srcElement || e.target;
                if (t == containerElement || t == canvasElement)
                    self.fire(alias, e);
            };
            _super.jsPlumb.on(canvasElement, evt, cc);
            _super.jsPlumb.on(containerElement, evt, cc);
        };
        _canvasBind(_e.tap, _e.canvasClick);
        _canvasBind(_e.dblclick, _e.canvasDblClick);
        var contentBounds = null; // current bounds as tracked by the panzoom

// -------------------------------- drag handling -----------------------------------------------------------

        //
        // make an element draggable. abstract method for superclass.
        //
        _super.makeDraggable = function (el, nodeDefDragOptions) {
            // init as draggable
            if (elementsDraggable) {
                var domEl = JP.getElement(el), id = _super.jsPlumb.getId(domEl);
                var _dragOptions = _super.jsPlumb.extend({}, dragOptions),
                    stopEvent = JP.dragEvents[_c.stop],
                    startEvent = JP.dragEvents[_c.start],
                    _getDragInfo = function (args) {
                        var dragObject = JP.getDragObject(args),
                            dragDOMElement = JP.getElement(dragObject);

                        return {
                            node: dragDOMElement.jtk.node,
                            el: dragObject
                        };
                    };

                // if the node definition provided drag options, override the common ones now,
                // but before we wrap any callbacks.
                if (nodeDefDragOptions != null)
                    _super.jsPlumb.extend(_dragOptions, nodeDefDragOptions);

                _dragOptions[startEvent] = JUTIL.wrap(_dragOptions[startEvent], function () {
                    contentBounds = panzoom.getBoundsInfo();
                    var dragInfo = _getDragInfo(arguments);
                    dragInfo.elementId = id;
                    dragInfo.pos = JP.getAbsolutePosition(domEl);
                    dragInfo.domEl = domEl;
                    JP.addClass(containerElement, _cl.SURFACE_ELEMENT_DRAGGING);
                    self.fire(_e.nodeMoveStart, dragInfo);
                });

                _dragOptions[stopEvent] = JUTIL.wrap(_dragOptions[stopEvent], function (params) {

                    var _one = function(info) {

                        JP.removeClass(containerElement, _cl.SURFACE_ELEMENT_DRAGGING);
                        var dragInfo = {
                            el:info[0],
                            node:info[0].jtk.node || info[0].jtk.group,
                            pos:[ info[1].left, info[1].top ],
                            e:params.e,
                            eventPosition:params.pos
                        };


                        //
                        // we do not support magnetizing nodes dragged in a group yet, as we dont have a means to constrain their movement inside the group.
                        if (_dragOptions.magnetize && !dragInfo.node.group) {
                            dragInfo.pos = self.getLayout().setMagnetizedPosition(dragInfo.node.id, dragInfo.pos[0], dragInfo.pos[1], true);
                        } else {
                            self.getLayout().setPosition(dragInfo.node.id, dragInfo.pos[0], dragInfo.pos[1], true);
                        }

                        panzoom.positionChanged(info[0]);

                        if (_storePositionsInModel !== false) {
                            self.storePositionInModel({
                                id:dragInfo.node.id,
                                leftAttribute:_modelLeftAttribute,
                                topAttribute:_modelTopAttribute
                            });
                            _super.toolkit.fire(_e.nodeUpdated, { node:dragInfo.node }, null);
                        }
                        self.fire(_e.nodeMoveEnd, dragInfo);
                    };

                    for (var i = 0; i < params.selection.length; i++) {
                        _one(params.selection[i]);
                    }

                });

                _dragOptions.canDrag = function () {
                    return !lasso.isActive();
                };

                _dragOptions.force = true;

                _super.jsPlumb.draggable(domEl, _dragOptions, false, _super.jsPlumb);
            }
        };

        _super.makeDroppable = function (el, nodeDefDropOptions) {
            // init as droppable
            if (elementsDroppable) {
                var domEl = JP.getElement(el);
                var _dropOptions = _super.jsPlumb.extend({}, dropOptions);

                if (nodeDefDropOptions != null)
                    _super.jsPlumb.extend(_dropOptions, nodeDefDropOptions);

                _dropOptions[_c.drop] = JUTIL.wrap(_dropOptions[_c.drop], function (params) {
                    var dropInfo = {
                        source:params.drag.el.jtk.node,
                        sourceElement:params.drag.el,
                        target:params.drop.el.jtk.node,
                        targetElement:params.drop.el,
                        e:params.e
                    };
                    self.fire(_e.nodeDropped, dropInfo);
                });

                _super.jsPlumb.droppable(domEl, _dropOptions);
            }
        };

        // for the case that a set of nodes were imported from an existing instance of jsPlumb. we have to tell
        // the pan/zoom widget about all of these nodes.
        // this was called by the superclass, during its initialize method. it does Surface specific stuff, like
        // switching the jsplumb instance's container to our canvas, and ensuring that each node is registered
        // with the pan/zoom widget.
        _super.doImport = function (nodeMap) {
            // tell the jsplumb instance to change its container
            params.jsPlumbInstance.setContainer(canvasElement);
            var managedElements = params.jsPlumbInstance.getManagedElements();
            for (var id in managedElements) {
                var el = managedElements[id].el;
                _importNode(el, id);
            }
        };

        var _importNode = this.importNode = function(el, id) {
            var offs = params.jsPlumbInstance.getOffset(el);
            var elId = params.jsPlumbInstance.getId(el);
            // ensure the left/top is set on the element, by using the standard getOffset function
            // and writing the values to the el.
            el.style.left = offs.left + _c.px;
            el.style.top = offs.top + _c.px;
            JP.addClass(el, _cl.NODE);
            panzoom.add(el, elId, [offs.left, offs.top], false);
            this.getLayout().setPosition(id, offs.left, offs.top); // set position in layout.
            // make draggable!
            if (JP.isAlreadyDraggable(el)) {
                _super.makeDraggable(el);
            }
            _super.nodeMap()[id] = el;
            _super.reverseNodeMap()[elId] = el.jtk.node;

            if (miniview != null) {
                miniview.registerNode({el: el, node: el.jtk.node, pos: JP.getAbsolutePosition(el) });
            }
        }.bind(this);

        /**
         * Zooms the display so that all the tracked elements fit into 90% of the viewport. This method will also,
         * by default, increase the zoom if necessary - meaning the default behaviour is to adjust the zoom so that
         * the content fills the viewport. You can suppress zoom increase by setting `doNotZoomIfVisible:true` on the
         * parameters to this method. You can supply a `fill` parameter to tell the Surface how much of the viewport
         * you wish to fill with the zoomed content if 90% is not to your liking.
         * @method zoomToFit
         * @param {Object} [params]
         * @param {Number} [params.fill=0.90] A decimal indicating how much of the viewport to fill with the zoomed content.
         * @param {Number} [params.padding=20] Optional padding to leave around all elements.
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotAnimate=true] By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
         * @param {Boolean} [params.doNotZoomIfVisible=false] If true, no action is taken if the content is currently all visible.
         * @param {Boolean} [params.doNotFirePanEvent=false] If true, a pan event will not be fired.
         */
        this.zoomToFit = panzoom.zoomToFit;

        /**
         * Zooms the display so that all the tracked elements fit inside the viewport, but does not make any adjustments
         * to zoom if all the elements are currently visible (it still does center the content though).
         * @method zoomToFitIfNecessary
         * @param {Object} [params]
         * @param {Number} [params.padding = 20] Optional padding to leave around all elements.
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotAnimate=true] By default, the centering content step does not use animation. This is due to this method being used most often to initially setup a UI.
         */
        this.zoomToFitIfNecessary = panzoom.zoomToFitIfNecessary;

        /**
         * Zooms the display so that the current selected nodes are all visible.
         * @method zoomToSelection
         * @param [params] {Object} Optional method params
         * @param {Number} [params.fill=0.90] A decimal indicating how much of the viewport to fill with the zoomed content.
         * @param [params.selection] Optional Selection to which to zoom. If omitted, the default is to use the Toolkit's
         * current selection.
         */
        this.zoomToSelection = function(params) {
            params = params || {};

            var sel = params.selection || _super.toolkit.getSelection(), els = [];
            sel.eachNode(function(idx, n) {
                els.push(_super.getElement(n.id));
            });

            if (els.length > 0) {
                panzoom.zoomToElements({elements:els, fill:params.fill});
            }
        };

        /**
         * Zooms the display so that the background fits inside the viewport.
         * @method zoomToBackground
         * @param {Object} [params]
         * @param {Function} [params.onComplete] Optional function to call on operation complete (centering may be animated).
         * @param {Function} [params.onStep] Optional function to call on operation step (centering may be animated).
         * @param {Boolean} [params.doNotAnimate=false] If true, centering content will not use animation.
         */
        this.zoomToBackground = panzoom.zoomToBackground;

        /**
         * Centers the given object in the viewport. You can pass in a DOM element or a Toolkit Node here.
         * @method centerOn
         * @param {Node|Element|String} obj Object to center in the viewport - a Node, Element, or Node id.
         * @param {Object} [params] Optional extra parameters.
         * @param {Boolean} [params.horizontal=true] Whether or not to center horizontally
         * @param {Boolean} [params.vertical=true] Whether or not to center vertically
         * @param {Boolean} [params.doNotAnimate=false] If true, animation will not be switched on for the operation.
         * @param {Boolean} [params.onComplete] Optional on complete callback
         * @param {Boolean} [params.onStep] Optional on animation step callback.
         */
        this.centerOn = function (obj, params) {
            var info = this.getObjectInfo(obj);
            info && info.el && panzoom.centerOn(info.el, params);
        };

        /**
         * Centers the given element in the viewport, horizontally only.
         * @method centerOnHorizontally
         * @param {Element|String} element Element, or element id, to center.
         */
        this.centerOnHorizontally = function (element) {
            this.centerOn(element, {vertical:false});
        };

        /**
         * Centers the given element in the viewport, vertically only.
         * @method centerOnHorizontally
         * @param {Element|String} element Element, or element id, to center.
         */
        this.centerOnVertically = function (element) {
            this.centerOn(element, {horizontal:false});
        };

        /**
         * Centers on the given element and then adjusts the zoom of the widget so that the short axis of the viewport
         * is [1 / fillRatio] larger than its corresponding axis on the centered node. `fillRatio` is basically
         * a measure of how much context you want to see around the node on which you centered.
         * @method centerOnAndZoom
         * @param {Element|String} element Element, or element id, to center.
         * @param {Number} [fillRatio=0.6] Proportional ratio of the corresponding node's edge to the viewport's short edge.
         */
        this.centerOnAndZoom = function(obj, fillRatio) {
            var info = this.getObjectInfo(obj);
            info && info.el && panzoom.centerOnAndZoom(info.el, fillRatio);
        };

        /**
         * Centers the content in the viewport.
         * @method centerContent
         */
        this.centerContent = panzoom.centerContent;

        /**
         * Centers the content in the viewport horizontally.
         * @method centerContentHorizontally
         */
        this.centerContentHorizontally = panzoom.centerContentHorizontally;

        /**
         * Centers the content in the viewport vertically.
         * @method centerContentVertically
         */
        this.centerContentVertically = panzoom.centerContentVertically;

        /**
         * Gets the canvas location that corresponds to the center of the viewport.  Note that this may describe
         * a point outside of the content bounds.
         * @method getViewportCenter
         * @return {Number[]} left,top location of the logical position on the canvas corresponding to the center of the viewport.
         */
        this.getViewportCenter = panzoom.getViewportCenter;

        /**
         * Sets the location of the canvas such that the given point appears at the center of the viewport.
         * @method setViewportCenter
         * @param {Number[]} xy left, top location of the point on the canvas to position in the center of the viewport.
         */
        this.setViewportCenter = panzoom.setViewportCenter;

        /**
         * Sets the default handle to use for state save/restore operations.
         * @method setStateHandle
         * @param {String} handle Handle to use.
         */
        this.setStateHandle = function (handle) {
            stateHandle = handle;
        };

        /**
         * Gets the default handle to use for state save/restore operations.
         * @method getStateHandle
         * @return {String} Handle in use.
         */
        this.getStateHandle = function () {
            return stateHandle;
        };

        /**
         * Sets the current lasso selection filter function.
         * @method setLassoSelectionFilter
         * @param {Function} fn A function that takes Nodes as argument and returns false if the Node should not be
         * selected. Any other return value will cause the Node to be selected.
         */
        this.setLassoSelectionFilter = function(fn) {
            lassoSelectionFilter = fn;
        };

        /**
         * Returns the apparent [left,top] of the canvas inside the viewport - the coordinates, in real pixel
         * values, of where the origin of the canvas appears to be. This apparent origin is not necessarily the
         * same as the [left,top] values of the canvas, because the transform origin and zoom values change
         * things.  This function can be used in conjunction with the content bounds by widgets such as the miniview,
         * to calculate what is actually visible in the viewport at some point in time.
         * @method getApparentCanvasLocation
         * @return [Number[]] [left,top] of the canvas, relative to the viewport's 0,0.
         */
        this.getApparentCanvasLocation = panzoom.getApparentCanvasLocation;

        /**
         * Sets the apparent canvas location - see the notes for getApparentCanvasLocation.
         * @method setApparentCanvasLocation
         * @param {Number} left Value in pixels for left edge of canvas.
         * @param {Number} top Value in pixels for top edge of canvas.
         * @return {Number[]} [left,top] of the actual origin set, after clamping.
         */
        this.setApparentCanvasLocation = panzoom.setApparentCanvasLocation;

        /**
         * Gets the current bounds information.
         * @method getBoundsInfo
         */
        this.getBoundsInfo = panzoom.getBoundsInfo;

        /**
         * Sets the current zoom, clamping it to the allowed range.
         * @method setZoom
         * @param {Number} zoom Zoom value. If this is outside the allowed bounds it will be clamped.
         * @return {Number} Current zoom. This may or may not be the value you asked for - it might have been clamped to the current allowed zoom range.
         */
        this.setZoom = panzoom.setZoom;

        /**
         * Sets the current zoom range. By default, this method checks if the current zoom is within
         * the new range, and if it is not then `setZoom` is called, which will cause the zoom to be clamped
         * to an allowed value in the new range. You can disable this by passing `true` for `doNotClamp`.
         * @method setZoomRange
         * @param {Number[]} zr New range, as an array consisting of [lower, upper] values. Lower must be less than upper.
         * @param {Boolean} [doNotClamp] If true, will not check the current zoom to ensure it falls within the new range.
         */
        this.setZoomRange = panzoom.setZoomRange;

        /**
         * Gets the current zoom range.
         * @method getZoomRange
         * @return {Number[]} Array of [min, max] zoom values.
         */
        this.getZoomRange = panzoom.getZoomRange;

        /**
         * Gets the current zoom.
         * @method getZoom
         * @return {Number} Current zoom value
         */
        this.getZoom = panzoom.getZoom;

        /**
         * Nudges the zoom by the given amount. Zoom will be clamped to the current zoom range in effect and the
         * value that was ultimately set is returned from this function. The value you pass in here is multiplied by
         * 100 to give a percentage value: 1 is 100%, for instance, 0.05 is 5%.
         * @method nudgeZoom
         * @param {Number} delta Amount to change zoom by.
         * @param {Event} [e] Original event that caused the nudge. May be null.
         * @return {Number} The zoom that was set. Zoom will be clamped to the allowed range.
         */
        this.nudgeZoom = panzoom.nudgeZoom;

        /**
         * Nudges the wheel zoom by the given amount. This function is intended for use by components that control
         * zoom via the mouse wheel, and not for general usage. See `nudgeZoom` for a more general version of this.
         * @method nudgeWheelZoom
         * @param {Number} delta Amount to change zoom by.
         * @param {Event} [e] Original event that caused the nudge. May be null.
         */
        this.nudgeWheelZoom = panzoom.nudgeWheelZoom;

        /**
         * Decodes the page location from the given event, taking touch devices into account.
         * @method pageLocation
         * @return {Number[]} [left, top] of the given event.
         */
        this.pageLocation = panzoom.pageLocation;

        /**
         * Gets the current [left,top] of the panned content.
         * @method getPan
         * @return {Number[]} [left,top], in pixels, of the panned content, where [0,0] is the origin of the viewport.
         */
        this.getPan = panzoom.getPan;

        /**
         * Pans the content by dx and dy.
         * @method pan
         * @param {Number} dx Amount to pan in X direction
         * @param {Number} dy Amount to pan in Y direction
         * @param {Boolean} [animate = false] Whether or not to animate the pan.
         */
        this.pan = panzoom.pan;

        /**
         * Sets the position of the panned content's origin.
         * @method setPan
         * @param {Number} left Position in pixels of the left edge of the panned content.
         * @param {Number} top Position in pixels of the top edge of the panned content.
         * @param {Boolean} [animate = false] Whether or not to animate the pan.
         * @param {Function} [onComplete] If `animate` is set to true, an optional callback for the end of the pan.
         * @param {Function} [onStep] If `animate` is set to true, an optional callback for each frame in the pan.
         */
        this.setPan = panzoom.setPan;


        //
        // resolve an Edge or Connection or Edge ID into a Connection.
        //
        function _resolveConnection(edgeOrConnection) {
            return edgeOrConnection == null ? null :
                    typeof edgeOrConnection === "string" ? this.getRenderedConnection(edgeOrConnection) :
                        edgeOrConnection.constructor == JP.Connection ? edgeOrConnection :
                            self.getRenderedConnection(edgeOrConnection.getId());
        }

        //
        // ensure the editors have been included. throw a TypeError if not.
        //
        function _ensureCanEdit() {
            if (!_super.jsPlumb.startEditing) {
                throw new TypeError("Connection editors not available.");
            }
        }

        /**
         * Starts editing of the given Edge, Connection, or Edge ID.
         * @method startEditing
         * @param {String|Edge|Connection} edgeOrConnection Either an Edge, or a Connection, or an Edge ID.
         * @param {Object} [params] Optional params for the start edit call.
         */
        this.startEditing = function(edgeOrConnection, params) {
            _ensureCanEdit();
            var conn = _resolveConnection(edgeOrConnection);
            if (conn != null) {
                _super.jsPlumb.startEditing(conn, params);
            }
        };

        /**
         * Stops editing of the given Edge, Connection, or Edge ID.
         * @method stopEditing
         * @param {String|Edge|Connection} edgeOrConnection Either an Edge, or a Connection, or an Edge ID.
         */
        this.stopEditing = function(edgeOrConnection) {
            _ensureCanEdit();
            var conn = _resolveConnection(edgeOrConnection);
            if (conn != null) {
                _super.jsPlumb.stopEditing(conn);
            }
        };

        /**
         * Clears edits for the given Edge, Connection, or Edge ID.
         * @param {String|Edge|Connection} edgeOrConnection Either an Edge, or a Connection, or an Edge ID.
         */
        this.clearEdits = function(edgeOrConnection) {
            _ensureCanEdit();
            var conn = _resolveConnection(edgeOrConnection);
            if (conn != null) {
                _super.jsPlumb.clearEdits(conn);
            }
        };


        this.setPanAndZoom = function(x, y, zoom, doNotAnimate) {
            this.setPan(x, y, !doNotAnimate);
            this.setZoom(zoom, !doNotAnimate);
        };

        /**
         * Sets the filter used to determine whether or not a given event should begin a pan.
         * @method setPanFilter
         * @param {String|Function} f Either a CSS selector to use as a whitelist on the event target, or a function that will be given the target of the current mouse event. You must return true from the function if you wish for a pan to begin.
         */
        this.setPanFilter = function (f) {
            panzoom.setFilter(f ? function (d, e) {
                if (typeof f == "function")
                    return f.apply(f, [e]);
                else {
                    return JUTIL.matchesSelector(d, f);
                }
            } : null);
        };

        /**
         * Sets the filter used to determine whether or not a given wheel event should be responded to.
         * @method setWheelFilter
         * @param {String} filter A CSS selector to use as a blacklist on the event target.
         */
        this.setWheelFilter = function (filter) {
            panzoom.setWheelFilter(function (e) {
                if (!filter) return true;
                else {
                    var t = e.srcElement || e.target;
                    return !JUTIL.matchesSelector(t, filter);
                }
            });
        };

        this.setWheelFilter(params.wheelFilter);
        this.setPanFilter(params.panFilter);

        /**
         * Maps the given page location to an [x,y] location in the Surface's canvas.
         * @method mapLocation
         * @param {Number} x X location to map
         * @param {Number} y Y location to map
         */
        this.mapLocation = panzoom.mapLocation;

        /**
         * Maps the page location of the given event to an [x,y] location in the Surface's canvas.
         * @method mapEventLocation
         * @param {Event} e Event to map
         */
        this.mapEventLocation = panzoom.mapEventLocation;

        /**
         * Finds all nodes whose centers are within a rectangle with `origin` as its center, and
         * a width and height of `radius / 2`.
         * @method findNearbyNodes
         * @param {Number[]} [x,y] location for center of search
         * @param {Number} Radius of search.
         * @param {Boolean} [mustBeInViewport=false] If true, first check that the given origin is within the viewport.
         * @param {Function} [filter] Optional filter function. This is passed the (id, node, boundingRect) of some element and should return true for elements that should be included in results.
         * @return {Object[]} A list of objects containing {id:id, el:element, r:bounding rect}, sorted in ascending order of distance of the center of the bounding rectangle from the given origin.
         */
        this.findNearbyNodes = panzoom.findNearbyNodes;

        /**
         * Finds all nodes that intersect to any extent the rectangle defined by the given origin
         * and dimensions. This rectangle is taken to be in the coordinate space of the document, ie. a value
         * of [0,0] for the origin means the document's top/left corner. A future version could take an optional
         * third argument specifying the element whose origin to use.
         * @method findIntersectingNodes
         * @param {Number[]} origin [x,y] location for center of search
         * @param {Number[]} dimensions Width and height of search area.
         * @param {Boolean} [enclosed=false] If true, returns only nodes that are enclosed by the given search area. Otherwise returns nodes that both intersect and are enclosed.
         * @return {Object[]} A list of objects containing {id:id, el:element, r:bounding rect} that either intersect or are enclosed by the search area.
         */
        this.findIntersectingNodes = panzoom.findIntersectingNodes;

        /**
         * Returns whether or not the given point (relative to page origin) is within the viewport for the widget.
         * @method isInViewport
         * @param {Number} x X location of point to test
         * @param {Number} y Y location of point to test
         * @return {Boolean} True if the point is within the viewport, false if not.
         */
        this.isInViewport = panzoom.isInViewport;

        /**
         * Places (using `style.left` and `style.top`) the given element at the given x,y, which is taken to
         * mean an [x,y] value on the canvas.  At zoom 1, with no panning, this will be the same as the given [x,y] value
         * relative to the viewport origin.  But once the canvas has been zoomed and panned we have to map
         * to the altered coordinates. This function also takes into account the difference between the offset of the
         * viewport in the page and the offset of the given element. It is assumed, just because of what this method
         * does, that the given element will be positioned `absolute`, but this method does nothing to ensure that.
         * Note that this method - and its relatives, `positionElementAtEventLocation` and `positionElementAtPageLocation` - are
         * not intended for use with elements being managed by the Surface. They are for use with external
         * elements that you need to align with the contents of the Surface.
         * @method positionElementAt
         * @param {Selector|Element|String} el Element to position.
         * @param {Number} x X location on canvas to move element's left edge to.
         * @param {Number} y Y location on canvas to move element's top edge to.
         * @param {Number} [xShift=0] Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
         * @param {Number} [yShift=0] Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
         */
        this.positionElementAt = panzoom.positionElementAt;

        /**
         * Places (using `style.left` and `style.top`) the given element at the page x,y corresponding to the given
         * event.  It is assumed, just because of what this method does, that the given element will be positioned
         * `absolute`, but this method does nothing to ensure that. Note that this method - and its relatives,
         * `positionElementAt` and `positionElementAtPageLocation` - are not intended for use with elements being
         * managed by the Surface. They are for use with external elements that you need to align with the contents
         * of the Surface.
         * @method positionElementAtEventLocation
         * @param {Selector|Element|String} el Element to position.
         * @param {Event} evt Event to position element at.
         * @param {Number} [xShift=0] Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
         * @param {Number} [yShift=0] Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
         */
        this.positionElementAtEventLocation = panzoom.positionElementAtEventLocation;

        /**
         * Places (using `style.left` and `style.top`) the given element at the given page x,y.  It is assumed, just
         * because of what this method does, that the given element will be positioned `absolute`, but this method
         * does nothing to ensure that. Note that this method - and its relatives, `positionElementAtEventLocation`
         * and `positionElementAt` - are not intended for use with elements being managed by the Surface. They are
         * for use with external elements that you need to align with the contents of the Surface.
         * @method positionElementAtPageLocation
         * @param {Selector|Element|String} el Element to position.
         * @param {Number} x X location on canvas to move element's left edge to.
         * @param {Number} y Y location on canvas to move element's top edge to.
         * @param {Number} [xShift=0] Optional absolute number of pixels to shift the element by in the x axis after calculating its position relative to the canvas. Typically you'd use this to place something other than the top left corner of your element at the desired location.
         * @param {Number} [yShift=0] Optional absolute number of pixels to shift the element by in the y axis after calculating its position relative to the canvas.
         */
        this.positionElementAtPageLocation = panzoom.positionElementAtPageLocation;

        /**
         * Sets (or clears) the filter that will be called if the widget needs to know whether to respond to an event that would
         * start a pan. By default, the widget responds to down events on the viewport or the canvas, but not on child nodes. You
         * can supply a function that the widget will call in the event that the down event did not occur on the viewport or the canvas;
         * returning true from this function will cause the pan to begin.
         * @method setFilter
         * @param {Function} filterFn Function to set as the filter; may be null if you wish to clear it. The function should return true if it wants to honour the down event on the given element.
         */
        this.setFilter = panzoom.setFilter;

        /**
         * Appends an element to the viewport so that it floats above the content that is being zoomed and panned.
         * The element will have `position:absolute` set on it. You can float any element you like, but note that the
         * responsibility for setting an appropriate z index is yours.
         * @method floatElement
         * @param {Element} el Element to float.
         * @param {Number[]} pos Array of [x,y] positions.
         */
        this.floatElement = panzoom.floatElement;

        /**
         * Appends an element to the content such that it is zoomed with everything else, but constrains pan
         * in one or both axes so that the element remains fixed with respect to the viewport origin.
         * @method fixElement
         * @param {Element} el The DOM element to append.
         * @param {Object} constraints Flags to indicate optional constraint to each axis.
         * @param {Number[]} pos [left,top] location of the element's origin.
         */
        this.fixElement = panzoom.fixElement;

        var _superSetPosition = this.setPosition,
            _superAnimateToPosition = this.animateToPosition,
            _doSetPosition = function(info, x, y) {
                if (info) {
                    panzoom.positionChanged(info.el, [x, y]);
                    self.fire(_e.nodeMoveEnd, {
                        el: info.el,
                        id: info.id,
                        pos: [x, y],
                        node: info.obj || (info.el.jtk ? (info.el.jtk.node || info.el.jtk.group) : {}),
                        bounds: panzoom.getBoundsInfo()
                    });
                }
            };

        // js doc in superclass
        this.setPosition = function (el, x, y, doNotUpdateElement) {
            var info = _superSetPosition.apply(this, arguments);
            _doSetPosition(info, x, y);
        };

        // js doc in superclass
        this.animateToPosition = function (el, x, y, animateOptions) {
            var info = _superAnimateToPosition.apply(this, arguments);
            _doSetPosition(info, x, y);
        };

        /**
         * Traces the given overlay along either a given path, or the shortest path
         * from a specified `source` to a specified `target` (if such a path exists).
         * If there is no path nothing happens (except for a debug trace, if you have debugging enabled on
         * the Toolkit instance via `toolkit.setDebugEnabled(true)`)
         * @param {Object} params Options for the trace.
         * @param {Path} [params.path] Path to trace.
         * @param {String|Element|Node|Port} [params.source] Source of traversal. May be a Node or Port, or a DOM element or element id. Supply this if you do not supply `path`.
         * @param {String|Element|Node|Port} [params.target] Target of traversal. May be a Node or Port, or a DOM element or element id. Supply this if you do not supply `path`.
         * @param {String|Object} params.overlay This is in the format accepted by the Community edition of jsPlumb.
         * @param {Object} [params.options] Options for animation.
         * @param {Number} [params.options.dwell=250] How long, in milliseconds, to dwell on each node as the overlay traverses the path.
         * @param {Number} [params.options.speed=100] How many pixels per second to travel. *Note*: this is in seconds, not milliseconds.
         * @param {Number} [params.options.rate=30] Frame rate, in milliseconds.
         * @returns {Boolean} True if the path existed and was traced. False otherwise.
         */
        this.tracePath = function(params) {
            var path = params.path || (function() {
                var source = _super.getObjectInfo(params.source);
                var target = _super.getObjectInfo(params.target);
                return _super.toolkit.getPath({source: source, target: target});
            })();

            if (path.exists()) {
                var fire = function (event, connection) {
                        this.fire(event, { edge: connection.edge, connection: connection, options: params.options });
                    }.bind(this),
                    components = [], currentConn = null, previousConn = null,
                    pathLength = path.path.path.length;

                for (var i = 1; i < pathLength; i++) {

                    var thisVertexId = path.path.path[i].vertex.id,
                        previousVertex = path.path.previous[thisVertexId],
                        forwards = true,
                        thisEdge = path.path.path[i].edge;

                    // if previous vertex not null, ensure that it is the SOURCE of
                    // the edge. if it is not, then we need to traverse this edge
                    // in the opposite to its natural flow.
                    if (previousVertex != null) {
                        forwards = previousVertex === thisEdge.source;
                    }

                    currentConn = _super.getConnectionForEdge(thisEdge);
                    previousConn = currentConn.animateOverlay(params.overlay,
                        JP.extend(params.options || {}, {
                            previous: previousConn,
                            isFinal: i === pathLength - 1,
                            forwards: forwards
                        }));

                    components.push({handler: previousConn, connection: currentConn});
                }

                if (components.length > 0) {
                    components[0].handler.bind(jsPlumbToolkit.Events.startOverlayAnimation, function () {
                        fire(jsPlumbToolkit.Events.startOverlayAnimation, components[0].connection);
                    });
                    components[components.length - 1].handler.bind(jsPlumbToolkit.Events.endOverlayAnimation, function () {
                        fire(jsPlumbToolkit.Events.endOverlayAnimation, components[components.length - 1].connection);
                    });
                }

                return true;
            }
            else {
                if (_super.toolkit.isDebugEnabled()) {
                    jsPlumbUtil.log("Cannot trace non existent path");
                }

                return false;
            }

        };

        /**
         * Returns a map of element ids -> positions.
         * @return {Object} Map of { id->[x,y]} positions.
         */
        this.getNodePositions = function () {
            var out = {};
            var ep = panzoom.getElementPositions();
            for (var i in ep) {
                var n = _super.getNodeForElementId(i) || _super.getGroupForElementId(i);
                if (n) {
                    out[n.id] = [ ep[i][0][0], ep[i][0][1] ];
                }
            }
            return out;
        };

        //
        // Append an element to the surface. Not part of the public API, unless being used via a layout
        // decorator. But the decorator does not know it is talking to a Surface.
        // Pos is a {left:, top:} object. It gets converted to an Array for the PanZoom widget.
        //
        this.append = function (el, id, pos, isDecoration) {
            canvasElement.appendChild(el);
            if (pos) {
                pos = [ pos.left, pos.top ];
            }
            panzoom.add(el, id, pos, isDecoration);
        };

        this.nodeAppendedToGroup = function(el, groupEl, group) {
            panzoom.suspend(el);
        };

        this.nodeRemovedFromGroup = function(el) {
            panzoom.restore(el);
        };

        var _setLayoutParent = this.setLayout;
        this.setLayout = function (l, doNotRefresh) {
            _setLayoutParent.apply(this, [l, doNotRefresh]);
            if (miniview) {
                miniview.setHostLayout(this.getLayout());
            }
        };

// -------------------- event delegation - click, dblclick etc ----------------------------------------------------------------

        var _delegateOne = function (evt) {
            _super.jsPlumb.on(canvasElement, evt, ".jtk-node, .jtk-node *", function (e) {
                var t = e.srcElement || e.target;
                if (t == null) {
                    e = JP.getOriginalEvent(e);
                    t = e.srcElement || e.target;
                }

                if (t != null && t.jtk) {
                    var args = JP.extend({e: e, el: t}, t.jtk);
                    self.fire(evt, args, e);
                }
            });
        };

        for (var i = 0; i < exports.mouseEvents.length; i++) {
            _delegateOne(exports.mouseEvents[i]);
        }

// -------------------- / event delegation - click, dblclick etc ----------------------------------------------------------------


// ------------------------------ node selection/deselection --------------------------------------
        _super.toolkit.bind(_c.select, function (d) {
            if (d.obj.objectType == _c.nodeType || d.obj.objectType == _c.groupType) {
                var el = _super.getElement(d.obj.id);
                if (el) {
                    JP.addClass(el, _cl.SURFACE_SELECTED_ELEMENT);
                    _super.jsPlumb.addToDragSelection && _super.jsPlumb.addToDragSelection(el);
                }
            }
            else if (d.obj.objectType == _c.edgeType) {
                var conn = _super.getConnectionForEdge(d.obj);
                if (conn) {
                    conn.addClass(_cl.SURFACE_SELECTED_CONNECTION);
                }
            }
        });

        _super.toolkit.bind(_e.selectionCleared, function () {
            _super.jsPlumb.clearDragSelection && _super.jsPlumb.clearDragSelection();
            JP.removeClass($j("." + _cl.SURFACE_SELECTED_CONNECTION), _cl.SURFACE_SELECTED_CONNECTION);
            JP.removeClass($j("." + _cl.SURFACE_SELECTED_ELEMENT), _cl.SURFACE_SELECTED_ELEMENT);
        });

        _super.toolkit.bind(_e.deselect, function (d) {
            if (d.obj.objectType == _c.nodeType || d.obj.objectType == _c.groupType) {
                var el = _super.getElement(d.obj.id);
                if (el) {
                    JP.removeClass(el, _cl.SURFACE_SELECTED_ELEMENT);
                    _super.jsPlumb.removeFromDragSelection && _super.jsPlumb.removeFromDragSelection(el);
                }
            }
            else if (d.obj.objectType == _c.edgeType) {
                var conn = _super.getConnectionForEdge(d.obj);
                if (conn) {
                    conn.removeClass(_cl.SURFACE_SELECTED_CONNECTION);
                }
            }
        });

        var so = this.setOffset;
        this.setOffset = function (el, o) {
            so.apply(this, arguments);
            panzoom.positionChanged(el, [o.left, o.top]);
        };

        /**
         * Sets the current mode - "pan", "select" or "disabled", then fires an event notifying any listeners subscribed to the `modeChanged` event.
         * @method setMode
         * @param {String} mode Mode to set. Must be one of Surface.PAN, Surface.SELECT or Surface.DISABLED.
         * @param {Boolean} [doNotClearSelection=false] By default, when switching _into_ Select mode, the current selection is cleared. Setting this to false prevents the selection from being cleared.
         */
        this.setMode = function (mode, doNotClearSelection, options) {
            if (modes[mode]) {
                _mode = mode;
                modes[mode]();

                if (mode === _c.select && !doNotClearSelection) {
                    // clear existing selection
                    _super.toolkit.clearSelection();
                }

                if (options && mode === _c.select) {
                    if (options.lassoSelectionFilter) lassoSelectionFilter = options.lassoSelectionFilter;
                }

                self.fire(_e.modeChanged, mode);
            }
            else {
                throw new TypeError("Surface: unknown mode '" + mode + "'");
            }
        };

        var _selectEdges = function (params, edgeSelectFunction) {
            var p = JP.extend({}, params);
            p.source = _super.getObjectInfo(params.source).obj;
            p.target = _super.getObjectInfo(params.target).obj;
            p.element = _super.getObjectInfo(params.element).obj;
            var edges = _super.toolkit[edgeSelectFunction](p),
                connections = _super.getConnectionsForEdges(edges);
            return _super.jsPlumb.select({connections: connections});
        };

        /**
         * Selects a set of edges. If you supply a DOM element for any of the arguments here, the underlying graph object - a Node or a Port - will be
         * determined, and the edges for that object will be retrieved.  Note that for a Port this method does the same thing as
         * `selectAllEdges`, but for a Node, which may have Ports registered on it, this method will retrieve only the Edges directly
         * registered on the Node itself.  You may need to use `selectAllEdges` if you want everything from some Node.
         * @method selectEdges
         * @param {Object} params Selection parameters
         * @param {String|Element|Node|Selector} [params.source]  Source node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
         * @param {String|Element|Node|Selector} [params.target]  Target node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
         * @param {String|Element|Node|Selector} [params.element] Source or target node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
         */
        this.selectEdges = function (params) {
            return _selectEdges(params, "getEdges");
        };

        /**
         * Selects a set of Edges.  Parameters are the same as for selectEdges; the difference here is that when you're working with
         * Nodes, this method will return all of the Node's Edges as well as those of all the Ports registered on the Node.
         * @method selectAllEdges
         * @param {Object} params Selection parameters
         * @param {String|Element|Node|Selector} [params.source]  Source node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
         * @param {String|Element|Node|Selector} [params.target]  Target node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
         * @param {String|Element|Node|Selector} [params.element] Source or target node, as a Node, a DOM element, a selector, or a String (including support for wildcard '*')
         *
         */
        this.selectAllEdges = function (params) {
            return _selectEdges(params, "getAllEdges");
        };

        /**
         * Repaints the element for the given object.
         * @method repaint
         * @param {String|Port|Node|Element|Selector} obj Object to repaint, including any associated connections. This can be
         * a Toolkit Node or Port, a String (representing a Node or Node.Port id), a DOM element, or a selector from the support library
         * modelling a DOM element.
         */
        this.repaint = function (obj) {
            var info = _super.getObjectInfo(obj);
            if (info.el) {
                _super.jsPlumb.recalculateOffsets(info.el);
                _super.jsPlumb.revalidate(_super.jsPlumb.getId(info.el));
                self.fire(_e.objectRepainted, info);
            }
        };

        /**
         * Repaints every element in the UI.
         * @method repaintEverything
         */
        this.repaintEverything = _super.jsPlumb.repaintEverything;

        /**
         * Sets whether or not elements will be made draggable. This does not disable dragging on elements
         * that are already draggable.
         * @method setElementsDraggable
         * @param {Boolean} d If false, elements will not be made draggable. If null or true, they will.
         */
        this.setElementsDraggable = function (d) {
            elementsDraggable = d !== false;
        };

        var _droppablesHandler = function (droppableParams) {
            if (!droppableParams || (!droppableParams.droppables && !(droppableParams.source && droppableParams.selector) && (droppableParams.allowNative !== true))) throw new TypeError("Cannot configure droppables: you must specify either `droppables`, `source` + `selector` or `allowNative:true`");

            var dataGenerator = droppableParams.dataGenerator || function () { return { }; },
                typeExtractor = droppableParams.typeExtractor,
                locationSetter = droppableParams.locationSetter || function (left, top, data) {
                    data.left = left;
                    data.top = top;
                },
                i,
                droppables = droppableParams.droppables ? droppableParams.droppables :
                             droppableParams.source ? droppableParams.source.querySelectorAll(droppableParams.selector) :
                             [],
                dragOptions = droppableParams.dragOptions || {},
                dropOptions = droppableParams.dropOptions || {},
                scope = "scope_" + (new Date()).getTime(),
                drop = function (e, ui, native) {
                    var cont = true;
                    if (droppableParams.drop) {
                        cont = droppableParams.drop.apply(this, arguments) !== false;
                    }
                    if (cont) {
                        var jp = self.getJsPlumb(),
                            dragObject = _super.jsPlumb.getDragObject(arguments),
                            dragObjectLocation = jp.getOffset(native ? nativeDragPlaceholder : dragObject, true),
                            eventLocation = panzoom.mapLocation(dragObjectLocation.left, dragObjectLocation.top),
                            type = typeExtractor ? typeExtractor(dragObject, e, native, eventLocation) : null,
                            data = dataGenerator ? dataGenerator(type, dragObject, e, eventLocation) : {},
                            isGroup = dragObject.getAttribute("jtk-group") === "true";

                        data = data || {}; // allow data generator to pass back null.

                        var droppedOnObject = self.getObjectInfo(e.e.srcElement || e.e.target );

                        if (type != null)
                            data.type = type;

                        if (droppedOnObject != null && !isGroup && droppedOnObject.type === "Group") {
                            var uiGroup = jp.getGroup(droppedOnObject.id);
                            var groupOffset = self.getOffset(uiGroup ? uiGroup.getDragArea() : droppedOnObject.el);
                            eventLocation.left -= groupOffset.left;
                            eventLocation.top -= groupOffset.top;
                        }

                        locationSetter(eventLocation.left, eventLocation.top, data);
                        //
                        if (!isGroup) {
                            _super.toolkit.getNodeFactory()(type, data, function (n) {
                                // second arg will be passed through by the Toolkit to registered listeners, ie.
                                // the Surface and its layout. This will probably supersede `locationSetter`.
                                var droppedNode = _super.toolkit.addNode(n, { position: eventLocation });
                                if (droppedOnObject.obj != null && droppedOnObject.type === "Group") {
                                    _super.toolkit.addToGroup(droppedNode, droppedOnObject.obj);
                                    // force position set (on underlying jsplumb view)
                                    self.setPosition(_super.nodeMap()[droppedNode.id], eventLocation.left, eventLocation.top);
                                    // ensure group's child offsets updated.
                                    jp.getDragManager().updateOffsets(droppedOnObject.el);
                                }

                                droppableParams.onDrop && droppableParams.onDrop(droppedNode, e, eventLocation);

                            }, e, native);
                        }
                        else {
                            _super.toolkit.getGroupFactory()(type, data, function (n) {
                                // second arg will be passed through by the Toolkit to registered listeners, ie.
                                // the Surface and its layout. This will probably supersede `locationSetter`.
                                var droppedGroup = _super.toolkit.addGroup(n, { position: eventLocation });
                                droppableParams.onDrop && droppableParams.onDrop(droppedGroup, e, eventLocation);
                            }, e, native);
                        }
                    }
                },
                startEv = JP.dragEvents[_c.start],
                dragEv = JP.dragEvents[_c.drag],
                stopEv = JP.dragEvents[_c.stop],
                dropEv = JP.dragEvents[_c.drop],
                devNull = function () {
                },
                nativeFilter = droppableParams.nativeFilter || [],
                allowNative = droppableParams.allowNative,
                nativeFilterMap = {};

            dragOptions[startEv] = JUTIL.wrap(dragOptions[startEv], droppableParams.start || devNull);
            dragOptions[dragEv] = JUTIL.wrap(dragOptions[dragEv], droppableParams.drag || devNull);
            dragOptions[stopEv] = JUTIL.wrap(dragOptions[stopEv], droppableParams.stop || devNull);

            dropOptions.scope = scope;
            dropOptions[dropEv] = JUTIL.wrap(dropOptions[dropEv], drop);

// NATIVE
            if (allowNative) {
                var nativeDragPlaceholder = document.createElement(_c.div);
                nativeDragPlaceholder.style.position = _c.absolute;
                for (i = 0; i < nativeFilter.length; i++) {
                    nativeFilterMap[nativeFilter[i]] = true;
                }

                var _filterNative = function (e) {
                    if (e.dataTransfer != null && e.dataTransfer.items.length === 1) {
                        return (nativeFilter.length == 0 || nativeFilterMap[e.dataTransfer.items[0].type]);
                    }
                    return false;
                };

                document.addEventListener(_e.dragover, function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    if (_filterNative(e)) {
                        JP.setAbsolutePosition(nativeDragPlaceholder, [ e.pageX, e.pageY ]);
                        dragOptions[dragEv].apply(null, [ e, {
                            helper: nativeDragPlaceholder,
                            offset: { left: e.pageX, top: e.pageY }
                        }, true ]);
                    }
                }, false);

                document.addEventListener(_e.drop, function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    if (_filterNative(e)) {
                        dropOptions[dropEv].apply(null, [ e, {
                            helper: nativeDragPlaceholder,
                            offset: { left: e.pageX, top: e.pageY }
                        }, true ]);
                        dragOptions[stopEv].apply(null);
                    }
                }, false);

                document.addEventListener(_e.dragend, function (e) { });
            }

// / NATIVE

            _super.jsPlumb.initDroppable(containerElement, dropOptions, _c.surfaceNodeDragScope);

            function _oneDraggable(droppableNode) {
                if (!_super.jsPlumb.hasClass(droppableNode, _cl.SURFACE_DROPPABLE_NODE)) {
                    _super.jsPlumb.addClass(droppableNode, _cl.SURFACE_DROPPABLE_NODE);
                    _super.jsPlumb.initDraggable(droppableNode, dragOptions, _c.surfaceNodeDragScope, _super.jsPlumb);
                }
            }

            dragOptions.scope = scope;
            dragOptions.ignoreZoom = true; // draggables should not be subject to the zoom in place for UI elements.
            dragOptions.doNotRemoveHelper = true;
            for (i = 0; i < droppables.length; i++) {
                var droppableNode = _super.jsPlumb.getElement(droppables[i]);
                _oneDraggable(droppableNode);
            }

            return {
                refresh:function() {
                    if (!(droppableParams.source && droppableParams.selector)) {
                        throw new TypeError("Cannot refresh droppables; `source` and `selector` required in constructor.")
                    }
                    else {
                        var d = droppableParams.source.querySelectorAll(droppableParams.selector);
                        for (var i = 0; i < d.length; i++) {
                            _oneDraggable(d[i]);
                        }
                    }
                }
            }
        };

        /**
         * Allows you to register a list of droppables that can be dropped onto the surface. This function also supports
         * configuring the Surface to accept files dragged from the user's desktop, but it is limited to supporting one file
         * at a time.
         * @method registerDroppableNodes
         * @param {Object} params Parameters for droppables, including node list, drop options etc
         * @param {Function} [params.typeExtractor] Optional function to use to extract the related node type for some element that was dropped on the Surface.
         * @param {Function} [params.dataGenerator] Optional function to use to generate some initial data for a node of some given type. The function is passed `type` as argument, which _may be null_, so program defensively.
         * @param {Element[]} [params.droppables] List of elements identifying the elements to be configured as droppable. Either provide this,
         * or provide `source` and `selector`. It is only in this latter case that you will be able to call `refresh` to
         * subsequently add newly added elements to the set of droppables.
         * @param {Element} [params.source] Source element on which to execute `querySelectorAll` with the given `selector`
         * in order to get the list of elements to be configured as droppable.
         * @param {Element} [params.selector] Selector that specifies child nodes of `source` that should be configured as droppable.
         * @param {Object} [params.dragOptions] Optional set of drag options, in a format specific to your underlying library.
         * @param {Object} [params.dropOptions] Optional set of drop options, in a format specific to your underlying library.
         * @param {Function} [params.start] Function to call when a droppable starts to be dragged.
         * @param {Function} [params.drag] Function to call as a droppable is being dragged.
         * @param {Function} [params.stop] Function to call when a droppable stops being dragged.
         * @param {Function} [params.drop] Function to call when a droppable has been dropped, *before* the Toolkit code is run. Returning false from this function causes the drop to be aborted.
         */
        this.registerDroppableNodes = function (params) {
            return new _droppablesHandler(params);
        };

        // ************** miniview ********************************
        /**
         * Creates a miniview that is associated with this Surface.
         * @method createMiniview
         * @param {Object} params Miniview parameters. See Minview docs.
         */
        this.createMiniview = function (params) {

            // do not re-init an element that is already a miniview.
            if (miniview != null) {
                var containerId = _super.jsPlumb.getId(_super.jsPlumb.getElement(params.container));
                if (miniview.getContainerId() == containerId)
                    return false;
                // else ? cleanup the current miniview? or will garbage collection do that.
            }

            var p = JP.extend({
                surface: self,
                toolkit: _super.toolkit,
                surfaceContainerElement: containerElement,
                bounds: panzoom.getBoundsInfo(),
                visible: params.initiallyVisible !== false || _super.toolkit.getNodeCount() > 0,
                layout: {
                    type: _c.mistletoeLayoutType,
                    parameters: {
                        layout: self.getLayout()
                    }
                },
                typeFunction:params.typeFunction
            }, params);
            miniview = new JTK.Renderers.Miniview(p);

            // register existing nodes and groups.
            var nm = _super.nodeMap();
            for (var n in nm) {
                var el = nm[n];
                miniview.registerNode({el: el, node: el.jtk.node, pos: JP.getAbsolutePosition(el) });
            }

            var gm = _super.groupMap();
            for (var n in gm) {
                var el = gm[n];
                miniview.registerNode({el: el, node: el.jtk.group, pos: JP.getAbsolutePosition(el) });
            }

            return miniview;
        };
        if (params.miniview) {
            this.createMiniview(params.miniview);
        }

        /**
         * Gets the current Miniview, if there is one. There may not be.
         * @method getMiniview
         * @return {Miniview} Current Miniview, null if no Miniview is registered.
         */
        this.getMiniview = function () {
            return miniview;
        };

        //
        // enables/disables things.  for Ports, checks if an Endpoint exists (which would be the result of a jtk-port element
        // in a template).
        // TODO ideally we want this to return what the state was _before_ this one. but the IIFE makes that tricky.
        // the community version ince 2.1.6 returns that. but not sure about the endpoint yet.
        var _setEnabled = function(what, obj, state) {
            var info = _super.getObjectInfo(obj), out = null;
            if (info.el) {
                if (!info.obj.objectType === "Port" || !(function() {
                    var ep = self.getRenderedEndpoint(info.obj);
                    if (ep) {
                        out = ep.setEnabled(state);
                        return true;
                    }
                })()) {
                    // if not a Port, or no Endpoint exists, use the set***Enabled method on the jsPlumb community instance.
                    var method = "set" + what + "Enabled";
                    out = _super.jsPlumb[method](info.el, state);
                }
            }
            return out;
        };

        /**
         * Sets whether or not a given Node or Port is currently enabled as a connection target in the UI.
         * @method setTargetEnabled
         * @param {String|Node|Port|Element} Node/Port or Node/Port ID, or a DOM element to disable as a connection target.
         */
        this.setTargetEnabled = _setEnabled.bind(this, "Target");
        /**
         * Sets whether or not a given Node or Port is currently enabled as a connection source in the UI.
         * @method setSourceEnabled
         * @param {String|Node|Port|Element} Node/Port or Node/Port ID, or a DOM element to disable as a connection source.
         */
        this.setSourceEnabled = _setEnabled.bind(this, "Source");
        /**
         * Sets whether or not a given Node or Port is currently enabled as a connection target and source in the UI.
         * @method setEnabled
         * @param {String|Node|Port|Element} Node/Port or Node/Port ID, or a DOM element to disable as both a connection target and source.
         */
        this.setEnabled = function(obj, state) {
            this.setTargetEnabled(obj, state);
            this.setSourceEnabled(obj, state);
        };

        // ******************************* save/restore UI state (from either cookies or html5 storage, depending on the browser )

        this.State = {
            /**
             * Writes the current location of each node in the UI to local storage (using either a cookie or html5 storage,
             * depending on browser capabilities). You pass this function a 'handle' argument, which is used to restore the state
             * at some stage in the future.
             * @method State.save
             * @param {String} [handle] The handle to save the state as, If this is not supplied, and `stateHandle` was supplied as a constructor parameter, that is used instead.
             * @param {Function} [preprocessor] Optional preprocessor which is given the serialized state, and a callback function, before saving to localStorage. Useful if you wish to compress the data, for instance.
             */
            save: function (handle, preprocessor) {
                handle = arguments.length == 2 ? arguments[0] : arguments.length == 1 && typeof arguments[0] === "string" ? arguments[0] : stateHandle;
                preprocessor = arguments.length == 2 ? arguments[1] : arguments.length == 1 && typeof arguments[0] === "function" ? arguments[0] : function(s, f) { return f(s); };
                if (handle) {
                    try {
                        preprocessor(self.State.serialize(), function(_s) {
                            JTK.util.Storage.set(_c.jtkStatePrefix + handle, _s);
                        });
                    }
                    catch (e) {
                        JUTIL.log(_cl.msgCannotSaveState, e);
                    }
                }
            },
            /**
             * Serializes the UI state to a String.
             * @method State.serialize
             */
            serialize : function() {
                var o = panzoom.getPan();
                o.push(panzoom.getZoom());
                o.push.apply(o, panzoom.getTransformOrigin());
                var s = o.join(",");

                // elements.
                var p = self.getLayout().getPositions(), _p = [];
                for (var i in p) {
                    _p.push(i + " " + p[i][0] + " " + p[i][1]);
                }

                s += ("," + _p.join("|"));

                return s;
            },
            /**
             * Restores the UI state to the state it was in when it was saved with the given handle. If the handle does not
             * exist, nothing happens. It is possible a future incarnation of this could support animating a UI back to some state.
             * @method State.restore
             * @param {String} [handle] The handle to restore the state from, If this is not supplied, and `stateHandle` was supplied as a constructor parameter, that is used instead.
             * @param {Function} [preprocessor] Optional preprocessor which is given the serialized state before saving to localStorage. Useful if you wish to compress the data, for instance.
             */
            restore: function (handle, preprocessor) {
                handle = arguments.length == 2 ? arguments[0] : arguments.length == 1 && typeof arguments[0] === "string" ? arguments[0] : stateHandle;
                preprocessor = arguments.length == 2 ? arguments[1] : arguments.length == 1 && typeof arguments[0] === "function" ? arguments[0] : function(s, f) { return f(s); };

                if (handle) {
                    try {
                        var s = JTK.util.Storage.get(_c.jtkStatePrefix + handle);
                        if (s) {
                            preprocessor(s, self.State.deserialize);
                        }
                    }
                    catch (e) {
                        JUTIL.log(_cl.msgCannotRestoreState, e);
                    }
                }
            },
            /**
             * Restores the UI state to the serialized state given.
             * @method State.deserialize
             * @param {String} value Serialized state.
             */
            deserialize:function(value) {
                var _s = value.split(",");
                //panzoom.setPan(parseFloat(_s[0]), parseFloat(_s[1]));
                //panzoom.setZoom(parseFloat(_s[2]));
                //panzoom.setTransformOrigin(parseFloat(_s[3]), parseFloat(_s[4]));
                var p = _s[5].split("|"), l = self.getLayout();
                for (var i = 0; i < p.length; i++) {
                    var _p = p[i].split(" ");
                    try {
                        self.setPosition(_p[0], parseFloat(_p[1]), parseFloat(_p[2]));
                    }
                    catch (e) {
                        // consume. non fatal and we dont want to clog up the console.
                    }
                }

                l.draw();
            },
            /**
             * Clears the state that was stored against the given handle.
             * @method State.clear
             */
            clear: function (handle) {
                handle = handle || stateHandle;
                if (handle) {
                    JTK.util.Storage.clear(_c.jtkStatePrefix + handle);
                }
            },
            /**
             * Removes all saved UI state information.
             * @method State.clearAll
             */
            clearAll: function () {
                JTK.util.Storage.clearAll();
            }
        };

        /**
         * Saves the current state of the UI, either to local storage or a cookie, depending on the browser's capabilities.
         * @method saveState
         * @param {String} handle The handle to save the state as, If this is not supplied, and `stateHandle` was supplied as a constructor parameter, that is used instead.
         */
        self.saveState = self.State.save;

        self.store = JTK.util.Storage.set;
        self.retrieve = JTK.util.Storage.get;
        self.storeJSON = JTK.util.Storage.setJSON;
        self.retrieveJSON = JTK.util.Storage.getJSON;

        /**
         * Restores the current state of the UI, either from local storage or a cookie, depending on the browser's capabilities.
         * @method restoreState
         * @param {String} handle The handle to restore the state from, If this is not supplied, and `stateHandle` was supplied as a constructor parameter, that is used instead.
         */
        self.restoreState = function (handle) {
            self.State.restore(handle);
            self.getJsPlumb().repaintEverything();
            self.fire(_e.stateRestored);
        };

        /**
         * Clears the state stored by the given handle.
         * @method clearState
         * @param {String} handle The handle to restore the state from. If this is not supplied, and `stateHandle` was supplied as a constructor parameter, that is used instead.
         */
        self.clearState = function (handle) {
            self.state.clear(handle);
        };

        // ******************************* end of save/restore UI state (from either cookies or html5 storage, depending on the browser )

        // finally, initialize
        self.initialize();

        // prefer zoomToFitIfNecessary if it is set:
        if (params.zoomToFitIfNecessary)
            self.zoomToFitIfNecessary();
        // but if zoomToFit is set, do that.
        else if (params.zoomToFit)
            self.zoomToFit();
    };


    // register the Surface as the default renderer type for the Toolkit.  If the Toolkit is being used
    // server-side, this script will not have been included and so this won't be set.
    JTK.DefaultRendererType = _c.surfaceType;


}).call(typeof window !== 'undefined' ? window : this);

/*
 * Miniview
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 */

/**
 * The Miniview widget. A single instance of this is paired with an instance of Surface.
 *
 * The fundamental difference between this and a Surface is that a Miniview does not draw connections. Plus, it
 * calculates its own zoom based on the ratio of the size of its viewport compared to the size of the viewport of
 * the related Surface. In reality, a Miniview could reside inside an element that is much bigger than that in which
 * the related Surface resides, but it does not seem likely that that would normally be the case.
 *
 * The Miniview widget provides a floating window that represents a scaled version of the viewport of the related
 * Surface. Dragging this window around causes the related Surface to pan.  Resizing (via grabbing a corner and
 * dragging) the window causes the Surface to zoom in/out (within its allowed zoom range).
 *
 * All of the visual aspects of the Miniview can be controlled via CSS, and you can provide a custom CSS class
 * to allow you to target the styles for an individual Miniview more easily.
 *
 * You do not create a Miniview directly - you either specify its parameters in a `render` call on a `jsPlumbToolkitInstance`,
 * or you call `createMiniview` on an existing `Surface`.
 *
 * @class jsPlumbToolkit.Renderers.Miniview
 * @constructorg
 */
;
(function () {

    "use strict";

    var root = this;
    var JTK = root.jsPlumbToolkit,
        exports = JTK.Renderers,
        JUTIL = root.jsPlumbUtil,
        JP = root.jsPlumb,
        _cl = JTK.Classes,
        _c = JTK.Constants,
        _e = JTK.Events,
        _a = JTK.Attributes,
        _m = JTK.Methods;

    exports.Miniview = function (params) {
        this.bindToolkitEvents = false;
        var _super = exports.AbstractRenderer.apply(this, arguments), self = this;

        exports.DOMElementAdapter.apply(this, arguments);

        var surface = params.surface,
            containerElement = JP.getElement(params.container),
            canvasElement = exports.createElement({ position: _c.relative, width: _c.nominalSize, height: _c.nominalSize, left: 0, top: 0, clazz: _cl.MINIVIEW_CANVAS }, containerElement),
            pannerElement = exports.createElement({ position: _c.absolute, width: _c.nominalSize, height: _c.nominalSize, left: 0, top: 0, clazz: _cl.MINIVIEW_PANNER }, containerElement),
            surfaceBounds = params.bounds,
            suspended = params.suspended === true,
            _collapsible = params.collapsible !== false,
            typeFunction = params.typeFunction,
            _collapser = null,
            _collapsed = false,
            wheelSensitivity = params.wheelSensitivity || 10,
            panzoom = new ZoomWidget({
                viewport: containerElement,
                canvas: canvasElement,
                domElement: JP.getElement,
                offset: this.getOffset,
                bind: function () {
                    _super.jsPlumb.on.apply(_super.jsPlumb, arguments);
                },
                unbind: function () {
                    _super.jsPlumb.off.apply(_super.jsPlumb, arguments);
                },
                enableWheelZoom: false,
                enablePanButtons: false,
                enablePan: false,
                enableAnimation:false,
                width: function (el) {
                    return _super.jsPlumb.getWidth(_super.jsPlumb.getElement(el))
                },
                height: function (el) {
                    return _super.jsPlumb.getHeight(_super.jsPlumb.getElement(el))
                },
                id: _super.jsPlumb.getId,
                animate: _super.jsPlumb.animate,
                dragEvents: {
                    "stop": JP.dragEvents[_c.stop],
                    "start": JP.dragEvents[_c.start],
                    "drag": JP.dragEvents[_c.drag]
                },
                extend: JP.extend,
                events: {
                    pan: function () {
                        _updateSurface();
                    },
                    mousedown: function () {
                        JP.addClass(pannerElement, _cl.MINIVIEW_PANNING);
                    },
                    mouseup: function () {
                        JP.removeClass(pannerElement, _cl.MINIVIEW_PANNING);
                    }
                },
                zoomRange: [ -Infinity, Infinity ]
            }),
            panning = false, downAt = null, pannerAtMouseDown = null, zoomingWithWheel = false,
            elementFilter = params.elementFilter || function() { return true;},
            _downListener = function (e) {
                panning = true;
                downAt = panzoom.pageLocation(e);
                pannerAtMouseDown = JP.getAbsolutePosition(pannerElement);
                JP.on(document, _e.mouseup, _upListener);
                JP.on(document, _e.mousemove, _moveListener);
                JUTIL.consume(e);
            },
            _moveListener = function (e) {
                zoomingWithWheel = false;
                if (panning) {
                    var loc = panzoom.pageLocation(e),
                        dx = loc[0] - downAt[0],
                        dy = loc[1] - downAt[1],
                        newPannerPos = [pannerAtMouseDown[0] + dx, pannerAtMouseDown[1] + dy];

                    var clampedMovement = _updateSurface(newPannerPos);
                    JP.setAbsolutePosition(pannerElement, newPannerPos);
                }
            },
            _upListener = function (e) {
                panning = false;
                downAt = null;
                JP.off(document, _e.mouseup, _upListener);
                JP.off(document, _e.mousemove, _moveListener);
            },
            visible = true,
            pannerPos;

        var wheelZoom = function (e) {
            JUTIL.consume(e);
            surface.nudgeWheelZoom(e.normalizedWheelDelta * wheelSensitivity, e);
        };

        // bind to window resize, debounced.
        JP.on(window, _e.resize, jsPlumbToolkitUtil.debounce(function() {
            _updatePanner();
        }, 100));

        // bind mousewheel
        if (params.enableWheelZoom !== false) {
            addWheelListener(containerElement, wheelZoom);
        }

        // panzoom offers a helper method to do this for us.
        panzoom.setTransformOriginForElement(pannerElement, [0, 0]);

        // add jtk-miniview class to container
        JP.addClass(containerElement, _cl.MINIVIEW);

        // configure pannerElement
        JP.on(pannerElement, _e.mousedown, _downListener);

        // if collapsible, add the collapser.
        if (_collapsible) {
            _collapser = JP.createElement("div");
            _collapser.className = _cl.MINIVIEW_COLLAPSE;
            containerElement.appendChild(_collapser);
            JP.on(_collapser, _c.click, function (e) {
                _collapsed = !_collapsed;
                JP[_collapsed ? _m.addClass : _m.removeClass](containerElement, _cl.MINIVIEW_COLLAPSED);
                _zoomToFit(true);
            });
        }

        var _zoomToFit = function (doNotFirePanEvent) {
            panzoom.zoomToFit({
                onComplete: _updatePanner,
                onStep: _updatePanner,
                doNotFirePanEvent: doNotFirePanEvent
            });
        };

        params.toolkit.bind(_e.dataLoadEnd, _zoomToFit);

        var _nodeMoved = function (params) {
            var obj = params.node || params.group;
            if (obj && elementFilter(obj) === false) return;
            surfaceBounds = params.bounds;
            var miniviewElement = _super.nodeMap()[(params.node || params.group).id] || params.el;
            panzoom.positionChanged(miniviewElement, params.pos);
            JP.setAbsolutePosition(miniviewElement, params.pos);
            _zoomToFit(true);
            this.fire(_e.nodeMoveEnd, params); // perhaps fire groupMoveEnd from here if was a group?
        }.bind(this);

        var _migrateGroupMembers = function(group, groupEl) {
            var n = group.getNodes();
            for (var i = 0; i < n.length; i++) {
                var nodeEl = _super.nodeMap()[n[i].id];
                if (nodeEl) {
                    groupEl.appendChild(nodeEl);
                }
            }
        };

        var _nodeAdded = function (params, extraClasses) {
            if (params.node && elementFilter(params.node) === false) return;
            var s = JP.getSize(params.el),
                n = exports.createElement({ position: _c.absolute, width: s[0] + _c.px, height: s[1] + _c.px, left: 0, top: 0, clazz: _cl.MINIVIEW_ELEMENT + (extraClasses ? " " + extraClasses : "") });

            if (typeFunction) {
                n.setAttribute("jtk-miniview-type", typeFunction(params.node));
            }

            n.relatedElement = params.el;
            n.jtk = params.node;
            surfaceBounds = surface.getBoundsInfo();
            n.setAttribute(_a.jtkNodeId, params.node.id);
            n.setAttribute(_a.relatedNodeId, params.el.getAttribute(_c.id));
            canvasElement.appendChild(n);
            panzoom.add(n);
            _super.nodeMap()[(params.node || params.group).id] = n;

            if (params.group) {
                _migrateGroupMembers(params.group, n);
            }
            else if (params.node.group) {
                var groupEl = _super.nodeMap()[params.node.group.id];
                if (groupEl) {
                    groupEl.appendChild(n);
                    panzoom.suspend(params.el);
                }
            }

            self.getLayout().map(params.node.id, n);
            _updatePanner();
        };

        this.registerNode = function (params) {
            _nodeAdded(params, params.node.objectType === "Group" ? _cl.MINIVIEW_GROUP_ELEMENT : "");
            _nodeMoved(params);
        };

        var so = this.setOffset;
        this.setOffset = function (el, o) {
            so.apply(this, arguments);
            panzoom.positionChanged(el, [o.left, o.top]);
        };

        var sap = this.setAbsolutePosition;
        this.setAbsolutePosition = function (el, p) {
            sap.call(this, el, p);
            panzoom.positionChanged(el, p);
        };

        /**
         * Sets whether or not the miniview is visible. Strictly speaking you don't need to use this method;
         * you can just control the miniview's container via your own CSS or whatever. But the Surface uses this
         * occasionally, and there is also the concept of having the miniview initially invisible until the
         * related surface contains some data.
         */
        this.setVisible = function (v) {
            visible = v;
            containerElement.style.display = v ? _c.block : _c.none;
        };
        this.setVisible(params.visible !== false);

        /**
         * Gets the current [left,top] of the panned content.
         * @method getPan
         * @return {Number[]} [left,top], in pixels, of the panned content, where [0,0] is the origin of the viewport.
         */
        this.getPan = panzoom.getPan;

        var _showGroupMembers = function(group, state) {
            var n = group.getNodes();
            for (var i = 0; i < n.length; i++) {
                _super.nodeMap()[n[i].id].style.display = state ? "block" : "none";
            }
        };

        var repositionGroupMembers = function(group) {
            var n = group.getNodes();
            var groupPos = JP.getAbsolutePosition(_super.nodeMap()[group.id]);

            for (var i = 0; i < n.length; i++) {
                var nodeEl = _super.nodeMap()[n[i].id];
                var npos = JP.getAbsolutePosition(nodeEl);

                JP.setAbsolutePosition(nodeEl, [ groupPos[0] + npos[0], groupPos[1] + npos[1] ]);
            }
        };

        // TODO if this method is called when the miniview is not visible then the computed size of the element is [0,0],
        // and nothing is shown in the miniview the next time it becomes visible. so the question is, do we have a
        // general 'revalidate' method that goes and gets the position and the size of everything, or do we just
        // have a 'revalidateDirty' method that tracks stuff like this. Or do we have both (and does the Surface
        // have the revalidateDirty method too..it would be useful).
        var _objectRepainted = function (info) {
            var n = _super.nodeMap()[info.id];
            if (n) {
                var s = JP.getSize(n.relatedElement);
                n.style.width = s[0] + _c.px;
                n.style.height = s[1] + _c.px;
                _updatePanner();
                if (typeFunction) {
                    n.setAttribute("jtk-miniview-type", typeFunction(info.obj));
                }
            }
        };

        /**
         * Forces a repaint of every element.
         * @method invalidate
         */
        this.invalidate = function(id) {
            if (id) _objectRepainted({id:id});
            else
            {
                var nm = _super.nodeMap();
                for (var i in nm) {
                    _objectRepainted({id: i});
                }
            }
        };

        /**
         * Sets whether or not the miniview is currently suspended, ie. will not respond
         * to changes.
         * @method setSuspended
         * @param {Boolean} s Suspended or not.
         * @param {Boolean} [updateAfterwards] If true, will update the state after changing the suspended state. Only makes sense to use this if you are unsuspending the widget.
         */
        this.setSuspended = function (s, updateAfterwards) {
            suspended = s;
            updateAfterwards && this.update();
        };

        /**
         * Instructs the miniview to update its state.
         * @method update
         */
        this.update = _updatePanner;

        var _nodeRemoved = function (params) {
            var id = params.node, el = _super.nodeMap()[id];
            if (el) {
                panzoom.remove(el);
                delete _super.nodeMap()[id];
                _super.jsPlumb.removeElement(el);
            }

            // what else?
            if (!params.dontUpdatePanner)
                _updatePanner();
        };

        var _removeAllNodes = function () {
            var nm = _super.nodeMap();
            for (var id in nm)
                _nodeRemoved({node: id, dontUpdatePanner: true});

            _updatePanner();
        };

        // subscribe to the Zoom, Pan and nodeDragEnd events from the Surface.
        surface.bind(_e.pan, _updatePanner);
        surface.bind(_e.zoom, _updatePanner);
        surface.bind(_e.nodeMoveEnd, _nodeMoved);
        surface.bind(_e.nodeRemoved, _nodeRemoved);
        surface.bind(_e.nodeAdded, _nodeAdded);
        surface.bind(_e.nodeRendered, _nodeAdded);

        surface.bind(_e.groupMoveEnd, _nodeMoved);
        surface.bind(_e.groupAdded, function(p) { _nodeAdded(p, _cl.MINIVIEW_GROUP_ELEMENT); });
        surface.bind(_e.groupMoveEnd, _nodeMoved);
        surface.bind(_e.groupMemberAdded, function(p) {
            var groupEl = _super.nodeMap()[p.group.id], nodeEl = _super.nodeMap()[p.node.id];
            if (groupEl && nodeEl) {
                groupEl.appendChild(nodeEl);
            }
        });
        surface.bind(_e.groupMemberRemoved, function(p) {
            var  nodeEl = _super.nodeMap()[p.node.id];
            if (nodeEl) {
                canvasElement.appendChild(nodeEl);
            }
        });
        surface.bind(_e.groupCollapse, function(p) {
            _showGroupMembers(p.group, false);
            _objectRepainted({id: p.group.id});
        });
        surface.bind(_e.groupExpand, function(p) {
            _showGroupMembers(p.group, true);
            _objectRepainted({id: p.group.id});
        });

        surface.bind(_e.relayout, _updatePanner);
        surface.bind(_e.objectRepainted, _objectRepainted);
        surface.bind(_e.stateRestored, _updatePanner);
        params.toolkit.bind(_e.graphCleared, _removeAllNodes);

        //
        // bound to the host layout's 'redraw' event.
        //
        var _onLayoutRedraw = function () {
            _zoomToFit(true);
        };

        self.getLayout().bind(_e.redraw, _onLayoutRedraw);

        /**
         * Update the host layout for this miniview
         */
        this.setHostLayout = function (layout) {
            var current = self.getLayout();
            if (current)
                current.setHostLayout(layout);
        };

        function _updatePanner(params) {
            if (surface && panzoom && !suspended) {
                surfaceBounds = surface.getBoundsInfo();
                var scl = surface.getApparentCanvasLocation(),
                    ocl = panzoom.getApparentCanvasLocation(),
                    pz = panzoom.getZoom(),
                    pannerZoom = pz / (surfaceBounds.zoom);

                // size panner to the size of the viewport. we will subsequently scale it.
                pannerElement.style.width = surfaceBounds.vw + _c.px;
                pannerElement.style.height = surfaceBounds.vh + _c.px;
                // scale it
                panzoom.applyZoomToElement(pannerElement, pannerZoom);
                // move it
                var originMappedToPanner = [
                        scl[0] * pannerZoom,
                        scl[1] * pannerZoom
                ];

                pannerPos = [
                        ocl[0] - originMappedToPanner[0],
                        ocl[1] - originMappedToPanner[1]
                ];

                // then show the pannerElement in the appropriate location
                JP.setAbsolutePosition(pannerElement, pannerPos);
            }
        }

        function _updateSurface(pannerPos) {
            if (panzoom != null) {
                surfaceBounds = surface.getBoundsInfo();
                pannerPos = pannerPos || JP.getAbsolutePosition(pannerElement);

                var ocl = panzoom.getApparentCanvasLocation(),
                    pz = panzoom.getZoom(),
                    pannerZoom = pz / surfaceBounds.zoom,
                    sx = (ocl[0] - pannerPos[0]) / pannerZoom,
                    sy = (ocl[1] - pannerPos[1]) / pannerZoom;

                var clamped = surface.setApparentCanvasLocation(sx, sy);

                return [
                        ocl[0] - (clamped[0] * pannerZoom),
                        ocl[1] - (clamped[1] * pannerZoom)
                ];
            }
        }

        // this is here for testing; we may not keep it in the API.
        this.setZoom = panzoom.setZoom;
        this.getZoom = panzoom.getZoom;
        this.getTransformOrigin = panzoom.getTransformOrigin;
    };
}).call(typeof window !== 'undefined' ? window : this);

/*
 * Lasso
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 */
;
(function () {

    "use strict";

    var root = this;
    var JTK = root.jsPlumbToolkit;
    var exports = JTK.Widgets;
    var JUTIL = root.jsPlumbUtil;

    var isTouchDevice = 'ontouchstart' in document.documentElement,
        downEvent = isTouchDevice ? "touchstart" : "mousedown",
        upEvent = isTouchDevice ? "touchend" : "mouseup",
        moveEvent = isTouchDevice ? "touchmove" : "mousemove",
        setSize = function (el, s) {
            el.style.width = s[0] + "px";
            el.style.height = s[1] + "px";
        },
        cls = {
            SELECT_DEFEAT:"jtk-lasso-select-defeat",
            LASSO:"jtk-lasso",
            LASSO_MASK:"jtk-lasso-mask",
            LASSO_MASK_LEFT:"jtk-lasso-mask-left",
            LASSO_MASK_TOP:"jtk-lasso-mask-top",
            LASSO_MASK_RIGHT:"jtk-lasso-mask-right",
            LASSO_MASK_BOTTOM:"jtk-lasso-mask-bottom"
        },
        evt = {
            SELECT_START:"onselectstart"
        },
        devnull = function() {};

    /**
     * The Lasso widget allows users to select an area with the mouse. You will not typically need to interact with
     * this widget, or create one manually, since the `Surface` widget handles all of that for you.
     * @class jsPlumbToolkit.Widgets.Lasso
     * @constructor
     * @param {Object} params Parameters for the widget.
     * @param {Function} params.pageLocation Function that can return a page location for an event.
     * @param {Element} params.canvas DOM Element on which the Lasso will operate.
     * @param {Boolean} [params.invert=false] If true, the lasso is drawn as blank space over the selected area, with
     * elements filling the excluded area.
     * @param {Function} [params.onStart] Optional function to call at the start of a lasso operation.
     * @param {Function} [params.onEnd] Optional function to call at the end of a lasso operation.
     * @param {Function} [params.onSelect] Optional function to call on each mousemove during a lasso operation.
     * @param {String} [params.filter] Optional CSS selector identifying elements that should be filtered and not begin a lasso operation.
     */
    exports.Lasso = function (params) {
        var canvas = params.canvas,
            enabled = false,
            el, masks = {},
            origin = [0, 0],
            onStart = params.onStart || devnull,
            onEnd = params.onEnd || devnull,
            onSelect = params.onSelect || devnull,
            down = false, moving = false,
            invert = params.invert === true,
            _position = function(origin, size) {
                if (!invert) {
                    jsPlumb.setAbsolutePosition(el, origin);
                    setSize(el, size);
                }
                else {
                var ww = window.innerWidth, wh = window.innerHeight,
                    wsx = window.scrollX, wsy = window.scrollY,

                    t = wh - origin[1] + wsy,
                    b = (wh - t) + size[1],
                    l = ww - origin[0] + wsx,
                    r = (ww-l) + size[0];

                    masks.top.style.bottom = t + "px";
                    masks.bottom.style.top = b + "px";
                    masks.left.style.right = l + "px";
                    masks.right.style.left = r + "px";

                    masks.top.style.left = (ww-l) + "px";
                    masks.top.style.right = (ww-r) + "px";
                    masks.bottom.style.left = (ww-l) + "px";
                    masks.bottom.style.right = (ww-r) + "px";
                }
            },
            _setVisible = function(state) {
                var d = state ? "block" : "none";
                if (!invert) {
                    el.style.display = d;
                }
                else {
                    masks.top.style.display = d;
                    masks.left.style.display = d;
                    masks.right.style.display = d;
                    masks.bottom.style.display = d;
                }

                jsPlumb[state ? "addClass" : "removeClass"](document.body, cls.SELECT_DEFEAT);
            },
            downListener = function (e) {
                if (enabled && !filter(e)) {
                    JUTIL.consume(e);
                    down = true;
                    params.on(document, upEvent, upListener);
                    params.on(document, moveEvent, moveListener);
                    params.on(document, evt.SELECT_START, onSelectStartListener);
                    origin = params.pageLocation(e);

                    _position(origin, [1, 1]);

                    onStart(origin, e.shiftKey);
                }
            },
            moveListener = function (e) {
                if (down) {
                    if (!moving) {
                        _setVisible(true);
                        moving = true;
                    }
                    JUTIL.consume(e);
                    var pl = params.pageLocation(e),
                        s = [ Math.abs(pl[0] - origin[0]), Math.abs(pl[1] - origin[1]) ],
                        o = [Math.min(origin[0], pl[0]), Math.min(origin[1], pl[1])];

                    _position(o, s);

                    onSelect(o, s, [origin[0] < pl[0], origin[1] < pl[1]], e.shiftKey);
                }
            },
            upListener = function (e) {
                if (down) {
                    down = false;
                    moving = false;
                    JUTIL.consume(e);
                    params.off(document, upEvent, upListener);
                    params.off(document, moveEvent, moveListener);
                    params.off(document, evt.SELECT_START, onSelectStartListener);
                    _setVisible(false);
                    onEnd();
                }
            },
            onSelectStartListener = function () {
                return false;
            },
            filter = params.filter ? function (e) {
                var t = e.srcElement || e.target;
                return JUTIL.matchesSelector(t, params.filter);
            } : function () {
                return false;
            },
            _createEl = function(classNames) {
                var e = document.createElement("div");
                e.className = classNames.join(" ");
                document.body.appendChild(e);
                return e;
            },
            _createMasks = function() {
                masks.top = _createEl([cls.LASSO_MASK, cls.LASSO_MASK_TOP]);
                masks.bottom = _createEl([cls.LASSO_MASK, cls.LASSO_MASK_BOTTOM]);
                masks.left  = _createEl([cls.LASSO_MASK, cls.LASSO_MASK_LEFT]);
                masks.right = _createEl([cls.LASSO_MASK, cls.LASSO_MASK_RIGHT]);
            };

        if (!invert) {
            el = _createEl([cls.LASSO]);
        }
        else {
            _createMasks();
        }

        params.on(canvas, downEvent, downListener);

        /**
         * Returns whether or not the lasso is active.
         * @method isActive
         * @return {Boolean} true if active, false otherwise.
         */
        this.isActive = function () {
            return down;
        };

        /**
         * Sets whether or not the lasso responds to mouse events.
         * @method setEnabled
         * @param {Boolean} e Enabled state.
         */
        this.setEnabled = function (e) {
            enabled = e;
        };
    };

}).call(typeof window !== 'undefined' ? window : this);

/*
 * Dialogs
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 */
/**
 * A library for providing simple dialogs to use with an instance of the jsPlumb Toolkit.
 * @class jsPlumbToolkit.Dialogs
 */
;
(function () {

    "use strict";

    var root = this;
    var JSPLUMB = root.jsPlumb;
    var ROTORS = root.Rotors;

    var cache = {}, current, underlay, overlay, title, content, buttons, onOK, onCancel, onOpen,
        onMaybeClose, onClose,
        btnOk, btnCancel, labels = {
            ok:"OK",
            cancel:"Cancel"
        },
        container = document.body,
        visible = false,
        _rotors = ROTORS.newInstance({
            templateResolver:function(id) {
                return templates[id] || document.getElementById(id).innerHTML;
            }
        }),
        globals = {},
        reposition = true,
        templates = {};

    // create underlay and bind click listener on it (it closes the current dialog)
    JSPLUMB.ready(function () {

        underlay = document.createElement("div");
        underlay.className = "jtk-dialog-underlay";

        JSPLUMB.on(underlay, "click", function () {
            _close(true);
        });

        overlay = document.createElement("div");
        overlay.className = "jtk-dialog-overlay";

        title = document.createElement("div");
        title.className = "jtk-dialog-title";
        overlay.appendChild(title);

        content = document.createElement("div");
        content.className = "jtk-dialog-content";
        overlay.appendChild(content);

        buttons = document.createElement("div");
        buttons.className = "jtk-dialog-buttons";
        overlay.appendChild(buttons);
    });

    var _createButtons = function(params) {
        buttons.innerHTML = "";

        if (params.buttons) {
            var btn;
            for (var i = 0; i < params.buttons.length; i++) {
                btn = params.buttons[i];
                buttons.appendChild(btn);
                if (btn.getAttribute("jtk-commit") === "true") {
                    JSPLUMB.on(btn, "click", function () {
                        _close();
                    });
                } else if (btn.getAttribute("jtk-cancel") === "true") {
                    JSPLUMB.on(btn, "click", function () {
                        _close(true);
                    });
                }
            }
        } else {

            btnOk = document.createElement("button");
            btnOk.className = "jtk-dialog-button jtk-dialog-button-ok";
            btnOk.innerHTML = labels.ok;
            buttons.appendChild(btnOk);
            JSPLUMB.on(btnOk, "click", function () {
                _close();
            });

            btnCancel = document.createElement("button");
            btnCancel.className = "jtk-dialog-button jtk-dialog-button-cancel";
            btnCancel.innerHTML = labels.cancel;
            btnCancel.setAttribute("jtk-cancel", "true");
            buttons.appendChild(btnCancel);
            JSPLUMB.on(btnCancel, "click", function () {
                _close(true);
            });

            // set labels:
            btnOk.innerHTML = params.labels ? params.labels.ok || labels.ok : labels.ok;
            btnCancel.innerHTML = params.labels ? params.labels.cancel || labels.cancel : labels.cancel;
        }
    };

    var _cleanupButtons = function() {
        var buttonList = buttons.children;
        for (var i = 0; i < buttonList.length; i++) {
            buttonList[i].parentNode.removeChild(buttonList[i]);
        }
    };

    var _positioners = {
        x:function(docElem, isBody, s) {
            var dw = container.clientWidth, l = (dw - s[0]) / 2;
            var scrollLeft = window.pageXOffset || docElem.scrollLeft || document.body.scrollLeft;
            if (l < 0) l = 10;
            scrollLeft = isBody ? scrollLeft : container.scrollLeft;
            overlay.style.left = l + scrollLeft + "px";
        },
        y:function(docElem, isBody, s) {
            var dh = container.clientHeight, t = 0.1 * dh;
            var scrollTop = window.pageYOffset || docElem.scrollTop || document.body.scrollTop;
            if (t < 0) t = 10;
            scrollTop = isBody ? scrollTop : container.scrollTop;
            overlay.style.top = t + scrollTop + "px";
        }
    };

    var _positionOverlay = function () {
        if (visible) {
            var docElem = document.documentElement,
                s = JSPLUMB.getSize(overlay),
                isBody = container == document.body,
                axis = overlay.getAttribute("data-axis");

            underlay.style.position = isBody ? "fixed" : "absolute";
            _positioners[axis](docElem, isBody, s);
        }
    };

    var keyListener = function (e) {
        if (e.keyCode == 27)
            _close(true);
    };

    var _resolveContainer = function (c) {
        if (c == null) return document.body;
        else if (typeof c === "string")
            return document.getElementById(c);
        else
            return c;
    };

    // set the current dialog
    var _setCurrent = function (params) {
        var i;

        if (!params.id || !cache[params.id]) return;

        reposition = params.reposition !== false;
        onOK = params.onOK;
        onCancel = params.onCancel;
        onOpen = params.onOpen;
        onMaybeClose = params.onMaybeClose;
        onClose = params.onClose;

        var position = params.position || "top",
            positionClass = "jtk-dialog-overlay-" + position,
            axis = (position === "top" || position === "bottom" ? "x" : "y"),
            axisClass = "jtk-dialog-overlay-" + axis;

        _createButtons(params);

        container = _resolveContainer(params.container);

        var d = params.data || {}, t = _rotors.template(params.id, d);

        title.innerHTML = params.title || cache[params.id].title || "";
        content.innerHTML = "";
        var childNodeCount = t.childNodes.length;
        for (i = 0; i < childNodeCount; i++) {
            content.appendChild(t.childNodes[0]);
        }

        container.appendChild(underlay);
        container.appendChild(overlay);

        JSPLUMB.addClass(overlay, positionClass);
        JSPLUMB.addClass(overlay, axisClass);

        underlay.style.display = "block";
        overlay.style.display = "block";
        overlay.setAttribute("data-position", position);
        overlay.setAttribute("data-axis", axis);

        // hide/show cancel button
        var cancelVisibleState = cache[params.id].cancelable ? "visible" : "hidden";
        var cancelButtons = buttons.querySelectorAll("[jtk-cancel='true']");
        for (i = 0; i < cancelButtons.length; i++) {
            cancelButtons[i].style.visibility = cancelVisibleState;
        }

        visible = true;
        _positionOverlay();
        _setData(d);

        JSPLUMB.on(document, "keyup", keyListener);
        // on window resize/scroll, ensure dialog stays in the middle.
        if (reposition) {
            JSPLUMB.on(window, "resize", _positionOverlay);
            JSPLUMB.on(window, "scroll", _positionOverlay);
        }

        // attach a clear button/clear all button handler
        JSPLUMB.on(overlay, "click", "[jtk-clear]", function(e) {
            var a = this.getAttribute("jtk-att");
            if (a) {
                _clear(overlay.querySelectorAll("[jtk-att='" + a + "']:not([jtk-clear])"), this);
            }
        });

        JSPLUMB.on(overlay, "click", "[jtk-clear-all]", function(e) {
            _clear(overlay.querySelectorAll("[jtk-att]:not([jtk-clear])"), this);
        });

        globals.onOpen && globals.onOpen(overlay);
        onOpen && onOpen(overlay);
        JSPLUMB.addClass(overlay, "jtk-dialog-overlay-visible");

        // perhaps set the focus
        try {
            var focusNode = content.querySelector("[jtk-focus]");
            focusNode && setTimeout(function () {
                focusNode.focus();
            }, 0);
        }
        catch (e) {
        } // old IE throws error if you try to focus a hidden el. so this is just in case.
    };

    var _setData = function (data) {
        var atts = content.querySelectorAll("[jtk-att]");
        for (var i = 0; i < atts.length; i++) {
            var t = atts[i].tagName.toUpperCase(),
                tt = t === "INPUT" ? (atts[i].getAttribute("type") || "TEXT").toUpperCase() : t,
                a = atts[i].getAttribute("jtk-att"),
                v = _rotors.data(data, a);

            if (v != null) {
                _setHandlers[tt](atts[i], v);
            }

            // ENABLE COMMIT VIA enter key.
            if (atts[i].getAttribute("jtk-commit")) {
                if (t === "INPUT") {
                    JSPLUMB.on(atts[i], "keyup", function (e) {
                        if (e.keyCode == 10 || e.keyCode == 13)
                            _close();
                    });
                }
                else if (t === "TEXTAREA") {
                    JSPLUMB.on(atts[i], "keyup", function (e) {
                        if (e.ctrlKey && (e.keyCode == 10 || e.keyCode == 13))
                            _close();
                    });
                }
            }
        }
    };

    var _setHandlers = {
        "TEXT": function (el, v) {
            el.value = v;
        },
        "RADIO": function (el, v) {
            el.checked = el.value == v;
        },
        "CHECKBOX": function (el, v) {
            el.checked = v == true;
        },
        "SELECT": function (el, v) {
            for (var i = 0; i < el.options.length; i++) {
                if (el.options[i].value == v) {
                    el.selectedIndex = i;
                    return;
                }
            }
        },
        "TEXTAREA": function (el, v) {
            el.value = v;
        }
    };

    var _getHandlers = {
        "TEXT": function (el) {
            return el.value;
        },
        "RADIO": function (el) {
            if (el.checked) return el.value;
        },
        "CHECKBOX": function (el) {
            if (el.checked) return true;
        },
        "SELECT": function (el) {
            return el.selectedIndex != -1 ? el.options[el.selectedIndex].value : null;
        },
        "TEXTAREA": function (el) {
            return el.value;
        }
    };

    var _clearHandlers = {
        "TEXT": function (el) {
            el.value = "";
        },
        "RADIO": function (el) {
            el.checked = false;
        },
        "CHECKBOX": function (el) {
            el.checked = false;
        },
        "SELECT": function (el) {
            el.selectedIndex = -1;
        },
        "TEXTAREA": function (el) {
            el.value = "";
        }
    };

    var _clear = function(els, source) {
        for (var i = 0; i < els.length; i++) {
            if (els[i] === source) continue;
            var t = els[i].tagName.toUpperCase(),
                tt = t === "INPUT" ? (els[i].getAttribute("type") || "TEXT").toUpperCase() : t,
                ch = _clearHandlers[tt];
            if (ch) {
                ch(els[i]);
            }
        }
    };

    var _getData = function () {
        var atts = content.querySelectorAll("[jtk-att]"),
            out = {};

        for (var i = 0; i < atts.length; i++) {
            var t = atts[i].tagName.toUpperCase(),
                tt = t === "INPUT" ? (atts[i].getAttribute("type") || "TEXT").toUpperCase() : t,
                v = _getHandlers[tt](atts[i]),
                a = atts[i].getAttribute("jtk-att");

            if (v != null) {
                var existing = _rotors.data(out, a);
                if (existing != null) {
                    if (!jsPlumbUtil.isArray(existing))
                        _rotors.data(out, a, [ existing ]);

                    existing.push(v);
                }
                else
                    _rotors.data(out, a, v);
            }
        }

        return out;

        // input of type text : value
        // textarea: value
        // input type radio: if checked, value
        // checkbox: value (create array if necessary)
        // select: value of selected option
        // multi select: array of values of selected options.
        // sliders etc. spinners etc.
    };

    var _proxy = function(fn, otherArguments) {
        try {
            if (fn != null)
                fn.apply(fn, Array.prototype.slice.apply(arguments, [1]));
        }
        catch (e) { }
    };

    var _close = function (wasCancelled) {

        var data = wasCancelled ? null : _getData() ;

        if (!wasCancelled && onMaybeClose != null && onMaybeClose(data) === false) return;

        visible = false;
        underlay.style.display = "none";
        overlay.style.display = "none";

        JSPLUMB.off(document, "keyup", keyListener);
        // on window resize/scroll, ensure dialog stays in the middle.
        JSPLUMB.off(window, "resize", _positionOverlay);
        JSPLUMB.off(window, "scroll", _positionOverlay);

        JSPLUMB.removeClass(overlay, "jtk-dialog-overlay-visible");
        JSPLUMB.removeClass(overlay, "jtk-dialog-overlay-top");
        JSPLUMB.removeClass(overlay, "jtk-dialog-overlay-bottom");
        JSPLUMB.removeClass(overlay, "jtk-dialog-overlay-left");
        JSPLUMB.removeClass(overlay, "jtk-dialog-overlay-right");
        JSPLUMB.removeClass(overlay, "jtk-dialog-overlay-x");
        JSPLUMB.removeClass(overlay, "jtk-dialog-overlay-y");
        overlay.setAttribute("data-position", "");
        overlay.setAttribute("data-axis", "");

        container.removeChild(underlay);
        container.removeChild(overlay);

        _cleanupButtons();

        if (wasCancelled) {
            _proxy(globals.onCancel, content);
            _proxy(onCancel, content);
        }
        else {
            _proxy(globals.onOK, data, content);
            _proxy(onOK, data, content);
        }

        _proxy(globals.onClose);
        _proxy(onClose);


        onOK = onCancel = onOpen = onClose = onMaybeClose = current = null;
    };

    root.jsPlumbToolkit.Dialogs = {
        /**
         * Initialize all the dialogs found on the page.
         * @method initialize
         * @static
         * @param {Object} params Method parameters
         * @param {Object} [params.dialogs] Optional map of dialog IDs to [content, title, isCancelable] arrays. Use this
         * instead of providing a selector if you wish to supply dialog information via JS and not as templates in the HTML.
         * @param {String} [params.selector='.jtk-dialog'] Selector identifying dialog elements. If not provided, the value '.jtk-dialog' is used by default.
         * @param {Object} [params.globals] Optional object of global callbacks, keyed by event id.
         * @param {Object} [params.labels] Optional object of button labels. See documentation.
         */
        initialize: function (params) {
            params = params || {};
            cache = {};
            if (params.dialogs) {
                for (var d in params.dialogs) {
                    templates[d] = params.dialogs[d][0];
                    cache[d] = {
                        content:templates[d],
                        title:params.dialogs[d][1] || "",
                        cancelable:params.dialogs[d][2] !== false
                     }
                }
            }
            else {
                var sel = params.selector || ".jtk-dialog",
                    els = JSPLUMB.getSelector(sel);

                for (var i = 0; i < els.length; i++) {
                    var id = els[i].getAttribute("id");
                    if (id != null) {
                        cache[id] = {
                            content: els[i].innerHTML,
                            title: els[i].getAttribute("title") || "",
                            el: els[i],
                            cancelable: els[i].getAttribute("cancel") !== "false"
                        };
                    }
                }
            }

            // override default labels if labels provided
            if (params.labels) {
                JSPLUMB.extend(labels, params.labels);
            }

            if (params.globals) {
                JSPLUMB.extend(globals, params.globals);
            }
        },
        /**
         * Show the dialog with the given id, optionally rendering it with some provided data.
         * @method show
         * @static
         * @param {Object} params Method parameters
         * @param {String} params.id ID of the dialog to show
         * @param {Object} [params.data] Optional data to render the dialog template with.
         * @param {String} [params.title] Title for the dialog. If not supplied, the dialog's title will come from the `title` attribute of the associated template, if any. Otherwise it will be blank.
         * @param {Function} [params.onOpen] Optional function to run once the dialog has opened.
         * @param {Function} [params.onOK] Optional function to run when the user presses OK.
         * @param {Function} [params.onCancel] Optional function to run when the user presses cancel.
         * @param {Function} [params.onClose] Optional function to call when the dialog is closed, regardless of how it was closed.
         * @param {Function} [params.onMaybeClose] Optional function that will be called prior to `onOK` being called, with the same data that will be passed to `onOK`. Returning false from this function causes the dilaog to remain open.
         */
        show: _setCurrent,

        /**
         * Hide the current dialog as if the cancel button was pressed.
         * @method hide
         * @static
         */
        hide:function() { _close(true); },

        /**
         * Clears the given set
         */
        clear:_clear
    }

    if (typeof exports !== "undefined") {
        exports.Dialogs = root.jsPlumbToolkit.Dialogs;
    }

}).call(typeof window !== 'undefined' ? window : this);


/*
 * Drawing
 *
 * Copyright 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * This software is not free.
 *
 */
;
(function () {
    "use strict";
    var root = this;

    /**
     * Provides a set of drawing tools to use in conjunction with a Surface in the Toolkit - select, drag, resize.
     * Everything this tool adds to the UI has an associated CSS class, so you can skin it very easily. There are no
     * methods on this class - you just construct one with the parameters you need.
     * @class jsPlumbToolkit.DrawingTools
     * @param {Object} params Constructor parameters.
     * @param {Surface} params.renderer Surface renderer to associate the tools with.
     * @param {String} [params.widthAttribute="w"] Name of the attribute used to store the node's width in its data.
     * @param {String} [params.heightAttribute="h"] Name of the attribute used to store the node's height in its data.
     * @param {String} [params.leftAttribute="left"] Name of the attribute used to store the node's left position in its data.
     * @param {String} [params.topAttribute="top"] Name of the attribute used to store the node's top position in its data.
     * @constructor
     */
    root.jsPlumbToolkit.DrawingTools = function (params) {

        var renderer = params.renderer,
            toolkit = renderer.getToolkit(),
            jsp = renderer.getJsPlumb(),
            skeletons = {},
            widthAtt = params.widthAttribute || "w",
            heightAtt = params.heightAttribute || "h",
            leftAtt = params.leftAttribute || "left",
            topAtt = params.topAttribute || "top",
            xAxis, yAxis;

        var _reset = function () {
            for (var id in skeletons) {
                var s = skeletons[id];
                if (s[0] && s[0].parentNode) {
                    s[0].parentNode.removeChild(s[0]);
                }
                delete skeletons[id];
            }
        };

        var _create = function (t, c, p, a) {
            var s = document.createElement(t);
            if (c) s.className = c;
            if (p) p.appendChild(s);
            if (a) {
                for (var i in a) {
                    s.setAttribute(i, a[i]);
                }
            }
            return s;
        };

        var _remove = function (id) {
            var s = skeletons[id];
            if (s && s[0] && s[0].parentNode) {
                s[0].parentNode.removeChild(s[0]);
            }
            delete skeletons[id];
        };

        var _deselect = function (node, renderer) {
            var el = renderer.getRenderedNode(node.id);
            _remove(node.id);
            return el;
        };

        var _select = function (node, renderer) {
            var el = _deselect(node, renderer);
            if (el != null) {
                var s = _create("div", "jtk-draw-skeleton", el),
                    x = el.getAttribute("jtk-x-resize"), y = el.getAttribute("jtk-y-resize");

                _create("div", "jtk-draw-drag", s);
                _create("div", "jtk-draw-handle jtk-draw-handle-tl", s, {"data-dir": "tl", "data-node-id": node.id });
                _create("div", "jtk-draw-handle jtk-draw-handle-tr", s, {"data-dir": "tr", "data-node-id": node.id });
                _create("div", "jtk-draw-handle jtk-draw-handle-bl", s, {"data-dir": "bl", "data-node-id": node.id });
                _create("div", "jtk-draw-handle jtk-draw-handle-br", s, {"data-dir": "br", "data-node-id": node.id });

                skeletons[node.id] = [ s, x !== "false", y !== "false" ];
            }
        };

        var downAt, handler, toolkitDragObject, x1, x2, y1, y2;

        var _dim = function (x, y, w, h) {
            var out = {};
            out[widthAtt] = xAxis ? w : (x2 - x1);
            out[heightAtt] = yAxis ? h : (y2 - y1);
            out[leftAtt] = xAxis ? x : x1;
            out[topAtt] = yAxis ? y : y1;
            return out;
        };

        var _dragHandlers = {
            "tl": function (dx, dy) {
                var x = x1 + dx, y = y1 + dy, w = x2 - x, h = y2 - y;
                if (x >= x2) {
                    w = x - x2;
                    x = x2;
                }

                if (y >= y2) {
                    h = y - y2;
                    y = y2;
                }

                return _dim(x, y, w, h);
            },
            "tr": function (dx, dy) {
                var w = (x2 - x1) + dx, y = y1 + dy, h = y2 - y, x = x1;
                if (w <= 0) {
                    x = x1 + w;
                    w *= -1;
                }

                if (y >= y2) {
                    h = y - y2;
                    y = y2;
                }

                return _dim(x, y, w, h);
            },
            "bl": function (dx, dy) {
                var x = x1 + dx, h = (y2 - y1) + dy, w = x2 - x, y = y1;
                if (x >= x2) {
                    w = x - x2;
                    x = x2;
                }
                if (h <= 0) {
                    y += h;
                    h *= -1;
                }
                return _dim(x, y, w, h);
            },
            "br": function (dx, dy) {
                var w = (x2 - x1) + dx, h = (y2 - y1) + dy, x = x1, y = y1;
                if (w <= 0) {
                    x = x1 + w;
                    w *= -1;
                }

                if (h <= 0) {
                    y += h;
                    h *= -1;
                }

                return _dim(x, y, w, h);
            }
        };

        toolkit.bind("selectionCleared", function () {
            _reset();
        });

        // - on select, add drawing primitives
        toolkit.bind("select", function (params) {
            _select(params.obj, renderer);
        });

        // - on deselect, remove drawing primitives.
        toolkit.bind("deselect", function (params) {
            _deselect(params.obj, renderer);
        });

        var moveListener = function (e) {
            var p = renderer.mapEventLocation(e),
                editingDx = (p.left - downAt.left),
                editingDy = (p.top - downAt.top);

            var newCoords = handler(editingDx, editingDy, "");
            toolkit.updateNode(toolkitDragObject, newCoords);
            renderer.setPosition(toolkitDragObject, newCoords[leftAtt], newCoords[topAtt], true);
        };

        var upListener = function (e) {
            renderer.storePositionInModel(toolkitDragObject.id);
            jsp.removeClass(document.body, "jtk-drag-select-defeat");
            jsp.off(document, "mousemove", moveListener);
            jsp.off(document, "mouseup", upListener);
            jsPlumbUtil.consume(e);
        };

        // - delegate bind to drag handles
        jsp.on(document, "mousedown", ".jtk-draw-handle", function (e) {
            var dir = this.getAttribute("data-dir"),
                nodeId = this.getAttribute("data-node-id");

            toolkitDragObject = toolkit.getNode(nodeId);
            xAxis = skeletons[nodeId][1];
            yAxis = skeletons[nodeId][2];

            downAt = renderer.mapEventLocation(e);
            // get the location and size of the element
            var c = renderer.getCoordinates(toolkitDragObject);
            x1 = c.x;
            y1 = c.y;
            x2 = x1 + c.w;
            y2 = y1 + c.h;

            handler = _dragHandlers[dir];

            jsp.addClass(document.body, "jtk-drag-select-defeat");

            jsp.on(document, "mousemove", moveListener);
            jsp.on(document, "mouseup", upListener);
        });

    };

    if (typeof exports !== "undefined") {
        exports.DrawingTools = root.jsPlumbToolkit.DrawingTools;
    }

}).call(typeof window !== 'undefined' ? window : this);